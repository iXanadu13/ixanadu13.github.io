import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as a,o as r}from"./app-BnosB2O8.js";const l={};function d(i,t){return r(),n("div",null,t[0]||(t[0]=[a('<h1 id="java线程同步方法对比" tabindex="-1"><a class="header-anchor" href="#java线程同步方法对比"><span>Java线程同步方法对比</span></a></h1><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">Thread#sleep</th><th style="text-align:center;">Object#wait</th><th style="text-align:center;">LockSupport#park</th></tr></thead><tbody><tr><td style="text-align:center;">调用方式</td><td style="text-align:center;">抛出中断异常</td><td style="text-align:center;">必须在synchronized块中、抛出中断异常。如果当前线程不是对象锁的拥有者，调用wait/notify会抛出 IllegalMonitorStateException 异常</td><td style="text-align:center;">无限制，无抛出</td></tr><tr><td style="text-align:center;">阻塞时是否释放当前线程占有的锁</td><td style="text-align:center;"><strong>不释放</strong></td><td style="text-align:center;"><strong>释放</strong></td><td style="text-align:center;"><strong>不释放</strong></td></tr><tr><td style="text-align:center;">传入参数</td><td style="text-align:center;">必须传入时间</td><td style="text-align:center;">可选传入超时时间</td><td style="text-align:center;">可选传入超时时间、阻塞原因blocker</td></tr><tr><td style="text-align:center;">唤醒方式</td><td style="text-align:center;">无法从外部唤醒</td><td style="text-align:center;">Object#notify，还需抢锁成功。<strong>wait前调用notify无效</strong></td><td style="text-align:center;">LockSupport#unpark，唤醒传入的执行线程。<strong>park前调用unpark有效</strong></td></tr><tr><td style="text-align:center;">中断响应</td><td style="text-align:center;">抛出中断异常，清除中断标志位</td><td style="text-align:center;">抛出中断异常，清除中断标志位</td><td style="text-align:center;">park方法返回，不抛异常，中断响应位依然为true</td></tr><tr><td style="text-align:center;">底层实现</td><td style="text-align:center;">native方法Thread#sleep0</td><td style="text-align:center;">native方法Object#wait0</td><td style="text-align:center;">调用Unsafe#park。类似只有一个许可证的Semaphore，且重复执行最多获得一个许可证</td></tr></tbody></table>',2)]))}const o=e(l,[["render",d],["__file","sync.html.vue"]]),g=JSON.parse(`{"path":"/posts/java/sync.html","title":"Java线程同步方法对比","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-04-28T00:00:00.000Z","category":["Java"],"tag":["多线程"],"description":"Java线程同步方法对比","head":[["meta",{"property":"og:url","content":"https://iXanadu13.github.io/posts/java/sync.html"}],["meta",{"property":"og:site_name","content":"Xanadu13's Blog"}],["meta",{"property":"og:title","content":"Java线程同步方法对比"}],["meta",{"property":"og:description","content":"Java线程同步方法对比"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-04T15:16:27.000Z"}],["meta",{"property":"article:tag","content":"多线程"}],["meta",{"property":"article:published_time","content":"2025-04-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-04T15:16:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java线程同步方法对比\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-04-28T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-04T15:16:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Xanadu13\\",\\"url\\":\\"https://github.com/iXanadu13\\"}]}"]]},"headers":[],"git":{"createdTime":1745855819000,"updatedTime":1754320587000,"contributors":[{"name":"Xanadu13","email":"xanadu13@qq.com","commits":5}]},"readingTime":{"minutes":0.9,"words":270},"filePathRelative":"posts/java/sync.md","localizedDate":"2025年4月28日","excerpt":"\\n<table>\\n<thead>\\n<tr>\\n<th style=\\"text-align:center\\"></th>\\n<th style=\\"text-align:center\\">Thread#sleep</th>\\n<th style=\\"text-align:center\\">Object#wait</th>\\n<th style=\\"text-align:center\\">LockSupport#park</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td style=\\"text-align:center\\">调用方式</td>\\n<td style=\\"text-align:center\\">抛出中断异常</td>\\n<td style=\\"text-align:center\\">必须在synchronized块中、抛出中断异常。如果当前线程不是对象锁的拥有者，调用wait/notify会抛出 IllegalMonitorStateException 异常</td>\\n<td style=\\"text-align:center\\">无限制，无抛出</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">阻塞时是否释放当前线程占有的锁</td>\\n<td style=\\"text-align:center\\"><strong>不释放</strong></td>\\n<td style=\\"text-align:center\\"><strong>释放</strong></td>\\n<td style=\\"text-align:center\\"><strong>不释放</strong></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">传入参数</td>\\n<td style=\\"text-align:center\\">必须传入时间</td>\\n<td style=\\"text-align:center\\">可选传入超时时间</td>\\n<td style=\\"text-align:center\\">可选传入超时时间、阻塞原因blocker</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">唤醒方式</td>\\n<td style=\\"text-align:center\\">无法从外部唤醒</td>\\n<td style=\\"text-align:center\\">Object#notify，还需抢锁成功。<strong>wait前调用notify无效</strong></td>\\n<td style=\\"text-align:center\\">LockSupport#unpark，唤醒传入的执行线程。<strong>park前调用unpark有效</strong></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">中断响应</td>\\n<td style=\\"text-align:center\\">抛出中断异常，清除中断标志位</td>\\n<td style=\\"text-align:center\\">抛出中断异常，清除中断标志位</td>\\n<td style=\\"text-align:center\\">park方法返回，不抛异常，中断响应位依然为true</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:center\\">底层实现</td>\\n<td style=\\"text-align:center\\">native方法Thread#sleep0</td>\\n<td style=\\"text-align:center\\">native方法Object#wait0</td>\\n<td style=\\"text-align:center\\">调用Unsafe#park。类似只有一个许可证的Semaphore，且重复执行最多获得一个许可证</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}`);export{o as comp,g as data};
