import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c,d as o,b as e,f as r,g as n,r as l,o as u,e as a}from"./app-D5QkqpoG.js";const g="/assets/images/scholar/C2RustSafe/figure1.png",p="/assets/images/scholar/C2RustSafe/table1.png",d={};function f(h,t){const s=l("RouteLink");return u(),c("div",null,[t[2]||(t[2]=o('<h1 id="in-rust-we-trust-–-a-transpiler-from-unsafe-c-to-safer-rust" tabindex="-1"><a class="header-anchor" href="#in-rust-we-trust-–-a-transpiler-from-unsafe-c-to-safer-rust"><span>In Rust We Trust – A Transpiler from Unsafe C to Safer Rust</span></a></h1><p>论文来自 2022 IEEE International Conference on Software Engineering (ICSE 22) 的《<a href="https://dl.acm.org/doi/abs/10.1145/3510454.3528640" target="_blank" rel="noopener noreferrer">In Rust We Trust – A Transpiler from Unsafe C to Safer Rust</a>》。</p><h2 id="摘要" tabindex="-1"><a class="header-anchor" href="#摘要"><span>摘要</span></a></h2><p>Rust 是一种<strong>类型安全</strong>的系统编程语言，其编译器会检查内存与并发安全。为便于从既有 C 项目平滑迁移，可使用<strong>源到源（source-to-source）转译器</strong>通过程序变换将 C 程序自动转换为 Rust。然⽽，现有的 C→Rust 变换工具（例如开源的 C2Rust 转译器<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>）存在一个缺点：<strong>保留了 C 的不安全语义，仅将其改写为 Rust 的语法</strong>。Emre 等人 [2] 指出了这些问题，并利用 <code>rustc</code> 编译器的反馈，将某一类原始指针（raw pointers）重构为 Rust 引用，以提升 C2Rust 输出的整体安全性与“惯用性”（idiomaticness）。</p><p>我们聚焦于提升 <strong>API 安全性</strong>（即在函数签名中尽量减少 <code>unsafe</code> 关键字的使用），采用源到源变换技术，基于<strong>代码结构的模式匹配与变换</strong>，对 C2Rust 的输出进行自动重构；该方法<strong>不依赖</strong> <code>rustc</code> 的编译器反馈。进一步地，通过<strong>放宽变换的语义保持（semantics-preserving）约束</strong>，我们提出 <strong>CRustS</strong>：一种全自动的源到源变换方法，可<strong>提高转换后代码通过 <code>rustc</code> 安全检查的比例</strong>。</p><p>我们的方法新增了 <strong>220 条 TXL [1] 源到源变换规则</strong>，其中 <strong>198 条严格保持语义</strong>，<strong>22 条为语义近似（semantics-approximating）</strong>；由此<strong>缩小了不安全表达式的范围</strong>，并<strong>暴露出更多可进行安全 Rust 重构的机会</strong>。我们在开源与商业 C 项目上对该方法进行了评估；结果显示，变换之后的<strong>安全代码占比显著提高</strong>，其<strong>函数级别</strong>的安全代码占比<strong>可与惯用 Rust 项目的平均水平相当</strong>。</p><h2 id="关键词" tabindex="-1"><a class="header-anchor" href="#关键词"><span>关键词</span></a></h2><p>transpiler, safety, measurement, refactoring, code transformation</p><h2 id="_1-引言" tabindex="-1"><a class="header-anchor" href="#_1-引言"><span>1. 引言</span></a></h2><p>为了受益于 <code>rustc</code> 编译器内置的内存与并发安全保障 [4]，转译得到的 Rust 程序必须避免<strong>不必要</strong>的 <code>unsafe</code> 关键字使用，因为它会降低对被标注的函数或代码块的安全检查力度。流行的、人工编写的 <strong>惯用（idiomatic）</strong> Rust 项目通常有大约 <strong>20%–30%</strong> 的代码被标记为 <code>unsafe</code> [5]<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>。这些 <code>unsafe</code> 大多是为换取较低层级的效率或硬件相关操作而作出的权衡 [3]。</p><p>然而，当前的 C→Rust 转译工具（如 <code>c2rust</code>）为了生成<strong>语义等价</strong>的 Rust 代码，往往会在<strong>几乎所有的函数签名</strong>中使用 <code>unsafe</code>，从而产出<strong>不够惯用</strong>的 Rust 代码。这显著限制了 <code>rustc</code> 编译器在转译后 Rust 代码上能够执行的安全检查。此外，即便语义上等价，部分 Rust 代码也常因<strong>违背 Rust 设计</strong>而无法通过编译；例如，在<strong>运行时</strong>初始化静态变量在 C 中是合法的，但在 Rust 中不是。</p><p>虽然 <code>c2rust</code> 提供了命令行重构工具 [6]，用户可以手动撰写命令来改进生成的 Rust 代码，但这需要大量的人工工作以及对源代码相当全面的理解。</p><p>在本文中，我们基于 <code>c2rust</code> 构建了一个转译系统，重点在于生成<strong>可编译</strong>的 Rust 程序，并提升<strong>通过编译器检查的安全代码比例</strong>。我们的方法旨在<strong>系统性</strong>地消除函数签名中<strong>非必需</strong>的 <code>unsafe</code> 关键字，并在<strong>完全自动化</strong>的方式下，细化安全函数内部 <code>unsafe</code> 代码块（block）的作用域。</p><hr><h2 id="_2-我们的方法-our-approach" tabindex="-1"><a class="header-anchor" href="#_2-我们的方法-our-approach"><span>2. 我们的方法（OUR APPROACH）</span></a></h2><p>依据 <em>The Rust Reference</em>，<code>unsafe</code> 可以用于四种上下文：<strong>函数限定符（Function qualifiers）</strong>、<strong><code>unsafe</code> 代码块</strong>、<strong>Trait</strong> 以及 <strong>Trait 实现（Trait Implementations）</strong>。</p><p>在纯 Rust 项目与 C→Rust 转译项目中，绝大多数涉及 <code>unsafe</code> 的 Rust 代码属于前两类上下文，也是本文关注的重点。我们首先处理<strong>函数限定符</strong>中的 <code>unsafe</code>，原因在于：</p><ul><li>这是 <code>c2rust</code> 转译代码中 <code>unsafe</code> 的<strong>主要使用方式</strong>；</li><li>它会使函数体中的<strong>所有语句</strong>都被视为 <code>unsafe</code>，因此对<strong>整体安全比例</strong>的影响更大；</li><li>它具有<strong>多米诺效应</strong>：凡是使用了 <code>unsafe</code> 的函数，在调用处要么必须被 <code>unsafe</code> 代码块包裹，要么被声明为 <code>unsafe</code>（例如当该函数作为参数被传递时）；</li><li>其中<strong>大多数</strong>可以通过<strong>将函数体内所有不安全语句包裹进 <code>unsafe</code> 代码块</strong>来移除函数签名上的 <code>unsafe</code>。</li></ul><p>对于 <strong><code>unsafe</code> 代码块</strong> 本身，我们的策略很简单：<strong>将其拆分</strong>为<strong>每条语句一个</strong>的 <code>unsafe</code> 块，然后删除<strong>非必需</strong>的 <code>unsafe</code>。对于相邻的 <code>unsafe</code> 块，我们再进行<strong>合并</strong>，并在考虑<strong>命名作用域</strong>的情况下，必要时把中间的一些语句也纳入其中。</p><hr><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们将<strong>不安全 C</strong> 迁移到<strong>安全 Rust</strong> 的主要处理步骤如<strong>图1</strong> 所示。该流程在 <code>c2rust</code> 的基础上扩展了以下组件：</p><ul><li><strong><code>c-builder</code></strong>：自动化构建 C 源项目（支持 Make、CMake 或 Bazel），并生成 <code>c2rust</code> 所需的中间产物（例如 <code>compile_commands.json</code>）；</li><li><strong>调用 <code>c2rust</code></strong>：将 C 项目转译为一个 Rust 项目；</li><li><strong><code>build-fixer</code></strong>：依据 <code>rustc</code> 的报错提示修复构建错误；</li><li><strong>TXL 规则</strong>：自动重构 Rust 代码，以<strong>减少</strong> <code>unsafe</code> 的<strong>使用频度与作用域</strong>。</li></ul><hr><p>一个 <strong>TXL</strong> 程序通常由许多<strong>独立的变换规则</strong>组成。每条规则完成一种特定的代码变换；例如，依据硬件规格，将 C 库类型 <code>libc::c_short</code> 转换为 Rust 原生类型 <code>i16</code>。</p><p>应用 TXL 变换规则的主要步骤是：</p><ol><li><strong>解析</strong> Rust 源文件，生成<strong>语法树</strong>；</li><li><strong>应用用户自定义的变换规则</strong>，重写语法树中需要修改的部分，例如：把<strong>语法范畴</strong>为 <code>TypeNoBounds</code><sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>、其取值为 <code>libc::c_short</code> 的<strong>每个节点</strong>替换为同一语法范畴但取值为 <code>i16</code> 的<strong>节点</strong><sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup>；</li><li><strong>反向生成（unparse）<strong>并</strong>美化输出</strong>该语法树，得到更新后的 Rust 源代码文件。</li></ol><blockquote><p>注：<code>TypeNoBounds</code>、<code>libc::c_short</code>、<code>i16</code>、<code>c2rust</code>、<code>rustc</code> 等均保留为代码标识符形式，以避免歧义。</p></blockquote><h2 id="_3-评估-evaluation" tabindex="-1"><a class="header-anchor" href="#_3-评估-evaluation"><span>3. 评估（EVALUATION）</span></a></h2><blockquote><p><strong>RQ1. 使用我们的源到源（source-to-source）变换方法，安全函数比例可以提升到什么程度？</strong></p></blockquote><p>我们通过对<strong>开源</strong>与<strong>商业</strong>C 项目在转译<strong>前后</strong>的对比来评估 <strong>CRustS</strong> 的效果。</p><p>对数据集中每个项目，我们统计其<strong>代码规模</strong>（以代码行数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>O</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">LOC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span></span></span></span> 计）以及其<strong>安全/不安全函数比例</strong>。然后，我们将这些统计与使用 <strong>c2rust</strong> 与 <strong>CRustS</strong> 转换后的若干项目进行对比，以衡量<strong>安全函数比例的提升</strong>与<strong>处理效率</strong>。结果见<strong>表 1</strong>。</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><p>如结果所示，相比于原始（按定义其安全函数比例为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">0\\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">0%</span></span></span></span> 的）不安全 C 项目，转换后的<strong>安全函数比例</strong>获得了<strong>显著提升</strong>。需要注意的是，大多数项目的安全函数比例都<strong>超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>95</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">95\\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">95%</span></span></span></span></strong>。尽管 <strong>BusyBox</strong> 的安全函数比例<strong>明显低于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>95</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">95\\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">95%</span></span></span></span></strong>，但与之前已被转换的 <strong>RustyBox</strong> 项目相比，<strong>改进幅度仍然可观</strong>。进一步分析显示，该案例中相对较低的安全函数比例主要由其<strong>操作系统相关的数据结构</strong>所致——这在<strong>操作系统类项目</strong>中较为常见。针对该类型项目的解决方案将是我们<strong>后续研究</strong>的方向之一。</p><hr><blockquote><p><strong>RQ2. 这些提升安全性的 Rust 项目转换成果，在产品团队中是如何被接受的？</strong></p></blockquote><p>某大型通信公司的<strong>多个产品团队</strong>试用了 <strong>CRustS</strong>。其中一个来自 <strong>TLVcodec</strong> 产品的团队给出了<strong>正面反馈</strong>。最突出的评价包括：“<strong>它克服了学习一种新语言的陡峭曲线</strong>”，以及“<strong>它减少了将遗留 C 代码转到 Rust 的工作量</strong>”。</p><p>另一个产品团队在一个<strong>低层硬件控制</strong>产品上试用了 <strong>CRustS</strong>，希望将一个<strong>核心 C 模块的 2K 行代码</strong>快速转成<strong>Rust 初始版本</strong>，以便<strong>启动</strong>该模块从 C 到 Rust 的迁移。在这次尝试中，工具在生产环境中的<strong>初始部署与小幅适配</strong>耗时<strong>约两天</strong>，随后又在<strong>一天后</strong>产出了转换得到的 Rust 项目。与<strong>人工重写</strong>相比，该方案的<strong>交付周期显著更短</strong>；据项目经理评估，在该特定案例中，人工重写将<strong>超过两周</strong>。</p><p>该团队对我们的工具给予了高度评价，认为它“<strong>很快就产出了一个 Rust 初始实现</strong>，并为后续工作提供了<strong>坚实的踏板</strong>”。与此同时，他们也指出了工具的若干不足，主要集中在<strong>C 宏</strong>与<strong>枚举（enum）<strong>处理方面；这些问题</strong>已纳入</strong>我们的改进计划。</p><h2 id="citation" tabindex="-1"><a class="header-anchor" href="#citation"><span>Citation</span></a></h2><h3 id="ownership-guided-c-to-rust-translation" tabindex="-1"><a class="header-anchor" href="#ownership-guided-c-to-rust-translation"><span>Ownership Guided C to Rust Translation</span></a></h3><blockquote><p>Computer Aided Verification (CAV 2023)、CCF A</p></blockquote>',43)),e("p",null,[r(s,{to:"/posts/scholar/Ownership_Guided_C_to_Rust_Translation.html"},{default:n(()=>t[0]||(t[0]=[a("Click to jump")])),_:1})]),t[3]||(t[3]=o('<h3 id="don-t-write-but-return-replacing-output-parameters-with-algebraic-data-types-in-c-to-rust-translation" tabindex="-1"><a class="header-anchor" href="#don-t-write-but-return-replacing-output-parameters-with-algebraic-data-types-in-c-to-rust-translation"><span>Don’t Write, but Return: Replacing Output Parameters with Algebraic Data Types in C-to-Rust Translation</span></a></h3><blockquote><p>Proceedings of the ACM on Programming Languages (PACMPL) - PLDI 2024、CCF A</p></blockquote><p>论文提出把c风格的输出参数替换为Rust风格的函数返回值</p><h3 id="concrat-an-automatic-c-to-rust-lock-api-translator-for-concurrent-programs" tabindex="-1"><a class="header-anchor" href="#concrat-an-automatic-c-to-rust-lock-api-translator-for-concurrent-programs"><span>Concrat: An automatic C-to-Rust lock API translator for concurrent programs</span></a></h3><blockquote><p>ICSE 2023、CCF A</p></blockquote><p>把C风格的锁替换为Rust的锁API</p><h3 id="vert-verified-equivalent-rust-transpilation-with-large-language-models-as-few-shot-learners" tabindex="-1"><a class="header-anchor" href="#vert-verified-equivalent-rust-transpilation-with-large-language-models-as-few-shot-learners"><span>VERT: Verified Equivalent Rust Transpilation with Large Language Models as Few-Shot Learners</span></a></h3><blockquote><p><a href="https://arxiv.org/abs/2404.18852" target="_blank" rel="noopener noreferrer">arXiv预印本</a></p></blockquote><p>提出了 VERT：先把源语言经由 WebAssembly 编译成“正确性先验”的 Rust 参考程序，再用 LLM 生成可读的候选 Rust，并通过形式化验证与参考程序对比；若验证失败就迭代重生成，最终得到既可读、又具正确性保证的 Rust 翻译。</p><h3 id="evoc2rust-a-skeleton-guided-framework-for-project-level-c-to-rust-translation" tabindex="-1"><a class="header-anchor" href="#evoc2rust-a-skeleton-guided-framework-for-project-level-c-to-rust-translation"><span>EVOC2RUST: A Skeleton-guided Framework for Project-Level C-to-Rust Translation</span></a></h3><blockquote><p><a href="https://arxiv.org/abs/2508.04295" target="_blank" rel="noopener noreferrer">arXiv预印本</a></p></blockquote>',11)),e("p",null,[r(s,{to:"/posts/scholar/EVOC2RUST%EF%BC%9A%E7%94%A8%E4%BA%8E%E9%A1%B9%E7%9B%AE%E7%BA%A7C%E5%88%B0Rust%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%AA%A8%E6%9E%B6%E5%BC%95%E5%AF%BC%E6%A1%86%E6%9E%B6.html"},{default:n(()=>t[1]||(t[1]=[a("Click to jump")])),_:1})]),t[4]||(t[4]=o('<p>采用骨架引导式翻译策略实现项目级转换</p><h3 id="towards-a-transpiler-for-c-c-to-safer-rust" tabindex="-1"><a class="header-anchor" href="#towards-a-transpiler-for-c-c-to-safer-rust"><span>Towards a Transpiler for C/C++ to Safer Rust</span></a></h3><blockquote><p><a href="https://arxiv.org/abs/2401.08264" target="_blank" rel="noopener noreferrer">arXiv预印本</a></p></blockquote><p>C++ to Rust</p><h3 id="integrating-rules-and-semantics-for-llm-based-c-to-rust-translation" tabindex="-1"><a class="header-anchor" href="#integrating-rules-and-semantics-for-llm-based-c-to-rust-translation"><span>Integrating Rules and Semantics for LLM-Based C-to-Rust Translation</span></a></h3><blockquote><p><a href="https://arxiv.org/abs/2508.06926" target="_blank" rel="noopener noreferrer">arXiv预印本</a></p></blockquote><p>该论文针对遗留 C 代码自动翻译到 Rust 的难题，指出早期规则法覆盖有限、直接用 LLM 翻译又常违反 Rust 规则且语义不一致。为此提出 IRENE 框架，结合规则增强检索（由自研静态分析器生成规则选例）、结构化摘要引导语义理解与基于编译器诊断的迭代纠错，并在 xCodeEval 与华为 HW-Bench 上用八种 LLM 评估其翻译准确性与安全性。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>https://github.com/immunant/c2rust <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>这里的“<code>unsafe</code> 代码”是指那些被标注为 <code>unsafe</code>、且<strong>不会被 <code>rustc</code> 完整检查</strong>的代码；它们并不一定真正“不安全”。 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>Rust grammar definitions as specified in The Rust Reference at commit e1abb17. <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li><li id="footnote4" class="footnote-item"><p>Such C to Rust primitive type mapping is configurable in CRustS <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p></li></ol></section>',9))])}const C=i(d,[["render",f],["__file","C2RustSafe.html.vue"]]),b=JSON.parse(`{"path":"/posts/scholar/C2RustSafe.html","title":"In Rust We Trust – A Transpiler from Unsafe C to Safer Rust","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-10-12T00:00:00.000Z","category":["Rust"],"tag":["c2rust"],"description":"In Rust We Trust – A Transpiler from Unsafe C to Safer Rust 论文来自 2022 IEEE International Conference on Software Engineering (ICSE 22) 的《In Rust We Trust – A Transpiler from Unsa...","head":[["meta",{"property":"og:url","content":"https://iXanadu13.github.io/posts/scholar/C2RustSafe.html"}],["meta",{"property":"og:site_name","content":"Xanadu13's Blog"}],["meta",{"property":"og:title","content":"In Rust We Trust – A Transpiler from Unsafe C to Safer Rust"}],["meta",{"property":"og:description","content":"In Rust We Trust – A Transpiler from Unsafe C to Safer Rust 论文来自 2022 IEEE International Conference on Software Engineering (ICSE 22) 的《In Rust We Trust – A Transpiler from Unsa..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://iXanadu13.github.io/assets/images/scholar/C2RustSafe/figure1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-21T15:21:05.000Z"}],["meta",{"property":"article:tag","content":"c2rust"}],["meta",{"property":"article:published_time","content":"2025-10-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-21T15:21:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"In Rust We Trust – A Transpiler from Unsafe C to Safer Rust\\",\\"image\\":[\\"https://iXanadu13.github.io/assets/images/scholar/C2RustSafe/figure1.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/C2RustSafe/table1.png\\"],\\"datePublished\\":\\"2025-10-12T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-21T15:21:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Xanadu13\\",\\"url\\":\\"https://github.com/iXanadu13\\"}]}"]]},"headers":[{"level":2,"title":"摘要","slug":"摘要","link":"#摘要","children":[]},{"level":2,"title":"关键词","slug":"关键词","link":"#关键词","children":[]},{"level":2,"title":"1. 引言","slug":"_1-引言","link":"#_1-引言","children":[]},{"level":2,"title":"2. 我们的方法（OUR APPROACH）","slug":"_2-我们的方法-our-approach","link":"#_2-我们的方法-our-approach","children":[]},{"level":2,"title":"3. 评估（EVALUATION）","slug":"_3-评估-evaluation","link":"#_3-评估-evaluation","children":[]},{"level":2,"title":"Citation","slug":"citation","link":"#citation","children":[{"level":3,"title":"Ownership Guided C to Rust Translation","slug":"ownership-guided-c-to-rust-translation","link":"#ownership-guided-c-to-rust-translation","children":[]},{"level":3,"title":"Don’t Write, but Return: Replacing Output Parameters with Algebraic Data Types in C-to-Rust Translation","slug":"don-t-write-but-return-replacing-output-parameters-with-algebraic-data-types-in-c-to-rust-translation","link":"#don-t-write-but-return-replacing-output-parameters-with-algebraic-data-types-in-c-to-rust-translation","children":[]},{"level":3,"title":"Concrat: An automatic C-to-Rust lock API translator for concurrent programs","slug":"concrat-an-automatic-c-to-rust-lock-api-translator-for-concurrent-programs","link":"#concrat-an-automatic-c-to-rust-lock-api-translator-for-concurrent-programs","children":[]},{"level":3,"title":"VERT: Verified Equivalent Rust Transpilation with Large Language Models as Few-Shot Learners","slug":"vert-verified-equivalent-rust-transpilation-with-large-language-models-as-few-shot-learners","link":"#vert-verified-equivalent-rust-transpilation-with-large-language-models-as-few-shot-learners","children":[]},{"level":3,"title":"EVOC2RUST: A Skeleton-guided Framework for Project-Level C-to-Rust Translation","slug":"evoc2rust-a-skeleton-guided-framework-for-project-level-c-to-rust-translation","link":"#evoc2rust-a-skeleton-guided-framework-for-project-level-c-to-rust-translation","children":[]},{"level":3,"title":"Towards a Transpiler for C/C++ to Safer Rust","slug":"towards-a-transpiler-for-c-c-to-safer-rust","link":"#towards-a-transpiler-for-c-c-to-safer-rust","children":[]},{"level":3,"title":"Integrating Rules and Semantics for LLM-Based C-to-Rust Translation","slug":"integrating-rules-and-semantics-for-llm-based-c-to-rust-translation","link":"#integrating-rules-and-semantics-for-llm-based-c-to-rust-translation","children":[]}]}],"git":{"createdTime":1760240310000,"updatedTime":1761060065000,"contributors":[{"name":"Xanadu13","email":"xanadu13@qq.com","commits":5}]},"readingTime":{"minutes":9.15,"words":2745},"filePathRelative":"posts/scholar/C2RustSafe.md","localizedDate":"2025年10月12日","excerpt":"\\n<p>论文来自 2022 IEEE International Conference on Software Engineering (ICSE 22) 的《<a href=\\"https://dl.acm.org/doi/abs/10.1145/3510454.3528640\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">In Rust We Trust – A Transpiler from Unsafe C to Safer Rust</a>》。</p>\\n<h2>摘要</h2>\\n<p>Rust 是一种<strong>类型安全</strong>的系统编程语言，其编译器会检查内存与并发安全。为便于从既有 C 项目平滑迁移，可使用<strong>源到源（source-to-source）转译器</strong>通过程序变换将 C 程序自动转换为 Rust。然⽽，现有的 C→Rust 变换工具（例如开源的 C2Rust 转译器<sup class=\\"footnote-ref\\"><a href=\\"#footnote1\\">[1]</a><a class=\\"footnote-anchor\\" id=\\"footnote-ref1\\"></a></sup><a class=\\"footnote-anchor\\" id=\\"footnote-ref1\\">）存在一个缺点：<strong>保留了 C 的不安全语义，仅将其改写为 Rust 的语法</strong>。Emre 等人 [2] 指出了这些问题，并利用 <code>rustc</code> 编译器的反馈，将某一类原始指针（raw pointers）重构为 Rust 引用，以提升 C2Rust 输出的整体安全性与“惯用性”（idiomaticness）。</a></p>","autoDesc":true}`);export{C as comp,b as data};
