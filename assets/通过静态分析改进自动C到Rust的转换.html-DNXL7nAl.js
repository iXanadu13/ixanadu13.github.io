import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as n,o as t}from"./app-DsxQQx1N.js";const l="/assets/images/scholar/%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%94%B9%E8%BF%9B%E8%87%AA%E5%8A%A8C%E5%88%B0Rust%E7%9A%84%E8%BD%AC%E6%8D%A2/figure1.png",h="/assets/images/scholar/%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%94%B9%E8%BF%9B%E8%87%AA%E5%8A%A8C%E5%88%B0Rust%E7%9A%84%E8%BD%AC%E6%8D%A2/figure2.png",e="/assets/images/scholar/%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%94%B9%E8%BF%9B%E8%87%AA%E5%8A%A8C%E5%88%B0Rust%E7%9A%84%E8%BD%AC%E6%8D%A2/figure3.png",p="/assets/images/scholar/%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%94%B9%E8%BF%9B%E8%87%AA%E5%8A%A8C%E5%88%B0Rust%E7%9A%84%E8%BD%AC%E6%8D%A2/figure4.png",r={};function k(o,s){return t(),i("div",null,s[0]||(s[0]=[n(`<h1 id="improving-automatic-c-to-rust-translation-with-static-analysis" tabindex="-1"><a class="header-anchor" href="#improving-automatic-c-to-rust-translation-with-static-analysis"><span>Improving Automatic C-to-Rust Translation with Static Analysis</span></a></h1><p>论文来自 2023 IEEE International Conference on Software Engineering (ICSE 23) 的《<a href="https://ieeexplore.ieee.org/abstract/document/10172848/" target="_blank" rel="noopener noreferrer">Improving Automatic C-to-Rust Translation with Static Analysis</a>》。</p><h2 id="摘要" tabindex="-1"><a class="header-anchor" href="#摘要"><span>摘要</span></a></h2><p>尽管 C 语言在系统编程领域广受欢迎，但也因其贫乏的语言级安全机制而“臭名昭著”，由此导致了严重的缺陷与漏洞。即便通过了类型检查，C 程序仍可能存在内存与线程方面的错误。为了解决这一由来已久的问题，近年来出现了 Rust，它配备了丰富的安全机制，尤以其“所有权”类型系统著称。Rust 通过类型检查来防止内存与线程错误。将遗留的 C 程序用 Rust 重写，开发者便能发现此前未知的缺陷，并避免引入新的错误。</p><p>然而，Rust 在遗留程序中的落地仍受限于手工 C→Rust 翻译的高成本。Rust 的安全特性在语义上与 C 的不安全特性存在差异，这要求程序员精确理解其程序行为，方能正确重写。现有的 C→Rust 翻译器并未缓解这一负担，因为它们通常只是将 C 的特性做语法层面的映射，转成 Rust 中仍然“不安全”的写法，从而把进一步的重构工作留给了程序员。</p><p>本文提出改进当前 C→Rust 翻译水平的问题设定：通过<strong>自动</strong>将不安全特性替换为安全特性，提高翻译结果的安全性与可用性。具体而言，我们识别出两类需要替换的重要不安全特性：<strong>锁 API</strong> 与 <strong>输出参数</strong>。我们给出了关于锁 API 的实验结果，并讨论了对输出参数的后续计划。</p><h2 id="_1-引言" tabindex="-1"><a class="header-anchor" href="#_1-引言"><span>1. 引言</span></a></h2><p>C 是一种被广泛使用的系统编程语言，但其贫乏的语言级安全机制导致了软件系统中严重的缺陷与漏洞。过去十年里，开源社区已披露的漏洞中大约有一半出现在 C 程序中 [29]。尽管 C 是静态类型语言，其薄弱的类型系统并不能消除大多数内存与线程错误。即便某个程序通过了类型检查，也无法保证其在内存与并发方面是安全的。这迫使 C 程序员必须手动防止此类错误，既耗时又容易出错。</p><p>Rust [3]，[28] 是一种较新的系统编程语言，旨在弥补 C 的局限。其“所有权”类型系统同时确保内存与线程安全 [23]。Rust 还提供了 C 所不具备的高层抽象，例如闭包 [24，§13.1]、泛型 [24，§10.1] 和 trait [24，§10.2]。这些特性使代码更加简洁，并减少对不安全类型转换的需求，从而降低缺陷产生的可能性。</p><p>Rust 的设计在优先保证安全性的同时仍能提供良好性能，为系统编程社区改进遗留系统软件的安全性提供了契机。将 C 程序用 Rust 重写，在 Rust 类型检查器的帮助下，人们可以发现此前未知的缺陷。以 cURL 为例，若其开发者当初用 Rust 重写，其中已知的安全漏洞有一半以上本可以被轻松发现 [22]。此外，一旦把软件迁移到 Rust，在引入新特性的同时产生新缺陷的风险也会显著降低。</p><p>鉴于 Rust 在提升软件安全性方面的益处，程序员正在用 Rust 重新实现关键的系统软件。例如，Mozilla 用 Rust 开发了 Servo 浏览器，并以 Servo 的部分模块替换了 Firefox 的相应模块。Rust 的安全机制使复杂 HTML 渲染器的正确实现成为可能 [17]。操作系统作为系统程序中最复杂的一类，也在采用 Rust。最新发布的 Linux 内核已经支持编写 Rust 代码 [10]。Android 与 Fuchsia 也在其实现中使用了 Rust [2]，[35]。</p><p>然而，手工进行 C→Rust 翻译的高成本阻碍了 Rust 在系统程序中的更广泛落地。由于 C 与 Rust 之间存在差异，这一翻译过程不仅劳力密集，而且难以保证正确性。Rust 为安全性提供了新特性，这些特性在句法与语义上都与 C 的对应概念不同。举例来说，Rust 提供了 <em>引用</em>（reference）这一保证受控访问的“指针”形式，但其使用约束远比 C 中的普通指针严格。这些差异要求程序员精确理解自己程序的行为以及 Rust 的相关特性。</p><p>这就产生了对<strong>自动化</strong> C→Rust 翻译的需求，但目前在该方向上的工作仍然有限。最广泛使用的自动 C→Rust 翻译器 C2Rust [40] 基本只做句法层面的翻译。它利用了 Rust 在提供安全保障特性的同时也保留了与 C 对应的<strong>不安全</strong>特性这一事实。比如，Rust 也有原始指针（raw pointer），其访问可能并不安全，与 C 的指针类似。C2Rust 生成的程序继续使用这些不安全特性，因此无法依靠类型检查来确保安全。通常期望程序员在 C2Rust 翻译之后，再手工把这些不安全特性替换为安全特性。Emre 等人 [12] 提出过一种方法，将 C2Rust 生成程序中的原始指针替换为引用，但其他不安全特性依然存在。</p><p>本文旨在改进当前最先进的自动 C→Rust 翻译：用安全特性替换 C2Rust 生成程序中的不安全特性。由于安全特性在语义上与不安全特性不同，我们需要静态分析来推断目标程序中不安全特性的行为并进行替换。每类不安全特性都有其独特性，因而需要专门设计相应的静态分析。本工作识别出两类需要优先替换的重要不安全特性：<strong>锁 API</strong> 与 <strong>输出参数</strong>（§III）。我们展示了将 C 的锁 API 替换为 Rust 锁 API 的结果（§IV），并讨论对输出参数以及其他重要不安全特性的计划（§V）。</p><h2 id="_2-背景与相关工作" tabindex="-1"><a class="header-anchor" href="#_2-背景与相关工作"><span>2. 背景与相关工作</span></a></h2><p>C2Rust [40] 是目前最广泛使用的 C→Rust 翻译器。其翻译属于“句法层面”的：针对 C 代码中使用到的每一种特性，找到 Rust 中一个<strong>可能不安全</strong>但在语法上可对齐的等价特性，以此化解 C 与 Rust 之间的句法差异。</p><p>C2Rust 在翻译过程中会保留所有 C 的类型以及对 C 标准库函数的调用。下面给出一段 C 代码及其由 C2Rust 生成的 Rust 版本：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// C</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) { </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (x </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Hello, world!&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// C2Rust 生成的 Rust</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">libc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">c_int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> as</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> libc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">c_int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">b&quot;Hello, world!</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\0</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> as</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> u8</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> as</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> libc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">c_char</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然函数定义与条件语句被做了句法层面的翻译，但类型 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">int</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span></span></span></span> 与函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">printf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 仍被保留下来。Rust 程序员更倾向于如下写法：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) { </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Hello, world!&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里使用了 Rust 的原生整数类型 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mn>32</mn></mrow><annotation encoding="application/x-tex">i32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mord">32</span></span></span></span>（其位宽可能随硬件而变）以及由标准库提供的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">print!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mclose">!</span></span></span></span> 宏。</p><p>C2Rust 也会把 C 的指针保留下来——在 Rust 中翻译为<strong>原始指针</strong>（raw pointer）。原始指针与 C 指针等价，无法保证安全访问。以下是使用指针的 C 代码及其由 C2Rust 生成的 Rust 版本：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// C</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) { </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">p </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// C2Rust 生成的 Rust（原始指针 *mut）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: *</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> libc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">c_int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { *</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> as</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> libc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">c_int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo><mi>m</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">*mut</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord">∗</span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span></span></span></span> 表示原始指针。为确保内存安全，Rust 提供了原始指针的安全替代物：<strong>引用</strong>（reference）。引用约束更严格，但在被借用规则允许的前提下始终可安全访问。程序员更偏好使用引用，如下：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) { *</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中 <code>&amp;mut</code> 表示可变引用。</p><p>CRustS [26] 通过“句法重写”增强 C2Rust 的输出。它基于 TXL 变换语言 [9] 编写的 220 条句法替换规则进行处理，例如可把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>i</mi><mi>b</mi><mi>c</mi><mo>:</mo><mo>:</mo><mi>c</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">libc::c\\_int</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">ib</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9695em;vertical-align:-0.31em;"></span><span class="mord mathnormal">c</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span></span></span></span> 替换为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mn>32</mn></mrow><annotation encoding="application/x-tex">i32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mord">32</span></span></span></span>。</p><p>Emre 等人 [12] 提出，用<strong>引用</strong>替换 C2Rust 生成代码中的<strong>原始指针</strong>。但“盲目地把所有原始指针都替换为引用”并不可行，原因有二：其一，受引用语义的约束，并非所有原始指针都能替换；其二，当编译器无法自行推断时，引用需要显式的<strong>生命周期</strong>（即有效范围）注解。为解决这些问题，他们采用“<strong>借助编译器反馈的迭代改写</strong>”：先将所有原始指针替换为引用，然后根据编译器的报错信息继续修改代码（把部分引用改回原始指针，或补充生命周期注解），如此往复，直到代码能够成功通过编译为止。</p><p>近来，也出现了可进行代码翻译的语言模型 [5]，[6]，[13]，[19]，[25]，[31]，[32]，[36]，[38]，[39]。虽然它们可以把 C 代码翻译成 Rust，但其翻译<strong>无法保证语义保持</strong>。</p><p>除 C→Rust 之外，学界还提出了许多更“安全”的 C 替代语言及（半）自动翻译到这些语言的方法 [7]，[8]，[11]，[14]–[16]，[18]，[27]，[30]，[33]。然而，与 Rust 不同，它们通常只保证<strong>有限形式</strong>的内存安全。例如，Cyclone [18] 防止悬垂指针解引用；Checked C [11] 保证不存在空指针解引用与越界访问。</p><h2 id="_3-提出的问题-proposed-problem" tabindex="-1"><a class="header-anchor" href="#_3-提出的问题-proposed-problem"><span>3. 提出的问题（Proposed Problem）</span></a></h2><p>我们旨在改进当前最先进的自动 C→Rust 翻译：把 C2Rust 生成程序中的<strong>不安全特性</strong>替换为<strong>安全特性</strong>。本文重点讨论两类重要的不安全特性：<strong>锁 API</strong> 与 <strong>输出参数</strong>。</p><h3 id="a-锁-api-lock-api" tabindex="-1"><a class="header-anchor" href="#a-锁-api-lock-api"><span>A. 锁 API（Lock API）</span></a></h3><p>锁被广泛用于防止<strong>数据竞争</strong>（data race）：当多个线程同时对同一内存地址进行读写时，就可能发生数据竞争。为避免数据竞争，每个线程在访问共享数据之前和之后，分别<strong>获取</strong>与<strong>释放</strong>一个锁。不幸的是，如果线程获取了<strong>错误的锁</strong>、<strong>获取得太晚</strong>，或<strong>过早释放</strong>，即便使用了锁，数据竞争仍可能发生。</p><p>C 语言中最常用的锁 API 是 <strong>pthreads</strong> [4]，它提供了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">_</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">pthread\\_mutex\\_lock</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">pt</span><span class="mord mathnormal">h</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">_</mi><mi>u</mi><mi>n</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">pthread\\_mutex\\_unlock</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">pt</span><span class="mord mathnormal">h</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 两个函数，分别用于获取与释放作为参数传入的互斥量。线程需要在访问共享数据的前后调用这两个函数，如下例所示：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...; </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">pthread_mutex_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> m </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> inc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    pthread_mutex_lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">m);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    pthread_mutex_unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">m);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是共享整数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 是保护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的锁。每次访问 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 时，线程都应当持有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>。</p><p>当使用 pthreads 时，<strong>正确使用锁的责任在程序员</strong>，因为该 API 并不会校验程序中锁使用的正确性。程序员在使用锁时容易犯两类错误：</p><ul><li><strong>数据—锁不匹配</strong>（data-lock mismatch）：访问某块数据时获取了<strong>错误的锁</strong>；</li><li><strong>流程—锁不匹配</strong>（flow-lock mismatch）：在<strong>错误的程序时机</strong>获取（或释放）了锁。</li></ul><p>下面是一个<strong>数据—锁不匹配</strong>的例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pthread_mutex_lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">m2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">n1 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pthread_mutex_unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">m2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而程序的其他部分在访问 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">n1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">n</span><span class="mord">1</span></span></span></span> 时获取的是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">m1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">m</span><span class="mord">1</span></span></span></span>。上面这段代码错误地获取了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">m2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">m</span><span class="mord">2</span></span></span></span>（本应获取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">m1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">m</span><span class="mord">1</span></span></span></span>）。</p><p>下面是一个<strong>流程—锁不匹配</strong>的例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() { n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pthread_mutex_lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">m); ... }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() { ... </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pthread_mutex_unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">m); n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>此处程序使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 来保护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">f1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">1</span></span></span></span> 在<strong>获取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 之前</strong>就访问了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">f2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">2</span></span></span></span> 在<strong>释放 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 之后</strong>又访问了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，二者都不正确。</p><p>与此形成对比的是，<strong>Rust 的锁 API 能确保每一次加锁的使用都是正确的</strong> [23]。为防止数据—锁与流程—锁的不匹配，Rust 的锁 API 将</p><ul><li><strong>数据—锁关系</strong>（哪把锁保护哪块数据），以及</li><li><strong>流程—锁关系</strong>（在程序的哪个点位持有哪些锁）</li></ul><p>都<strong>显式化</strong>到程序中。</p><p>首先，它把锁与共享数据<strong>绑定</strong>，从而显式暴露数据—锁关系。可以把“Rust 的每个锁”理解为“C 中的一把锁 + 与之绑定的共享数据”。下面这段代码创建了一个初始值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的锁，并命名为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">sync</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Mutex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> m</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Mutex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> Mutex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">new</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要访问共享数据，线程必须获取与该数据<strong>绑定</strong>的锁，从而消除了“数据—锁不匹配”的可能性。其次，Rust 引入了 <strong>guard</strong>（保护者）的概念来显式表达流程—锁关系。对锁调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">lock</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 方法会返回一个 <strong>guard</strong>，它是指向受保护数据的<strong>特殊指针</strong>。线程只能通过对 guard 解引用来访问数据；当 guard 被 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>r</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">drop</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">p</span></span></span></span>（释放）时，与之关联的锁会<strong>自动释放</strong>。下面展示了 guard 的创建、使用与释放：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> g</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> m</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unwrap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">g</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">drop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">g</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 Rust 的<strong>所有权类型系统</strong>，一个函数只能在变量<strong>初始化之后</strong>且<strong>移交到其他函数之前</strong>使用该变量。因此，线程只有在<strong>持有锁</strong>时才能使用相应的 guard，从而<strong>不会</strong>发生流程—锁不匹配。</p><p>C2Rust 生成代码中保留的 <strong>C 锁 API</strong> 是我们要替换的一项重要不安全特性。由于 C2Rust 保留了所有 C 的类型与库调用，C 的锁 API 也就被保留在生成程序里，这使程序无法受益于 Rust 锁 API 所保证的线程安全。<strong>核心挑战</strong>在于：如何通过静态分析<strong>高效且精确地</strong>计算出程序中的<strong>数据—锁关系</strong>与<strong>流程—锁关系</strong>。没有这两类信息就无法进行替换，因为 Rust 的锁 API 要求这些关系在代码里是<strong>显式</strong>的。</p><h3 id="b-输出参数-output-parameters" tabindex="-1"><a class="header-anchor" href="#b-输出参数-output-parameters"><span>B. 输出参数（Output Parameters）</span></a></h3><p><strong>输出参数</strong>指的是用于“输出”而非“输入”的参数。不同于某些把输出参数作为原生语言特性的语言，C 通过<strong>指针</strong>来模拟输出参数。要使用输出参数，函数接收一个指针，并只<strong>写入</strong>该地址（不读取）。在 C 中使用输出参数主要有两个原因。</p><p><strong>其一：返回多个值。</strong><br> 在支持元组的语言里，函数可以返回一个<strong>元组</strong>来携带多个返回值。由于 C 没有元组，函数只能把其中一个值作为<strong>返回值</strong>，其余值通过<strong>输出参数</strong>返回。下面的函数示例就通过一个输出参数，同时返回了整数除法的<strong>商</strong>与<strong>余数</strong>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> d</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">r</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> q </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> d;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">r </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> q </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> d;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> q;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>其二：实现“半谓词”（semipredicate）。</strong><br> “半谓词”是可能<strong>失败</strong>的函数；例如，当除数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时，除法函数会失败。在很多语言中，实现半谓词的常用方案是<strong>异常</strong>：当函数失败时抛出异常，调用者用异常处理器来识别失败。然而 C 没有异常机制，因此程序员常用<strong>输出参数</strong>来实现半谓词。典型做法是：把半谓词实现为<strong>带输出参数</strong>的函数；成功时，函数把结果写入输出参数，并返回一个<strong>表示成功</strong>的值；失败时，函数返回一个<strong>表示失败</strong>的值，且<strong>不写入</strong>输出参数。如下例所示：只有当除数非零时，该函数才返回商：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> d</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">q</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (d </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">q </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> d;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然输出参数在 C 中很实用，但如果可能，<strong>应当尽量避免</strong> [1]。原因如下：</p><ul><li><strong>可读性</strong>受损。参数本意是<strong>输入</strong>而非输出；通过输出参数返回值，比“直接返回结果”的函数更难理解。</li><li><strong>安全性</strong>受损。带输出参数的函数调用端通常会先声明一个<strong>未初始化变量</strong>，再把该变量的指针传入函数。若该函数是半谓词，则在<strong>失败路径</strong>上，该变量可能保持未初始化状态；如果随后不加小心地读取它，就会导致<strong>未定义行为</strong>。</li></ul><p>Rust 提供了<strong>安全</strong>的替代机制来消除输出参数：<strong>元组</strong>（tuple）与 <strong>Option</strong>。<br> 当函数需要返回多个值时，可以直接返回一个<strong>元组</strong>，例如：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">d</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> q</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> / </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">d</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> r</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> - </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">q</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">d</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">q</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">r</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当函数是半谓词时，可以返回一个 <strong>Option</strong>：它要么是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>o</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Some</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span></span></span></span>（表示成功，并携带一个内部值），要么是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>n</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">None</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span></span></span></span>（表示失败，不携带值）。下面给出用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Option</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Opt</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span> 实现半谓词的示例：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">d</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Option</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> d</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> None</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> q</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> / </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">d</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Some</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">q</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 C2Rust 生成的代码中，<strong>用元组与 Option 替换输出参数</strong>非常重要。由于 C2Rust <strong>不会增减函数形参</strong>，输出参数会在翻译后<strong>保留下来</strong>，从而损害生成的 Rust 代码的<strong>可读性</strong>与<strong>安全性</strong>。</p><p>然而，想要自动移除输出参数并不容易，难点包括：</p><ol><li><strong>识别输出参数本身</strong>并非易事；</li><li>对于半谓词，还需要<strong>识别返回值的语义</strong>（哪些返回值代表“成功”，哪些代表“失败”）。没有这些信息，就不可能把调用端的<strong>错误处理逻辑</strong>正确转换为 Rust 风格的返回类型。<br> 因此，我们需要<strong>高效的静态分析</strong>来定位输出参数，并推断半谓词返回值的实际含义。</li></ol><h2 id="_4-已取得的成果-achieved-results" tabindex="-1"><a class="header-anchor" href="#_4-已取得的成果-achieved-results"><span>4. 已取得的成果（Achieved Results）</span></a></h2><p>为将 C2Rust 生成代码中的 <strong>C 锁 API</strong> 替换为 <strong>Rust 锁 API</strong>，我们提出了 <strong>Concrat</strong>，它由 <strong>C2Rust</strong>、一个<strong>静态分析器</strong>以及一个 <strong>Rust 代码变换器</strong> 组成 [20]。<strong>图 1</strong> 展示了 Concrat 的工作流：静态分析器在 C2Rust 生成的代码上执行我们提出的数据流分析，产出一份<strong>锁摘要</strong>（lock summary），其中描述了<strong>数据—锁关系</strong>与<strong>流程—锁关系</strong>；随后，代码变换器依据该锁摘要，将程序中的锁 API 进行替换。</p><figure><img src="`+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为将我们的分析器与面向并发 C 程序的最新静态分析器 <strong>Goblint</strong> [34]，[37] 对比，我们额外构建了 <strong>Concrat_G</strong>，其框架与 Concrat 相同，但将我们的分析器替换为 Goblint。<strong>图 2</strong> 给出了 Concrat_G 的工作流。由于 Goblint 分析的是 <strong>C 源码</strong>，我们的摘要生成器会借助 C2Rust 产生的“C→Rust 行映射”，把 Goblint 的分析结果转换成<strong>锁摘要</strong>。</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们使用来自 GitHub 的 <strong>46 个真实并发 C 程序</strong>对 Concrat 进行了评估。实验环境为一台 Ubuntu 主机（Intel Core i7-6700K，4 核 8 线程，4GHz，32GB 内存）。我们的实现与评测数据已公开 [21]。</p><figure><img src="'+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们的评估结果表明，<strong>代码变换器</strong>具有良好的<strong>可扩展性</strong>、<strong>适用性广</strong>且<strong>正确</strong>。如<strong>图 3</strong> 所示，变换时间与代码规模近似成正比：在 <strong>66 KLOC</strong> 上仅需 <strong>2.5 s</strong>。我们把“若程序在变换后能成功编译”视为“变换器对该程序<strong>适用</strong>”。在 46 个程序中，<strong>29 个</strong>能直接编译通过，<strong>5 个</strong>在手工修改数行后可编译通过，<strong>12 个</strong>无法通过编译。12 个失败原因归纳为三类：<strong>按条件加锁的函数</strong>、<strong>函数指针</strong>以及<strong>指向锁的指针</strong>。我们把“若程序在变换后，其所有测试用例均通过”视为“变换器<strong>正确</strong>”。在 34 个可编译的程序中，<strong>20 个</strong>带有测试；在这 20 个中，1 个在 C2Rust 翻译前就失败，1 个在 C2Rust 翻译后失败，<strong>17 个</strong>在我们的变换后通过，另有 <strong>1 个</strong>在我们的变换后失败。尽管我们没有给出形式化的正确性证明，但我们的设计将一次 <strong>lock</strong> 函数调用变换为一次 <strong>lock 方法调用</strong>，并将一次 <strong>unlock</strong> 调用变换为“<strong>drop 一个 guard</strong>（其析构函数会释放相关联的锁）”，从直观上支撑了变换的正确性。</p><p>评估结果还表明，我们的<strong>分析器</strong>相比 Goblint <strong>更具可扩展性且更精确</strong>。在 <strong>66 KLOC</strong> 上，我们的分析器仅需 <strong>4.3 s</strong>；而 Goblint 因内部错误或 <strong>24 小时</strong>的超时限制，<strong>未能分析 27 个程序</strong>，对其余 <strong>19 个程序</strong>的分析耗时比我们<strong>慢 1.1× 至 3923×</strong>（见<strong>图 4</strong>）。我们认定：若分析器给出的锁摘要能使变换器生成<strong>可编译</strong>的代码，则该分析器是<strong>精确</strong>的；因为<strong>不精确</strong>的锁摘要会导致变换后的代码<strong>无法编译</strong>。在 Goblint 能分析的 19 个程序中，使用我们的分析器时有 <strong>2 个</strong>变换后无法编译；而使用 Goblint 时有 <strong>6 个</strong>变换后无法编译。</p><h2 id="_5-未来计划-future-plans" tabindex="-1"><a class="header-anchor" href="#_5-未来计划-future-plans"><span>5. 未来计划（Future Plans）</span></a></h2><p>我们将提出一种方法，用 <strong>元组（tuples）</strong> 与 <strong>选项类型（options）</strong> 来替换输出参数。该方法需要静态分析：既要<strong>检测</strong>哪里使用了输出参数，也要<strong>推断</strong>半谓词（semipredicate）函数返回值所表达的语义。此外，我们还需基于静态分析结果设计一个 <strong>Rust 代码变换器</strong>。目前，我们正在<strong>收集实际使用输出参数的 C 代码</strong>，以归纳现实代码中的常见用法模式；分析器与变换器将以这些模式为依据进行开发。我们相信，可以像在“锁 API”工作中那样对本方法进行评估：对<strong>变换器</strong>评估其<strong>可扩展性</strong>、<strong>适用性</strong>与<strong>正确性</strong>，对<strong>分析器</strong>评估其<strong>可扩展性</strong>与<strong>精度</strong>。我们预计在 <strong>2023 年底</strong>完成这部分工作。</p><p>在解决输出参数问题之后，我们将识别 C2Rust 生成代码中<strong>另一类重要的不安全特性</strong>，并将其替换为合适的安全特性。尽管尚未最终确定具体目标，候选方向包括：用 <code>Box</code> 替换 <code>malloc</code>，把接受 <code>void *</code> 指针的函数改造为<strong>泛型函数</strong>，以及将<strong>循环</strong>改造为使用<strong>迭代器</strong>与<strong>高阶函数</strong>的形式。虽然目前尚无法给出具体的评估计划，但我们预期可以采用与之前相似的评估流程。我们预计在 <strong>2024 年底</strong>完成该项工作。</p>',84)]))}const d=a(r,[["render",k],["__file","通过静态分析改进自动C到Rust的转换.html.vue"]]),c=JSON.parse(`{"path":"/posts/scholar/%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%94%B9%E8%BF%9B%E8%87%AA%E5%8A%A8C%E5%88%B0Rust%E7%9A%84%E8%BD%AC%E6%8D%A2.html","title":"Improving Automatic C-to-Rust Translation with Static Analysis","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-10-31T00:00:00.000Z","category":["Rust"],"tag":["c2rust"],"description":"Improving Automatic C-to-Rust Translation with Static Analysis 论文来自 2023 IEEE International Conference on Software Engineering (ICSE 23) 的《Improving Automatic C-to-Rust Translat...","head":[["meta",{"property":"og:url","content":"https://iXanadu13.github.io/posts/scholar/%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%94%B9%E8%BF%9B%E8%87%AA%E5%8A%A8C%E5%88%B0Rust%E7%9A%84%E8%BD%AC%E6%8D%A2.html"}],["meta",{"property":"og:site_name","content":"Xanadu13's Blog"}],["meta",{"property":"og:title","content":"Improving Automatic C-to-Rust Translation with Static Analysis"}],["meta",{"property":"og:description","content":"Improving Automatic C-to-Rust Translation with Static Analysis 论文来自 2023 IEEE International Conference on Software Engineering (ICSE 23) 的《Improving Automatic C-to-Rust Translat..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://iXanadu13.github.io/assets/images/scholar/通过静态分析改进自动C到Rust的转换/figure1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-31T02:40:03.000Z"}],["meta",{"property":"article:tag","content":"c2rust"}],["meta",{"property":"article:published_time","content":"2025-10-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-31T02:40:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Improving Automatic C-to-Rust Translation with Static Analysis\\",\\"image\\":[\\"https://iXanadu13.github.io/assets/images/scholar/通过静态分析改进自动C到Rust的转换/figure1.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/通过静态分析改进自动C到Rust的转换/figure2.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/通过静态分析改进自动C到Rust的转换/figure3.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/通过静态分析改进自动C到Rust的转换/figure4.png\\"],\\"datePublished\\":\\"2025-10-31T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-31T02:40:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Xanadu13\\",\\"url\\":\\"https://github.com/iXanadu13\\"}]}"]]},"headers":[{"level":2,"title":"摘要","slug":"摘要","link":"#摘要","children":[]},{"level":2,"title":"1. 引言","slug":"_1-引言","link":"#_1-引言","children":[]},{"level":2,"title":"2. 背景与相关工作","slug":"_2-背景与相关工作","link":"#_2-背景与相关工作","children":[]},{"level":2,"title":"3. 提出的问题（Proposed Problem）","slug":"_3-提出的问题-proposed-problem","link":"#_3-提出的问题-proposed-problem","children":[{"level":3,"title":"A. 锁 API（Lock API）","slug":"a-锁-api-lock-api","link":"#a-锁-api-lock-api","children":[]},{"level":3,"title":"B. 输出参数（Output Parameters）","slug":"b-输出参数-output-parameters","link":"#b-输出参数-output-parameters","children":[]}]},{"level":2,"title":"4. 已取得的成果（Achieved Results）","slug":"_4-已取得的成果-achieved-results","link":"#_4-已取得的成果-achieved-results","children":[]},{"level":2,"title":"5. 未来计划（Future Plans）","slug":"_5-未来计划-future-plans","link":"#_5-未来计划-future-plans","children":[]}],"git":{"createdTime":1761878403000,"updatedTime":1761878403000,"contributors":[{"name":"Xanadu13","email":"xanadu13@qq.com","commits":1}]},"readingTime":{"minutes":19.09,"words":5727},"filePathRelative":"posts/scholar/通过静态分析改进自动C到Rust的转换.md","localizedDate":"2025年10月31日","excerpt":"\\n<p>论文来自 2023 IEEE International Conference on Software Engineering (ICSE 23) 的《<a href=\\"https://ieeexplore.ieee.org/abstract/document/10172848/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Improving Automatic C-to-Rust Translation with Static Analysis</a>》。</p>\\n<h2>摘要</h2>\\n<p>尽管 C 语言在系统编程领域广受欢迎，但也因其贫乏的语言级安全机制而“臭名昭著”，由此导致了严重的缺陷与漏洞。即便通过了类型检查，C 程序仍可能存在内存与线程方面的错误。为了解决这一由来已久的问题，近年来出现了 Rust，它配备了丰富的安全机制，尤以其“所有权”类型系统著称。Rust 通过类型检查来防止内存与线程错误。将遗留的 C 程序用 Rust 重写，开发者便能发现此前未知的缺陷，并避免引入新的错误。</p>","autoDesc":true}`);export{d as comp,c as data};
