import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as s,o as i}from"./app-BlTD4QhU.js";const t="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/figure1.png",o="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/table1.png",r="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/table2.png",d="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/figure2.png",p="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/figure3.png",A="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/algo1.png",E="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/figure4.png",l="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/table3.png",c="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/table4.png",m="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/figure5.png",B="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/figure6.png",h="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/figure7.png",R="/assets/images/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B/figure8.png",g={};function S(u,a){return i(),e("div",null,a[0]||(a[0]=[s('<h1 id="ransomsentry-runtime-detection-of-android-ransomware-with-compiler-based-instrumentation" tabindex="-1"><a class="header-anchor" href="#ransomsentry-runtime-detection-of-android-ransomware-with-compiler-based-instrumentation"><span>RansomSentry: Runtime Detection of Android Ransomware With Compiler-Based Instrumentation</span></a></h1><p>论文来自 IEEE Transactions on Dependable and Secure Computing 2025的《<a href="https://ieeexplore.ieee.org/document/10840300" target="_blank" rel="noopener noreferrer">RansomSentry: Runtime Detection of Android Ransomware With Compiler-Based Instrumentation</a>》。</p><h2 id="摘要" tabindex="-1"><a class="header-anchor" href="#摘要"><span>摘要</span></a></h2><p>近年来，移动勒索软件攻击越来越普遍，尤其是在Android系统中。Android勒索软件通过恶意锁定受感染的设备或加密设备上的用户文件来勒索用户。为了解决这个问题，我们提出了RANSOMSENTRY，这是一个运行时检测系统，具有基于编译器的检测工具，可以在Android中同时检测锁屏和加密勒索软件。</p><p>具体来说，RANSOMSENTRY利用修改后的Android dex2oat编译器来检测勒索软件在安装目标应用程序期间调用的敏感API，并在运行时监控应用程序的屏幕相关和文件访问操作以检测攻击。与之前的解决方案相比，RANSOMSENTRY不需要更改应用程序的APK文件和字节码，因此它将通过应用程序的原始完整性检查，这使得用户可以轻松部署它。此外，这种动态方法自然不受代码或数据混淆的影响，可以提供实时保护。为了验证我们的方法，我们实现了一个RANSOMSENTRY原型，并收集了2376个最近的Android勒索软件样本进行评估。评估结果表明，我们的原型可以有效地检测勒索软件攻击，并具有可接受的性能开销。</p><h2 id="_1-introduction" tabindex="-1"><a class="header-anchor" href="#_1-introduction"><span>1. Introduction</span></a></h2><p>如今，安卓已经成为占主导地位的移动平台，拥有超过70%的市场份额[1]。</p><p>它受欢迎的一个潜在原因是，用户可以从各种来源安装他们的应用程序（或简称应用程序），包括谷歌应用商店、第三方应用商店，甚至可以下载APK（Android应用程序包）文件的网站。然而，这些特征和用户在移动设备上存储数据的倾向使Android成为勒索软件作者的热门目标[2]。更糟糕的是，Google Play作为最大、最受欢迎的安卓应用商店[3]、[4]，已经成为威胁行为者向受害者传递勒索软件的最有效平台，因为从官方商店安装的应用程序在要求采取一些可疑行动时不太可能受到怀疑[5]。卡巴斯基的一份报告显示，2023年检测到11065个新的移动勒索软件样本，攻击变得越来越复杂[6]。</p><p>勒索软件是一种恶意软件，通过阻止受害者访问受感染设备上的文件、应用程序和其他资源来勒索用户。具体来说，勒索软件攻击用户有两种主要方式[2]、[7]、[8]。第一种是锁定受感染设备的屏幕，另一种是加密用户的文件[8]。我们将前者称为锁屏勒索软件，后者称为加密勒索软件。由于人们逐渐倾向于将私人数据（如照片、联系人、聊天记录）保存到移动设备而不是个人电脑上，因此移动勒索软件锁定设备或加密私人数据的威胁现在比以往任何时候都大[8]。本文针对安卓平台上的锁屏和加密勒索软件。</p><p>为了应对安卓勒索软件的威胁，研究人员提出了一些检测解决方案，大致可分为两类：静态和动态。特别是，静态检测系统旨在通过分析Android勒索软件和良性应用程序之间的不同静态特征来检测勒索软件。静态系统不是执行代码，而是从Android应用程序的APK和dex（Dalvik可执行格式[9]）文件中提取API和资源等功能。然后，可以将特定的技术应用于这些功能，以将勒索软件与其他应用程序区分开来。例如，HelDroid[10]利用文本分类器、静态污染跟踪和轻量级Smali模拟器分别搜索（或识别）威胁文本、加密活动和锁屏活动。它能够将恶意软件样本分为三类，即勒索软件、恐吓软件和其他恶意软件。R-PackDroid[11]是另一种检测Android勒索软件的静态方法。基于系统API包和随机森林分类器的信息，R-PackDroid能够将Android应用程序分类为勒索软件、恶意软件或良性应用程序。然而，静态解决方案的主要弱点是它们不能在实时模式下工作，因此无法及时检测到攻击[12]。此外，静态解决方案无法处理代码或数据混淆的情况，这阻碍了这些系统的实际部署。</p><p>相比之下，动态检测系统旨在通过执行应用程序的代码在运行时检测恶意行为。例如，RansomProber[12]监控受感染设备上敏感文件的操作，并通过实时测量信息熵来识别加密操作。然后，通过检查应用程序的用户界面和布局，RansomProber确定加密操作是否出于用户的意图；否则，这些操作将被识别为恶意。通过这样做，它实现了勒索软件检测的高精度。然而，RansomProber仅针对加密勒索软件。DNA Droid[13]提出了一种实时的Android勒索软件检测框架，借助软件模块快速评估样本。如果样本被标记为可疑，它将使用修改后的模拟器持续监控和分析样本的运行时行为，该模拟器捕获API调用序列，然后将其与恶意样本进行比较，以进行攻击检测。然而，高级攻击者可以通过识别丢失的硬件和手机标识符来躲避模拟环境[14]，这阻碍了DNA Droid的动态分析。</p><p>在本文中，我们提出了RANSOMSENTRY，这是一个基于编译器的检测系统，用于识别Android勒索软件攻击。与静态系统相比，这种运行时方法自然不受代码或数据混淆的影响。此外，与依赖于仿真或虚拟化环境的现有动态系统不同，RANSOMSENTRY部署在真实的移动设备上，这些环境很容易被熟练的攻击者检测和绕过[15]。此外，作为一种系统级解决方案，RANSOMSENTRY基于修改后的Android dex2oat编译器，并在应用程序安装过程中执行检测。与其他插装或挂钩技术（如字节码重写技术[16]）相比，RANSOMSENTRY不需要更改应用程序的APK文件和字节码。因此，它将通过应用程序的原始完整性检查，这通常是应用程序开发人员用来验证签名密钥是否被盗版的方法。</p><p>RANSOMSENTRY检测Android勒索软件的主要思想是在应用程序被定制的编译器检测后，在应用程序执行期间监控敏感框架API的行为。请注意，Android平台在框架层为应用程序提供了各种API，而其中一些API可能会被勒索软件作者恶意调用，我们称之为敏感API。例如，在Android中，加密勒索软件经常调用Cipher类的<code>doFinal()</code>方法来加密用户的文件，而锁屏或加密勒索软件可以使用<code>startActivity()</code>方法启动包含威胁消息的活动。 使用修改后的dex2oat编译器，RANSOMSENTRY的检测指令在编译过程中被注入可执行文件（即oat文件），并将在调用敏感API时执行。通过这样做，RANSOMSENTRY可以拦截敏感的API调用，并在应用运行时收集锁屏和文件访问的行为信息。</p><p>特别是，为了获得关于锁屏操作的信息，RANSOMSENTRY监视布局和活动的API调用模式的整个生命周期。此外，RANSOMSENTRY能够提取活动上显示的威胁文本，稍后可以将其与勒索软件进行比较以检测攻击。为了获取有关文件相关活动的信息，RANSOSTERY会监视所有文件访问操作以及目标应用程序在特定目录中写入的文件的熵值。一旦收集到信息，RANSOMSENTRY就对勒索软件的敏感API调用模式进行建模。</p><p>然后，在运行时，它通过执行与建模模式匹配的安全策略来识别攻击。如果识别到勒索软件攻击，RANSOSTERY将提醒用户，并根据预定义的安全策略执行进一步的操作（例如，杀死勒索软件进程）。</p><p>为了验证我们的方法，我们实现了一个RANSOMSENTRY原型，并从几个流行的数据集中收集了2376个最近的勒索软件样本，包括VirusTotal[17]和之前的研究[10]，[12]。我们首先选择300个勒索软件样本来确定需要检测的敏感API，并对勒索软件的API调用模式进行建模。然后，我们使用剩余的2076个样本来评估原型的有效性。评估结果表明，RANSOMSENTRY能够检测到这两种类型的勒索软件。此外，RANSOMSENTRY引入的运行时性能开销是可以接受的。</p><p>总体而言，本文做出了以下贡献。</p><ul><li><p>我们提出了一种名为RANSOMSENTRY的运行时解决方案来检测Android勒索软件。RANSOMSENTRY基于定制的dex2oat编译器，提供了一种在运行时检测锁屏和加密勒索软件的机制。此外，RANSOMSENTRY不需要更改应用程序的字节码和签名。</p></li><li><p>我们实现了RANSOMSENTRY的原型，该原型在安装目标应用程序的编译阶段检测敏感API，并在运行时监控应用程序的屏幕相关和文件访问操作。此外，它还执行安全策略来识别勒索软件攻击。</p></li><li><p>我们使用最近的Android勒索软件样本进行评估。评估结果表明，RANSOSTERY能够高精度地识别勒索软件，同时施加可接受的性能开销。为了让整个社区参与进来，我们计划在https://github/XDU-SysSec/RansomSentry 上发布我们评估中使用的勒索软件样本数据集。</p></li></ul><p>本文的其余部分组织如下。首先，我们介绍了威胁模型和假设，并在第二节中介绍了系统设计。然后，我们分别在第III节和第IV节中展示了实施细节和评估结果。之后，我们在第五节中讨论了我们当前原型的局限性和潜在的改进。相关工作在第六节中进行了描述。最后，在第七节中总结了本文。</p><h2 id="_2-系统设计" tabindex="-1"><a class="header-anchor" href="#_2-系统设计"><span>2. 系统设计</span></a></h2><h3 id="a-overview" tabindex="-1"><a class="header-anchor" href="#a-overview"><span>A. Overview</span></a></h3><p>威胁模型和假设：本文主要研究Android勒索软件的防御。我们首先假设，与其他类型的Android恶意软件类似，勒索软件以多种方式传播，包括从应用商店下载恶意应用程序（例如Google Play[5]、[18]、[19]），点击电子邮件或短信中的可疑链接[20]，或使用不安全的Wi-Fi/URL[21]。其次，我们假设勒索软件利用两种方式攻击Android设备进行勒索，即锁定设备和加密用户文件。因此，我们的方法需要同时击败这两种恶意行为。第三，我们假设Android平台的应用层是不可信的，而应用层以下的组件是可信的，包括Android框架、Android运行时（ART）、本机C/C++库和Linux内核[22]。我们不信任应用层，因为Android的预装和第三方应用程序将仅安装在这一层[23]，这意味着勒索软件也可能驻留在这一层面。</p><p>总体设计：我们的目标是实时检测Android勒索软件（包括锁屏和加密勒索软件）。为了实现这一目标，我们监控Android勒索软件的行为，并在运行时捕获它们以识别攻击。具体来说，锁屏勒索软件试图禁用用户与设备之间的正常交互，而加密勒索软件则执行多种与文件相关的操作（例如，文件读取、写入、删除）来加密受感染设备上的文件。这些行为是通过调用相应的框架API（称为敏感API）来执行的。因此，我们通过检测敏感API来捕获这些行为，并从这些API中收集必要的信息（例如，应用程序特定信息、屏幕布局和文件操作），以得出勒索软件行为的模式。然后，我们利用这些模式在运行时进行勒索软件检测。</p><p>图1显示了我们的系统的总体设计，称为RANSOMSENTRY。特别是，RANSOMSENTRY由三个模块组成：基于编译器的仪器、拦截器和检测器，如图1所示。通常，当安装应用程序时，其dex文件会被dex2oat编译器转换为可执行文件（即oat文件）。相比之下，在安装目标应用程序的过程中，RANSOSTERY利用修改后的dex2oat编译器和一个新的模块，即基于编译器的检测，来编译应用程序（1）。</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通过这样做，拦截器和检测器模块的代码在编译之前被注入到应用程序的原始代码中，并生成插入指令的代码（2）。当仪表化应用程序执行时，拦截器模块捕获敏感API的调用并收集相关信息（3），这些信息被发送到检测器模块（4）进行攻击检测。相比之下，其他API的调用直接转发到Android框架（5）。根据收集到的信息，检测器模块执行检测策略（如第II-D节的算法1所示），以确定应用程序是否是勒索软件（6）。如果没有，应用程序将继续运行，敏感API将照常调用（7）；否则，如果应用程序被识别为勒索软件，则RANSOMSENTRY会发出警报（8），并可能根据预设的安全策略终止应用程序的执行。</p><h3 id="b-监控敏感api" tabindex="-1"><a class="header-anchor" href="#b-监控敏感api"><span>B. 监控敏感API</span></a></h3><p>RANSOMSENTRY通过监控应用程序执行过程中敏感框架API的行为来检测勒索软件。为了实现这一目标，我们需要解决两个设计挑战。首先，我们需要确定应该监视哪些API（即敏感API）以获取有关勒索软件相关行为的信息。其次，我们需要执行指令插装来捕获敏感API的调用，而不会篡改APK文件。这很重要，因为应用程序在发布APK文件之前会使用证书密钥进行数字签名，并且应用程序的完整性在设备上安装或更新时会使用签名密钥进行验证[24]，[25]。</p><p>确定敏感API：为了解决第一个挑战，即确定哪些API是敏感的，我们需要确定勒索软件必须执行哪些操作来完成其恶意行为。然后，我们找到执行这些操作的API，并将其归类为敏感API。</p><p>如第一节所述，有两种类型的勒索软件，即锁屏和加密勒索软件。他们通过不同的操作勒索用户。具体来说，锁屏勒索软件会锁定受感染的设备以阻止用户与其交互，而加密勒索软件则使用加密算法系统地加密受害者的文件。因此，对于锁定屏幕或阻止交互的行为，应监控布局操作，因为Android布局用于定义用户界面。布局包含出现在Android应用程序或活动屏幕上的UI控件或小部件[26]。此外，勒索软件经常在屏幕上显示勒索威胁信息[27]，其中包含如何支付赎金（例如，通过比特币或MoneyPak[28]）以获取解密密钥[29]的说明。通过监视布局也可以捕获此消息。因此，与布局操作相关的API被归类为应被监控的敏感API。</p><p>同样，对于加密文件的行为，需要监控与文件相关的操作，如文件打开、创建、读取、写入、删除、关闭和目录遍历。因此，用于这些操作的API也被视为敏感API。此外，作为一个细粒度的检测系统，RANSOMSENTRY需要识别执行相应恶意操作的主机应用程序。为了实现这一点，我们的系统必须获取特定于应用程序的信息，以便在运行时了解目标应用程序的基础知识。在Android中，可以从目标应用程序的上下文中获取特定于应用程序的信息。特别是，Context类是关于应用程序环境的全局信息的接口，允许访问特定于应用程序的资源和类[30]。在Context的帮助下，RANSOMSENTRY可以在运行时访问目标应用程序的资源和组件（例如，包名、资产和活动）。因此，需要监控用于获取上下文的API。</p><p>为了找到执行上述操作的敏感API，我们对由300个活动勒索软件样本组成的训练集进行了静态分析（见第II-C节）。具体来说，我们首先使用AAPT2[31]工具转储并记录训练集中每个样本的静态信息，包括包名、APK文件大小等。此外，我们使用jadx[32]和dex2jar[33]将样本的字节码反编译为Java代码。最后，我们通过分析Java代码并参考Android API reference[34]来识别勒索软件调用的几个敏感API。例如，<code>addView()</code>通常用于弹出覆盖窗口，<code>Cipher.init()</code>用于使用密钥和一组加密文件的算法参数初始化密码对象。最终，我们确定属于15个类的36个API为敏感API。表I列出了需要监控的信息类型（type）、类名称（class）和相应的敏感API（API）。值得注意的是，如果需要，该列表可以很容易地扩展到检测勒索软件变体的新行为。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>基于编译器的检测：为了检测应用程序的安全性，传统方法通常通过使用Javassist在其dex文件中重写应用程序的字节码来直接钩住敏感的API[35]，然后重新打包应用程序文件以供发布。然而，这种方法在重写和重新打包过程中会对原始APK文件进行修改，从而导致应用程序在安装时的完整性检查失败。为了应对这一挑战，我们利用一种称为基于编译器的工具的不同方法，在应用程序安装过程中使用修改后的Android dex2oat编译器对敏感的API调用进行工具化。</p><p>自Android 4.4 KitKat以来，ART（Android Runtime的缩写）已被引入，并自Android 5.0以来完全取代了Dalvik[36]，[37]，[38]。从Dalvik到ART最显著的变化是，Dalvik基于准时制（JIT）编译，而ART采用提前（AOT）编译。使用ART，应用程序运行速度更快，但存储空间和安装时间稍长，因为应用程序的字节码在安装过程中被编译为本机代码。在运行时，加载并执行本机代码，而不需要额外的时间来编译字节码。dex2oat编译器负责ART中的AOT编译[39]。给定一个APK文件，dex2oat编译器首先从中提取dex文件，然后将文件中的字节码转换为基于Java方法的中间表示（IR），最终将其编译为本机代码并写入oat文件。具体来说，我们的instrumentation是在操作IR的过程中进行的。在编译过程中，IR会经历几轮优化，每一轮都称为优化过程。例如，循环优化过程能够消除循环体内的死代码。</p><p>因此，我们将我们的插装集成到自定义优化过程中。请注意，Java方法调用对应于IR中的单个指令，该指令具有特定类型（例如kVirtual、kStatic和kDirect），并且与Java方法具有相同的签名。自定义通行证访问IR，并通过特定类型和签名发现与敏感API对应的指令。通过编译器提供的函数，该过程可以在指令级别操纵IR，例如构造、插入、修改或删除指令。通过这样做，我们的自定义传递可以在特定API之前插入调用自定义Java方法的新指令。因此，目标应用程序的敏感API调用被拦截。在代码插装之后，IR被编译为本机代码并存储在应用程序的oat文件中，该文件将在运行时加载和执行。请注意，原始应用程序的签名被保留，dex字节码在整个过程中保持不变。</p><h3 id="c-行为模式建模" tabindex="-1"><a class="header-anchor" href="#c-行为模式建模"><span>C. 行为模式建模</span></a></h3><p>通过监控敏感API的调用，如果应用程序的行为与勒索软件的行为模式相匹配，RANSOMSENTRY会识别勒索软件。因此，我们首先需要对勒索软件的行为模式进行建模。为了实现这一点，我们构建了一个包含最近活动勒索软件样本的训练集，并运行这些样本来记录它们与布局和文件相关的操作。我们从之前的研究[10]中随机选择300个活跃的勒索软件样本来构建训练集。这些样本的家族和每个家族的样本号如table.2所示。值得指出的是，根据先前的研究[10]、[12]和现有的报告[8]、[40]，这些样本涵盖了最受欢迎的Android勒索软件家族及其变体，确保建模的行为模式有效地捕捉到不同勒索软件家族共享的核心特征。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通过手动检查每个样本，我们确认训练集中的所有样本都是活动的，并且代表了勒索软件威胁格局。因此，我们认为我们的训练集是一个地面真理集。</p><p>我们利用修改后的dex2oat编译器来执行代码插装。通过重新编译300个训练样本，Interceptor模块在IR中每个敏感API的调用指令之前被注入。在运行时，当样本应用程序调用敏感API时，Intercepter模块获得数据（例如，签名、参数和时间戳）和文件访问操作的信息（例如，文件名、写入数据）。然后，我们在设备上手动运行这些重新编译的示例，并收集它们的运行时日志。通过分析日志，我们发现66个样本劫持活动，228个样本弹出全屏覆盖窗口，119个样本重置密码，15个样本加密外部存储上的文件。请注意，一个样本可能会执行上述多种行为。例如，一个示例可能会在前台劫持活动，同时在另一个线程中加密文件。我们训练数据集中勒索软件类型的分布与现实世界Android勒索软件感染中观察到的流行模式非常相似。根据卡巴斯基实验室的一份报告，与加密勒索软件占主导地位的PC平台不同，Android勒索软件主要是基于锁屏的[41]。加密勒索软件在Android上的有限传播可归因于两个关键因素。首先，最近的Android安全增强功能限制了第三方应用程序对用户文件的访问。例如，在Android 11或更高版本中，针对API 30或更高级别的应用程序必须使用作用域存储，这限制了应用程序对外部存储的访问[42]。其次，移动应用程序中自动云备份的广泛使用降低了本地文件加密的影响。与传统PC相比，这些因素显著降低了基于加密的攻击对Android设备的有效性。通过获得这些勒索软件样本的行为信息，我们可以相应地对勒索软件行为模式进行建模。</p><p>最后，我们确定了三种锁屏行为模式，即模式a、模式b和模式c，如图2所示，以及一种文件加密行为模式，如图3所示，即模式d。</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>模式a：强制使用无法回避的全屏窗口。</p><p>勒索软件在获得<code>SYSTEM_ALERT_window</code>权限后，可以通过调用<code>WindowManager.addView()</code>来强制施加一个不可避免的全屏覆盖窗口来锁定屏幕。与常规的全屏应用程序不同，它占据了整个屏幕，包括覆盖导航栏，并主动阻止用户与底层系统的交互。这是通过使用通常为系统级接口保留的特定类型（例如<code>TYPE_SYSTEM_ERROR</code>、<code>TYPE_PHONE</code>）和标志（例如<code>FLAG_LAYOUT_IN_SCREEN</code>和<code>FLAG_FULLSCREEN</code>）设置覆盖窗口来实现的。这种覆盖的恶意性质具有几个关键的区别：使用通常为系统级界面保留的窗口类型和标志，故意阻止或忽略用户退出全屏模式或返回主屏幕的努力，以及全屏显示与其他恶意行为的结合。相比之下，包括游戏在内的合法全屏应用程序通常尊重用户控制，并提供简单的退出选项，而不会主动阻止对系统导航的访问。通过捕获<code>WindowManager.addView()</code>的调用并检查覆盖窗口的视图对象、类型和标志，可以识别恶意覆盖，这些对象、类型、标志被配置为最大化屏幕覆盖率并最小化用户控制。这种对API调用、窗口类型和窗口标志的细微检查能够有效区分良性全屏幕应用程序和恶意勒索软件行为。</p><p>模式b：重置PIN。勒索软件可以通过调用<code>DevicePolicyManager.resetPassword()</code>来请求设备管理器权限并重置个人识别码（PIN），以防止用户解锁他们的设备。通过监视<code>DevicePolicyManager.resetPassword()</code>的调用，可以从API的参数中捕获新的PIN。</p><p>模式c：阻断交互。勒索软件可以通过劫持活动来阻止用户与设备交互，攻击者可以通过两种方式实现。一方面，勒索软件可能会在通过调用<code>ActivityManager.getRunningTasks()</code>确认当前顶部活动属于另一个应用程序后，通过调用<code>startActivity()</code>来启动自己的活动。另一方面，它可能会启动一个<code>TimerTask</code>，定期启动活动。由于我们可以获得与活动相关的应用程序上下文，因此可以自然地捕获这种模式。</p><p>模式d：加密文件。我们根据勒索软件需要通过调用文件相关的API（例如<code>file.read()</code>和<code>file.write()</code>）以及用于数据加密的密码相关API（例如<code>cipher.update()</code>和<code>cipher.doFinal()</code>）来操作外部存储上的用户文件这一事实来识别文件加密模式，如图3所示。首先，勒索软件应用程序启动一个后台线程，贪婪地遍历外部存储目录（即/sdcard/），并构建一个目标文件列表。请注意，一些勒索软件应用程序倾向于将所有文件添加到列表中，而另一些则只对某些文件类型（例如mp4、docx和jpg）感兴趣。其次，对于列表中的每个目标文件，勒索软件应用程序都会创建一个新的未知类型文件，其前几个字节（即幻数[43]）无效。最后，勒索软件应用程序从目标文件读取数据并执行数据加密。然后，它将加密数据写入新文件并删除原始目标文件。我们将上述操作识别为由加密勒索软件执行的文件访问行为模式，并且可以在运行时通过捕获相关API的调用来识别。</p><p>特别是，我们的实验表明，对于所有锁勒索软件样本和大多数加密勒索软件样本，在攻击完成后，将弹出一条威胁消息，通知用户赎金支付的详细信息。威胁信息可以显示为文本或图像，受害者必须能够阅读和理解[10]。因此，通过从前台活动中提取威胁信息，可以确认勒索意图。</p><h3 id="d-检测策略" tabindex="-1"><a class="header-anchor" href="#d-检测策略"><span>D. 检测策略</span></a></h3><p>我们的检测策略基于我们在第II-C节中建模的勒索软件的行为模式。当从拦截器接收监控信息时，检测器会执行检测策略，以确定应用程序的锁屏或文件访问行为是否是恶意的。算法1显示了由检测器执行的检测策略。</p><p>具体而言，对于每个接收到的监控信息（第2行），算法1利用switch语句根据信息的类型采取不同的动作（第3行）。对于锁屏情况（第4行），它确定锁屏图案是否匹配（第5行）；如果是，它将变量lock_screen_pattern_match设置为True，并断开switch语句（第6-7行）。对于文件访问情况（第8行），它确定访问的文件是否在受监视的目录中（第9行）；如果是，它将接收到的信息添加到文件操作队列中，记录文件的前几个字节（即幻数）及其类型，并计算写入字节的熵（第10-12行）。此外，它确定文件访问模式是否匹配（第13行）；如果是，它将变量file_encrypt_pattern_match设置为True，并断开switch语句（第14-15行）。对于文本案例（第16行），它确定从前景活动中提取的文本是否包含威胁消息（第17行）；如果是，它将变量threatening_message设置为True，并断开switch语句（第18-19行）。接下来，算法确定lock_screen_pattern_match和threatening_message是否为真（第20行）；如果是，它会提醒用户检测到勒索软件，并可能根据安全策略采取进一步行动（第21行）。否则，算法确定iffile_encrypt_pattern_match为真（第22行）；如果是，它将做出进一步的决定。具体而言，该算法首先确定threatening_message是否为真（第23行）；如果是，它会提醒用户检测到勒索软件，并可能根据安全策略采取进一步行动（第24行）。相反，如果threatening_message不为真，该算法会将熵与α进行比较，α是我们设置的阈值（见第III-D节）。如果熵大于α（第25行），它会进一步检查记录文件的幻数及其类型，以排除良性应用程序产生的高熵值情况。如果幻数无效且类型未知（第26行），则算法会提醒用户检测到勒索软件，并可能根据安全策略采取进一步行动（第27行）。</p><figure><img src="'+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_3-实现" tabindex="-1"><a class="header-anchor" href="#_3-实现"><span>3. 实现</span></a></h2><p>为了验证我们的方法，我们开发了一个RANSOMSENTRY的概念验证原型，该原型由三个模块组成，即基于编译器的仪器、拦截器和检测器。具体来说，基于编译器的instrumentation模块是用C++编程语言编写的，并集成在Android系统的dex2oat编译器中，负责在应用程序的Java字节码编译为本机机器代码期间注入拦截器和检测器模块代码。拦截器和检测器模块用Java编写，并打包为库APK文件。在编译之前解析应用程序的APK文件后，此文件将与原始应用程序合并。总体而言，整个RANSOMSENTRY原型的代码库由1500行C++代码和4500行Java代码组成。</p><p>RANSOMSENTRY的实现细节如图4所示。在下文中，我们将深入探讨支撑RANSOMSENTRY功能的关键技术。</p><figure><img src="'+E+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="a-合并instrumentation库" tabindex="-1"><a class="header-anchor" href="#a-合并instrumentation库"><span>A. 合并Instrumentation库</span></a></h3><p>为了降低开发复杂性并促进未来的升级，用高级语言实现拦截器和检测器模块提供了一种更实用的方法。因此，我们用Java开发这些模块，并将其封装为标准APK文件中的库，该文件固有地包含dex文件。如图4所示，在应用程序安装过程中，系统的<code>PackageManagerService</code>首先解压缩应用程序的APK文件并解析其dex文件。通过将RANSOMSENTRY库APK文件（2）中的dex文件与原始应用程序APK文件（1）中的index文件合并，我们确保拦截器和检测器Java代码被合并到目标应用程序中，从而实现后续的编译时注入。</p><p>为了完成合并，我们开发了一个图形用户界面（GUI）应用程序，允许用户在安装前选择用于RANSOMSENTRY注入的目标应用程序。用户选择后，所选应用程序将进行预安装合并过程，合并RANSOMSENTRY的库索引文件。我们修改了一个开源项目[44]来促进这种合并操作。成功合并后，GUI应用程序调用系统的dex2oat编译器来执行编译。</p><p>值得指出的是，Android系统在解析APK文件的内容之前会验证其签名[45]。因此，在解析APK文件后执行合并操作不会损害原始APK文件的签名。因此，我们的方法确保应用程序能够成功通过签名验证过程。</p><h3 id="b-注入instrumentation代码" tabindex="-1"><a class="header-anchor" href="#b-注入instrumentation代码"><span>B. 注入Instrumentation代码</span></a></h3><p>从APK文件中提取dex文件后，ART启动dex2oat编译过程，将dex字节码转换为优化的本机代码。这个过程是ART系统的核心，主要在方法级别运行，提供了一种细粒度的优化方法。</p><p>dex2oat编译器首先解析dex文件并构造代码的内存表示。至关重要的是，这种表示是围绕单个方法组织的，为后续的分析和转换阶段奠定了基础。对于每种方法，编译器都会生成一个中间表示（IR），通常是一个控制流图（CFG），作为优化的基础。优化阶段是编译过程的关键组成部分，在这种方法级中间表示上运行。dex2oat编译器对每个方法分别应用各种优化技术，包括方法内联、常量传播、死代码消除和循环展开。这种以方法为中心的方法允许进行高度有针对性的优化，这些优化可以根据每种方法的特定特征和使用模式进行定制。</p><p>在上述方法级优化过程的基础上，RANSOMSENTRY的基于编译器的Instrumentation模块利用优化阶段来实现其注入机制。因此，我们可以将监控功能无缝集成到目标方法（即敏感API）中。具体来说，在系统编译器完成其默认优化过程（如图4中的第一步到第二步所示）后，基于编译器的检测模块对目标方法执行额外的优化过程（即图4中“勒索哨兵过程”）。此额外通道旨在将RANSOMSENTRY库中相应监控方法代码的中间表示注入目标方法。注入过程灵活，可以根据特定的监测要求进行定制。根据监控目标，注入的代码可以定位为在原始目标方法调用“之前”或“之后”执行。因此，RANSOMENTY能够综合监测和分析目标方法的输入、输出或两者。</p><p>为了实现注入操作，我们利用开源项目修改了Android系统的dex2oat编译器[46]。然而，由于该项目最初只支持Android 8，我们进行了广泛的扩展和调整工作，以确保其与Android 13的兼容性，Android 13是目前全球使用最广泛的Android系统[47]。这一显著增强使我们的注入机制能够在使用最广泛的Android平台上正常运行。</p><p>在编译和优化过程之后，生成的本机代码被打包成一个oat文件（如图4中的3所示），即“插入指令的oat文件”，它是设备上应用程序的主要可执行格式。</p><h3 id="c-拦截敏感api" tabindex="-1"><a class="header-anchor" href="#c-拦截敏感api"><span>C. 拦截敏感API</span></a></h3><p>当应用程序启动时，ART会将其oat文件加载到内存中。oat文件包含一个内存映射，允许有效地定位和执行单个方法。当应用程序运行时，方法调用会触发ART使用此内存映射在oat文件中定位相应的本机代码。</p><p>对于未被归类为敏感API的方法，执行直接进行（如图4中的4所示）。ART只是跳到适当的内存地址，并执行该方法的本机代码。相比之下，由RANSOMSENTRY基于编译器的Instrumentation模块检测的敏感API遵循修改后的执行路径。当调用这种方法时，ART会执行注入的代码，该代码由拦截器和检测器模块组成。</p><p>Interceptormodule拦截API调用及其参数，并收集必要的上下文信息。该模块位于原始方法主体之前或之后，具体取决于每个敏感API的具体监控要求。对于执行前拦截，Interceptor在调用敏感的API之前运行（5）。它捕获输入参数和相关上下文信息，如呼叫者的身份或当前应用程序状态。拦截过程完成后，执行流到原始敏感的API方法主体。对于执行后拦截，敏感的API方法主体首先执行，然后立即执行Interceptor模块（6）。在这种情况下，拦截器模块捕获方法的返回值和任何输出参数，以及相关的上下文信息。一旦拦截器模块收集到这些信息，它就会将收集到的数据传递给检测器模块，检测器模块负责识别潜在的勒索软件行为。</p><p>值得指出的是，在我们的原型中，RANSOMSENTRY的检测代码在Java中实现为单例类[48]。单例实例维护一个共享状态，允许它在整个应用程序的执行过程中聚合和关联来自各种仪器化方法的信息。当调用任何插入指令的方法时，它都会触发相同的RANSOMSENTRY实例，传递相关的上下文信息。RANSOMSENTRY根据上下文信息更新其内部状态，从而构建应用程序在多个方法调用中的行为的全面视图。这种设计确保了整个应用程序中只存在一个RANSOMSENTRY实例，无论有多少仪器化方法调用它。因此，RANSOMSENTRY可以在整个运行时持续维护和更新整个应用程序的所有所需信息。此外，无缝集成设计便于将RANSOMSENTRY的监控功能透明地整合到原始应用程序逻辑中。从调用方的角度来看，方法调用过程保持不变，ART将原始敏感的API代码和注入的代码作为一个单一的、有凝聚力的单元来执行。</p><h3 id="d-勒索软件行为检测" tabindex="-1"><a class="header-anchor" href="#d-勒索软件行为检测"><span>D. 勒索软件行为检测</span></a></h3><p>在从拦截器模块接收到数据后，检测器模块执行第II-D节中描述的勒索软件检测算法并生成检测结果。如果结果为良性，则允许该方法继续执行（如图4中的7所示）。相反，如果结果指示勒索软件，则通过<code>AlertDialog()</code>等方法向用户发出警报，并将检测结果记录在系统日志中（8）。同时，<code>Detector</code>模块执行安全策略（9）建立的预设操作，例如调用<code>killProcess()</code>强制终止应用程序。下面，我们将详细解释此检测过程的关键方面。</p><p>分析获得的信息：如第II-B节所述，三种关键类型的信息对于有效的勒索软件检测至关重要：布局相关信息、文件相关信息和应用程序特定信息。</p><p>布局相关信息是通过访问视图对象获取的，视图对象包含Android中的布局和小部件。原型通过调用Activity获得顶级视图。<code>getWindow()</code>和<code>Window.getDecorView()</code>，可以全面监控活动的布局。这种方法允许RANSOMSENTRY通过放置在活动上的小部件进行导航，利用视图对象组织的树结构。具体来说，RANSOMSENTRY采用视图对象树的递归遍历。从获得的顶级视图开始，通过递归调用<code>getAllChildren()</code>访问每个级别。当一个视图对象被标识为<code>TextView</code>或其子类的实例时，RANSOMSENTRY调用<code>getText()</code>将文本提取为字符串值。此外，<code>WindowManager.addView()</code>被检测以提供对新添加的视图对象的访问。</p><p>为了收集与文件相关的信息，RANSOMSENTRY检测Java I/O流API。此Instrumentation允许RANSOMSENTRY监视目标应用程序的文件访问操作。此外，RANSOMSENTRY将钩子注入到与密码相关的API中，以监视和拦截文件加密行为，并获取加密密钥。通过注入这些API，RANSOMSENTRY分析文件操作和加密活动，识别加密勒索软件的行为模式。</p><p>要获取特定于应用程序的信息，必须检索目标应用程序的上下文。这是通过访问从Context继承的主活动来实现的。<code>onCreate()</code>方法被插入指令，并在主活动启动时被调用，从而提供对Context的访问。在Context可用的情况下，将回调方法注册到<code>ActivityLifecycleRebacks</code>接口。此注册允许监控目标应用程序的活动生命周期阶段。</p><p>计算熵：与正常数据相比，加密勒索软件生成的加密数据通常表现出更高的香农熵值，这是攻击检测的一个关键因素[49]。因此，RANSOMSENTRY计算每个文件的写入数据的香农熵。香农熵的计算公式为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><msub><mo>∑</mo><mi>i</mi></msub><mo>−</mo><msub><mi>p</mi><mi>i</mi></msub><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">H= \\sum_i −p_i log 2p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示数组中第i个字节的值的频率。</p><p>为了为加密数据熵建立一个适当的阈值，我们使用100个大小从30KiB到80MiB不等的文件进行了一项实验，包括.mp4、.jpg、.docx、.zip等。然后，我们使用训练集中的加密勒索软件样本来加密这些文件。通过使用Python脚本，我们计算了这些文件在原始和加密状态下的平均熵。结果显示，未加密文件的平均熵值为6.31，加密文件为7.81。这些发现与现有的研究[50]一致，该研究报告称，基于广泛的文件分析，加密文件的熵始终超过7.85。基于我们的实验结果及其与先前研究的一致性，我们将熵阈值α设置为7.8。此阈值用于区分加密和非加密文件。</p><p>然而，值得注意的是，一些良性应用程序，如文件压缩工具，也会产生高熵文件。为了应对这一挑战，我们采用了两个附加功能来区分非加密文件和真正加密的文件。首先，加密勒索软件通常试图快速彻底地遍历目录和文件，以最大限度地提高其勒索潜力，这种行为在良性应用程序中并不常见。其次，合法压缩的文件保持有效的幻数[43]和合法的文件类型。相比之下，由加密勒索软件加密的文件缺乏有效的幻数，并且通常是未知类型的。通过将这两个功能与熵阈值结合使用，RANSOMSENTRY可以有效地区分由加密勒索软件创建的加密文件和由良性应用程序生成的其他高熵文件。</p><p>提取威胁信息：勒索软件攻击的一个关键指标是通过文本或图像向用户显示威胁信息。为了检测这些威胁，RANSOMSENTRY采用了一种结合文本提取、图像分析和自然语言处理技术的综合方法。对于基于文本的威胁，RANSOMSENTRY使用Android框架回调函数和视图对象的分层组织从TextView对象及其子类中提取字符串。为了捕获嵌入在图像中的威胁，RANSOMSENTRY利用光学字符识别（OCR）技术，特别是Tesseract[51]，从视觉元素中提取文本。</p><p>提取后，RANSOMSENTRY应用了几个自然语言处理步骤。它将收集到的文本分割成句子，并使用NLTK库的列表删除停用词[52]。然后使用Snowball算法将剩余的单词转换为词干向量[53]，为进一步分析做好准备。为了增强威胁检测，RANSOMSENTRY结合了语义分析技术。它使用词嵌入来捕捉词之间的语义关系，并应用主题建模来识别威胁信息中的共同主题。这些技术允许对潜在威胁进行更细致的理解，即使是用不同的语言表达的。RANSOMSENTRY还维护着一个已知威胁文本的数据库，包括从HelDroid等先前作品中收集的文本[10]。它计算提取的文本和数据库条目之间的余弦相似度[54]。基于实证测试和与先前研究的一致性，我们将文本分类为潜在威胁的相似性阈值设置为0.6[55]。</p><p>为了确保这些复杂的分析不会影响用户体验，RANSOMSENTRY在单独的线程中执行相似性计算和其他密集处理。这种多线程设计集成了先进的威胁检测技术，不会显著影响主线程的执行，从而保持了系统的响应能力。通过这种多方面的方法，RANSOMSENTRY有效地识别和提取了各种格式和上下文中的威胁信息。</p><h2 id="_4-evaluation" tabindex="-1"><a class="header-anchor" href="#_4-evaluation"><span>4. Evaluation</span></a></h2><p>在本节中，我们将通过一系列实验对RANSOMSENTRY进行评估，并展示结果。</p><h3 id="a-实验配置" tabindex="-1"><a class="header-anchor" href="#a-实验配置"><span>A. 实验配置</span></a></h3><p>我们的实验在两个Android平台上进行：运行Android 8的Google Nexus 5X和运行Android 13的Google Pixel 5。这一选择涵盖了截至2024年7月拥有大量用户群的旧版本（Android 8，排名第7，市场份额超过4%）和当前最流行的版本（Android 13，市场份额领先于20%以上）[47]。</p><p>在实验之前，我们禁用每个设备的PIN并将其连接到互联网。此外，我们授予勒索软件样本所请求的权限，并运行每个样本30分钟。每次样品运行后，我们重置设备以避免样品之间的干扰。Android 8和Android 13平台均遵循此程序。</p><p>由于加密勒索软件可能会加密外部存储上的用户文件，我们通过随机收集现实世界用户的各种类型的文件（例如文档、媒体文件、存档文件和程序源文件）来构建一个目录，包括几个Android专用目录（例如/sdcard/Android/data/、/sdcard/DCIM/）。此设置在两台设备上复制，以确保我们的测试环境的一致性。</p><p>为了评估RANSOMSENTRY，我们建立了一个大规模的Android勒索软件样本数据集。样品的详细分布和检测统计见表三。</p><p>如表三所示，我们的数据集由2376个Android勒索软件样本组成，其中838个样本来自VirusTotal[17]（至少有一家反病毒供应商将其标记为勒索软件），其余1538个样本来自先前的研究[10]、[12]，没有任何额外的特定目标或选择标准来确保数据集的通用性和多样性。根据先前的研究[10]、[12]和现有的报告[8]、[40]，收集的样本涵盖了2014年至今观察到的绝大多数流行的Android勒索软件变体。它确保我们的数据集广泛代表了过去十年中Android勒索软件的威胁格局。如第II-C节所述，300个样本用于训练RANSOMSENTRY。剩余的2076个样本构成了我们的初始评估集。值得指出的是，用于评估的样本与训练集中的样本不重叠。上述非重叠特别适用于单个样本本身，而不是它们所属的勒索软件家族。换句话说，用于训练RANSOMSENTRY的300个样本与我们初始评估集中的2076个样本完全不同。此外，初始评估集包括来自勒索软件家族的样本，这些样本既包括在训练集中，也包括在训练集之外，从而能够全面评估RANSOMSENTRY检测来自熟悉和以前看不见的家族的勒索软件的能力。</p><p>我们对Android 8和Android 13平台的初始评估集进行可执行性验证。</p><p>在Android 8上，2076个样本中有222个无法安装在我们的设备上，或者在启动时崩溃。我们进一步分析了这些崩溃应用程序的日志，并找到了三个崩溃的原因。首先，应用程序没有正确初始化，因为Android系统在dex路径上找不到正确的类，尤其是主活动。其次，由于开发中缺乏空检查，启动时会发生NullPointerException[56]。第三，必要的资源丢失，尤其是AndroidManifest.xml，这是Android系统解析APK文件所依赖的关键配置文件。我们认为，这些失败的主要原因是勒索软件攻击者在开发应用程序时缺乏纪律[57]。此外，2076个样本中有15个无法由Android 8上的RANSOMSENTRY修改编译器编译，因为这些样本的APK文件有多个dex文件，可以使用64K或更多的方法引用[58]。我们在第五节中详细讨论了这一限制。在删除不可执行的示例后，我们最终得到1839个示例作为Android 8的最终评估集。</p><p>对于Android 13，可执行性验证显示了不同的结果。591个样本无法安装，23个样本不兼容，导致Android 13的最终评估集为1462个样本。除了提到的Android 8的原因外，无法在Android 13上安装或编译的样本数量较多，这可以归因于Android平台的多次迭代。由于更严格的权限限制、弃用的方法、增强的系统安全策略和硬件更改等因素，许多为早期Android版本设计的示例无法在较新的平台上安装或编译。这些兼容性问题在恶意软件样本中尤为明显，这些样本通常针对特定的漏洞或系统行为，这些漏洞或行为可能已在较新的Android版本中被修补或更改。</p><p>为了进一步评估RANSOMSENTRY区分勒索软件和良性应用程序的能力，我们使用150个合法的Android应用程序进行了额外的实验。该套件包括各种类别，包括游戏、社交网络应用程序、摄影工具、生产力软件、压缩和加密实用程序以及文件管理应用程序。在这150个应用程序中，有53个是压缩或加密应用程序，它们在文件上的行为可能类似于加密勒索软件。我们在Android 8和Android 13平台上执行这150个良性应用程序中的每一个，并启用RANSOMSENTRY来检查任何潜在的误报。</p><h3 id="b-检测结果" tabindex="-1"><a class="header-anchor" href="#b-检测结果"><span>B. 检测结果</span></a></h3><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如表三所示，RANSOMSENTRY从Android 8的最终评估集中的1839个样本中成功识别出1276个勒索软件样本。而对于Android 13，RANSOMSENTRY在最终评估集中的1462个样本中检测到1201个勒索软件样本。请注意，在最终评估集中，即使样本被标记为勒索软件，也不意味着样本可以成功锁定设备或加密文件。导致攻击失败的原因有很多。例如，在攻击过程中，某些样本可能需要与远程服务器通信，但远程服务器可能已关闭或不再可用[8]，[59]。</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>表四提供了检测到的勒索软件家族的详细列表，以及这两个Android版本的相应样本计数。我们认为检测到的样本涵盖了大多数流行勒索软件家族。在这些家族中，有8个家族与训练集重叠，即locker、simplecker、lockscreen、koler、jisut、svpeng、congr和slocker。因此，我们检测到除训练集之外的6个新家族，这表明所识别的模式在其他家族中普遍存在。</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们进一步分析了Android 8和Android 13的检测样本模式，结果如图5所示。对于Android 8，在1276个检测到的样本中，689个（53.99%）样本与模式a匹配，153个（11.99%）样本与图案b匹配，568个（44.51%）样本与试图加密用户文件的模式c匹配，62个（4.86%）样本与尝试加密用户文件的模式d匹配。同样，对于Android 13，在1201个检测到的样本中，672个（55.95%）样本与模式a匹配，138个（11.49%）样本与图案b匹配，533个（44.38%）样本与试图加密用户文件的模式c匹配，13个（1.08%）样本与模式d匹配。请注意，一个样本可能与我们在攻击期间在第II-C节中确定的多个模式相匹配。</p><p>上述结果清楚地表明，显示文件加密行为模式（模式d）的样本数量明显低于显示三种锁屏模式（模式a、b、c）的样本。我们认为，这些结果的一个原因是，由于移动设备的计算能力有限，在短时间内进行大规模数据加密是不切实际的，而锁定用户的设备可能是勒索的更有效方式。此外，我们的检测结果显示，与Android 8相比，Android 13上表现出加密勒索软件行为的样本数量显著减少。这一观察证实了第II-C节中提到的事实，即随着每次Android版本升级，系统对应用程序访问外部存储的限制越来越严格[42]。因此，未更新以适应这些更改的勒索软件样本在没有明确用户许可的情况下无法执行文件加密操作。在我们的研究中，这一趋势不仅在两个Android版本中都是一致的，而且与现实世界中Android勒索软件的流行趋势一致[41]，其中绝大多数Android勒索软件主要将设备锁定作为主要的攻击向量。</p><p>此外，我们对良性应用程序的实验证明了RANSOMSENTRY在区分勒索软件和合法应用程序方面的有效性。在53个压缩或加密应用程序中，尽管它们压缩文件或生成高熵加密文件，但没有一个创建了具有无效幻数的未知文件类型或显示赎金说明，从而避免了被错误识别为勒索软件。对于剩下的97个应用程序，RANSOSTERY正确地将其归类为良性，因为它们与任何勒索软件模式都不匹配。在应用程序显示具有类似于勒索软件的参数的叠加窗口的情况下，RANSOSTERY对前景活动的文本提取和相似性分析显示，威胁消息的相似性得分低于0.3，表明没有实际的类似勒索软件的行为。</p><p>假阳性：为了评估RANSOMSENTRY的假阳性率，我们在Android 8和Android 13的未经修改的Android系统上手动执行RANSOMSENTRY识别为勒索软件的样本，并观察它们是否表现出勒索软件行为。对于Android 8，我们分析了所有被识别为勒索软件的1276个样本。因此，它们都会锁定设备或加密用户文件，并显示赎金说明。同样，对于Android 13，我们检查了所有1201个检测到的样本，所有样本都显示了相同的勒索软件行为。这表明RANSOMSENTRY准确地识别了实际的勒索软件样本，两组样本中都没有误报。</p><p>另一方面，在评估良性应用程序时，我们遇到了一种不同的情况。使用这些良性应用程序的默认配置，它们都不会被RANSOMSENTRY识别为勒索软件。但是，如果我们故意修改某些加密或压缩应用程序的设置，然后执行加密或压缩操作，这些应用程序确实会被RANSOMSENTRY识别为勒索软件。这些设置包括：执行完整的设备目录遍历，在加密或压缩后删除源文件，以及使用非传统的加密或压缩格式。这些应用程序被识别为勒索软件，因为启用这些设置后，它们的行为与勒索软件非常相似（见第II-C节中的模式d）。然而，在典型的使用场景中很少遇到这种极端的配置。在我们测试的53个良性加密或压缩应用程序中，只有9个提供了这些高级定制选项。此外，为了保护用户文件，这些误报偶尔造成的不便被认为是一种可以接受的权衡。</p><p>假阴性：为了评估RANSOMSENTRY的假阴性率，我们采用了与假阳性分析相同的方法。我们在Android 8和Android 13的相同未修改的Android系统上手动执行未被识别为勒索软件的剩余样本。具体来说，对于Android 8，我们检查了563个样本，而对于Android 13，我们分析了261个样本。我们观察他们的GUI界面并分析他们的执行日志，以识别任何与锁屏或加密相关的操作。</p><p>我们的分析表明，这些样本都没有表现出勒索软件行为，例如锁定设备、加密用户文件或显示赎金说明。基于这些观察结果，我们认为假阴性率为零。然而，值得注意的是，在我们的实验中，未被RANSOMSENTRY识别为勒索软件的样本仍有可能是勒索软件。这一结果有几个原因，包括延迟激活、我们的环境中未满足特定触发器、高级规避技术、网络问题（例如，不可用的命令和控制服务器）、与较新Android版本的兼容性问题、不完整的恶意软件开发以及系统安全策略的干扰。这些因素可以防止勒索软件在我们的分析期间完全执行其预期的恶意行为。</p><p>尽管存在这些可能性，但作为一个动态检测系统，RANSOMSENTRY可以实时识别攻击。一旦样本开始表现出勒索软件行为，它将检测最初逃避检测的样本。此外，RANSOMSENTRY在适应新的勒索软件变体方面提供了极大的灵活性。用户可以通过其GUI应用程序轻松更新检测库。此功能允许快速扩展敏感的API列表并增强检测算法。因此，RANSOMSENTRY可以快速适应新出现的勒索软件威胁。</p><h3 id="c-性能开销" tabindex="-1"><a class="header-anchor" href="#c-性能开销"><span>C. 性能开销</span></a></h3><p>为了评估RANSOMSENTRY引入的开销，我们在Android 8和Android 13平台上进行了微观基准和宏观基准实验。</p><p>微基准：我们开发了一个微基准应用程序，用于记录运行时敏感操作所消耗的时间。我们选择了9个敏感操作，并在两个平台上执行每个操作50次，有和没有RANSOMSENTRY。我们进一步计算了RANSOMSENTRY引入的延迟。结果如图6所示。</p><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对于Android 8，结果显示，这些操作中的大多数仅延迟不到0.5毫秒，最大延迟不超过2毫秒。在Android 13上，延迟甚至更小，最小为0.11毫秒，最大不超过1毫秒。这些操作引入的总延迟也不超过1秒。与现有的实时检测技术相比，如RansomProber[12]，在真实设备上的中值分析时间超过2秒，RANSOMSENTRY对性能的影响较小。此外，根据谷歌关于Android生命体征的指导方针，如果一个应用程序的启动时间在冷启动时需要5秒或更长时间，在热启动时需要2秒或更长的时间，在高温启动时需要1.5秒或更长，则该应用程序的启动时间被认为过长[60]。根据这些基线，结果表明，RANSOMSENTRY引入的开销最小，在两个平台上都在可接受的范围内。</p><p>宏基准测试：我们使用三个常见的基准测试应用程序来评估RANSOMSENTRY的宏级开销：PassMark[61]、GeekBench[62]和PCMark[63]。我们在两个Android版本上运行每个基准应用程序10次，有和没有RANSOMSENTRY，并计算平均分（简称pts）。结果如图7所示。在Android 8上，RANSOMSENTRY引入的三个基准测试的开销分别为3.07%、2.55%和4.28%。对于Android 13，开销明显较低，分别为1.23%、1.83%和1.73%。</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们实验的一个重要观察结果是，在微观基准测试和宏观基准测试中，RANSOMSENTRY在Android 13上引入的开销始终低于Android 8。这种差异可归因于较新硬件平台的增强计算能力。这一发现表明，随着硬件设备的不断发展和改进，RANSOMSENTRY对系统性能的影响可能会进一步减弱。</p><h3 id="d-案例研究" tabindex="-1"><a class="header-anchor" href="#d-案例研究"><span>D. 案例研究</span></a></h3><p>在下文中，我们将重点介绍一个真实世界的加密勒索软件示例，以说明Android勒索软件是如何攻击用户的。该样本属于simplecker家族，其MD5值为4B5259C20503B34CE4AC31B9B5620F2C。</p><p>为了理解示例如何加密文件，我们使用Jadx[32]将其字节码反编译为Java代码，然后分析与文件访问操作相关的代码。我们发现该示例针对特定文件，例如.jpeg、.jpg、.png、.bmp、.gif、.pdf、.doc、.docx、.txt、.avi、.mkv、.3gp和.mp4。启动后，它会启动一个用于文件加密的线程和一个用于锁定屏幕的服务。示例的线程遍历外部存储中的目录，并将目标文件添加到列表中。然后，它使用硬编码密钥创建Cipher类的实例，并逐一加密所选文件。对于目标文件，该示例使用FileInputStream将文件内容作为字节数组读取，然后使用CipherOutputStream对字节数组进行加密，并将加密数据写入后缀为“.enc”的新文件。之后，原始文件将被删除。与此同时，示例的服务定义了一个ScheduledExecutionrService，它以固定的速率不断弹出包含威胁文本的活动。</p><figure><img src="'+R+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>图8显示了RANSOMSENTRY检测样本前后的屏幕截图。具体来说，如果样本在没有RANSOSTERY的情况下执行，它会伪装成FBI，声称在设备上发现了非法内容并将其锁定（见图8（a））。同时，它要求用户支付300美元来解锁设备并恢复文件（见图8（b））。然后，我们重置设备，并在启用RANSOMSENTRY的情况下再次运行样本。因此，RANSOMSENTRY可以识别其锁屏和加密行为。默认情况下，RANSOMSENTRY的安全策略会立即终止勒索软件进程，同时提醒用户。然而，它还提供了更灵活的安全策略，允许用户决定是否终止该程序。例如，如图8（c）所示，其中一个策略会显示一个警告窗口，提醒用户检测到勒索软件，并提供两个选择：退出或继续。如果用户选择“退出”，则RANSOMSENTRY会抛出运行时异常，终止示例的执行。这种灵活的方法使用户能够根据自己的具体需求做出明智的决定。</p><h2 id="_5-discussion" tabindex="-1"><a class="header-anchor" href="#_5-discussion"><span>5. Discussion</span></a></h2><h2 id="_6-相关工作" tabindex="-1"><a class="header-anchor" href="#_6-相关工作"><span>6. 相关工作</span></a></h2><h2 id="_7-conclusion" tabindex="-1"><a class="header-anchor" href="#_7-conclusion"><span>7. Conclusion</span></a></h2><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h2>',128)]))}const I=n(g,[["render",S],["__file","RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测.html.vue"]]),f=JSON.parse(`{"path":"/posts/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B.html","title":"RansomSentry: Runtime Detection of Android Ransomware With Compiler-Based Instrumentation","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-09-03T00:00:00.000Z","tag":["Obfuscate"],"description":"RansomSentry: Runtime Detection of Android Ransomware With Compiler-Based Instrumentation 论文来自 IEEE Transactions on Dependable and Secure Computing 2025的《RansomSentry: Runtime D...","head":[["meta",{"property":"og:url","content":"https://iXanadu13.github.io/posts/scholar/RansomSentry%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%B9Android%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%B5%8B.html"}],["meta",{"property":"og:site_name","content":"Xanadu13's Blog"}],["meta",{"property":"og:title","content":"RansomSentry: Runtime Detection of Android Ransomware With Compiler-Based Instrumentation"}],["meta",{"property":"og:description","content":"RansomSentry: Runtime Detection of Android Ransomware With Compiler-Based Instrumentation 论文来自 IEEE Transactions on Dependable and Secure Computing 2025的《RansomSentry: Runtime D..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/figure1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-14T07:15:29.000Z"}],["meta",{"property":"article:tag","content":"Obfuscate"}],["meta",{"property":"article:published_time","content":"2025-09-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-14T07:15:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RansomSentry: Runtime Detection of Android Ransomware With Compiler-Based Instrumentation\\",\\"image\\":[\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/figure1.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/table1.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/table2.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/figure2.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/figure3.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/algo1.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/figure4.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/table3.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/table4.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/figure5.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/figure6.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/figure7.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测/figure8.png\\"],\\"datePublished\\":\\"2025-09-03T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-14T07:15:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Xanadu13\\",\\"url\\":\\"https://github.com/iXanadu13\\"}]}"]]},"headers":[{"level":2,"title":"摘要","slug":"摘要","link":"#摘要","children":[]},{"level":2,"title":"1. Introduction","slug":"_1-introduction","link":"#_1-introduction","children":[]},{"level":2,"title":"2. 系统设计","slug":"_2-系统设计","link":"#_2-系统设计","children":[{"level":3,"title":"A. Overview","slug":"a-overview","link":"#a-overview","children":[]},{"level":3,"title":"B. 监控敏感API","slug":"b-监控敏感api","link":"#b-监控敏感api","children":[]},{"level":3,"title":"C. 行为模式建模","slug":"c-行为模式建模","link":"#c-行为模式建模","children":[]},{"level":3,"title":"D. 检测策略","slug":"d-检测策略","link":"#d-检测策略","children":[]}]},{"level":2,"title":"3. 实现","slug":"_3-实现","link":"#_3-实现","children":[{"level":3,"title":"A. 合并Instrumentation库","slug":"a-合并instrumentation库","link":"#a-合并instrumentation库","children":[]},{"level":3,"title":"B. 注入Instrumentation代码","slug":"b-注入instrumentation代码","link":"#b-注入instrumentation代码","children":[]},{"level":3,"title":"C. 拦截敏感API","slug":"c-拦截敏感api","link":"#c-拦截敏感api","children":[]},{"level":3,"title":"D. 勒索软件行为检测","slug":"d-勒索软件行为检测","link":"#d-勒索软件行为检测","children":[]}]},{"level":2,"title":"4. Evaluation","slug":"_4-evaluation","link":"#_4-evaluation","children":[{"level":3,"title":"A. 实验配置","slug":"a-实验配置","link":"#a-实验配置","children":[]},{"level":3,"title":"B. 检测结果","slug":"b-检测结果","link":"#b-检测结果","children":[]},{"level":3,"title":"C. 性能开销","slug":"c-性能开销","link":"#c-性能开销","children":[]},{"level":3,"title":"D. 案例研究","slug":"d-案例研究","link":"#d-案例研究","children":[]}]},{"level":2,"title":"5. Discussion","slug":"_5-discussion","link":"#_5-discussion","children":[]},{"level":2,"title":"6. 相关工作","slug":"_6-相关工作","link":"#_6-相关工作","children":[]},{"level":2,"title":"7. Conclusion","slug":"_7-conclusion","link":"#_7-conclusion","children":[]},{"level":2,"title":"References","slug":"references","link":"#references","children":[]}],"git":{"createdTime":1757834129000,"updatedTime":1757834129000,"contributors":[{"name":"Xanadu13","email":"xanadu13@qq.com","commits":1}]},"readingTime":{"minutes":55.41,"words":16622},"filePathRelative":"posts/scholar/RansomSentry：使用基于编译器的检测工具对Android勒索软件进行运行时检测.md","localizedDate":"2025年9月3日","excerpt":"\\n<p>论文来自 IEEE Transactions on Dependable and Secure Computing 2025的《<a href=\\"https://ieeexplore.ieee.org/document/10840300\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">RansomSentry: Runtime Detection of Android Ransomware With Compiler-Based Instrumentation</a>》。</p>\\n<h2>摘要</h2>\\n<p>近年来，移动勒索软件攻击越来越普遍，尤其是在Android系统中。Android勒索软件通过恶意锁定受感染的设备或加密设备上的用户文件来勒索用户。为了解决这个问题，我们提出了RANSOMSENTRY，这是一个运行时检测系统，具有基于编译器的检测工具，可以在Android中同时检测锁屏和加密勒索软件。</p>","autoDesc":true}`);export{I as comp,f as data};
