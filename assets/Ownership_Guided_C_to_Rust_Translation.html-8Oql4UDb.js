import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as t,o as i}from"./app-BN4KXCQW.js";const e="/assets/images/scholar/Ownership_Guided_C_to_Rust_Translation/figure1.png",p="/assets/images/scholar/Ownership_Guided_C_to_Rust_Translation/figure2.png",l="/assets/images/scholar/Ownership_Guided_C_to_Rust_Translation/figure3.png",m="/assets/images/scholar/Ownership_Guided_C_to_Rust_Translation/table1.png",r="/assets/images/scholar/Ownership_Guided_C_to_Rust_Translation/table2.png",o={};function h(c,s){return i(),n("div",null,s[0]||(s[0]=[t(`<h1 id="ownership-guided-c-to-rust-translation" tabindex="-1"><a class="header-anchor" href="#ownership-guided-c-to-rust-translation"><span>Ownership Guided C to Rust Translation</span></a></h1><p>论文来自 Computer Aided Verification (CAV 2023) 的《<a href="https://link.springer.com/chapter/10.1007/978-3-031-37709-9_22" target="_blank" rel="noopener noreferrer">Ownership Guided C to Rust Translation</a>》。</p><p><a href="https://github.com/KomaEc/crown" target="_blank" rel="noopener noreferrer">Github</a> | <a href="https://zenodo.org/records/7966511" target="_blank" rel="noopener noreferrer">zenodo</a></p><h2 id="摘要" tabindex="-1"><a class="header-anchor" href="#摘要"><span>摘要</span></a></h2><p>Rust 常被称为更安全的 C，它是一门将内存安全与低层次控制相结合的现代编程语言。正是这种有趣的组合，使得 Rust 在开发者中非常流行；同时，也出现了将遗留代码库（通常是 C）迁移到 Rust 的增长趋势。本文提出了一种以静态所有权分析为核心的 C→Rust 翻译方法。我们设计了一套分析来推断 C 指针的所有权模型，并将这些指针自动转换为在 Rust 中的安全等价物。由此产生的工具 <strong>CROWN</strong> 能够扩展到真实世界的代码库（在不到 10 秒内处理 50 万行代码），并且实现了较高的转换率。</p><h2 id="_1-引言-introduction" tabindex="-1"><a class="header-anchor" href="#_1-引言-introduction"><span>1. 引言（Introduction）</span></a></h2><p>Rust [33] 是一门现代编程语言，兼具内存安全与低层级控制这两种令人兴奋的特性。尤其是，Rust 借鉴了所有权类型（ownership types）的思想来限制共享状态的可变性。Rust 编译器能够静态地验证相应的所有权约束，从而保证内存与线程安全。可证明的安全性这一独特优势使得 Rust 成为一种非常流行的语言，而将以 C 为主的遗留代码库迁移到 Rust 的前景也因此极具吸引力。</p><p>为响应这种需求，来自工业界与学术界的自动化 C→Rust 翻译工具相继出现 [17, 26, 31]。其中，工业级转换器 <strong>C2Rust</strong> [26] 将 C 代码改写为 Rust 语法，同时保持原有语义。然而，该翻译并不会综合（synthesise）一个所有权模型，因此最多只能复刻 C 中对指针的 <em>不安全</em> 用法。结果是，生成的 Rust 代码必须用 <code>unsafe</code> 关键字进行标注，允许一些编译器不会检查的操作。近期工作将重点放在减少这种 <code>unsafe</code> 标注上。特别地，工具 <strong>Laertes</strong> [17] 旨在通过搜索由 Rust 编译器给出的类型错误信息所引导的解空间，来改写 C2Rust 产生的（不安全的）代码。该结果令人印象深刻，因为它首次实现在逐行直接转换原始 C 源代码之外，<strong>综合</strong>（synthesise）出“正确”的 Rust 代码。另一方面，这种试错式方法的局限也很明显：系统既不支持对生成过程的推理，也无法对目标代码产生任何新的理解（除了“它能成功编译”这一事实）。</p><p>在本文中，我们提出一种更为系统化的路线：我们开发了一种<strong>新颖的指针所有权分析</strong>，既高效（可扩展至大型程序，在不到 10 秒内处理 50 万行代码），又复杂精细（能够处理嵌套指针与<strong>归纳定义</strong>的数据结构），并且<strong>精确</strong>（对字段与控制流均敏感）。我们的所有权分析在 Rust 的所有权模型上作出了一项<strong>加强性假设</strong>，从而不再需要别名分析。虽然这一假设排除了少量 Rust 的安全用法（见第 5 节的讨论），但它确保了所有权分析同时具备可扩展性与精确性，而这会进一步体现在 C→Rust 翻译整体的可扩展性与精度上。</p><p>该分析的首要目标，当然是<strong>促进</strong> C→Rust 的翻译。正如本文其余部分将展示的，我们建立了一个<strong>自动化翻译系统</strong>，用来将所推导出的所有权模型编码进生成的 Rust 代码中，并由 Rust 编译器证明其安全性。然而，与现有方法常见的“把 Rust 编译器当作求解器”形成对比 [17, 31]，这种分析式方法实际上<strong>从代码中提取了关于所有权的新知识</strong>。这些知识还可能带来更多后续用途，包括防止当前“安全 Rust”中仍允许的内存泄漏、识别先天不安全的代码片段等。</p><p>我们的主要贡献如下：</p><ul><li>设计了一种<strong>可扩展且精确</strong>的所有权分析，能够处理<strong>复杂的归纳定义数据结构与嵌套指针</strong>。（见第 5 节）</li><li>基于所有权分析，提出一种<strong>面向 Rust 的重构技术</strong>以提升代码安全性。虽然本文聚焦其在 C→Rust 翻译中的应用，但该技术也可用于改进任意不安全的 Rust 代码的安全性。（见第 6 节）</li><li>实现了一个原型工具 <strong>CROWN</strong>（意为 <em>C to Rust OWNership guided translation</em>），能够将 C 代码翻译为<strong>安全性增强</strong>的 Rust。（见第 7 节）</li><li>使用一个基准套件对 <strong>CROWN</strong> 进行评估，该套件既包含常用的数据结构库，也包含真实世界项目（规模从 150 行到 50 万行不等），并将结果与当前最先进的方法进行比较。（见第 8 节）</li></ul><h2 id="_2-背景-background" tabindex="-1"><a class="header-anchor" href="#_2-背景-background"><span>2. 背景（Background）</span></a></h2><p>我们首先对 <strong>Rust</strong> 做一个简要介绍，尤其是它的<strong>所有权系统</strong>以及<strong>指针</strong>的使用，因为它们是内存安全的核心。</p><h3 id="_2-1-rust-的所有权模型-rust-ownership-model" tabindex="-1"><a class="header-anchor" href="#_2-1-rust-的所有权模型-rust-ownership-model"><span>2.1 Rust 的所有权模型（Rust Ownership Model）</span></a></h3><p>Rust 中的<strong>所有权</strong>是一组规则，用来约束编译器如何管理内存 [33]。其思想是：将每个值与一个<strong>唯一的拥有者（owner）<strong>关联起来。该特性有助于内存管理。例如，当拥有者离开作用域时，为该值分配的内存可以</strong>自动回收</strong>。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> v</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> u</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;     </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 所有权被转移给 u</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码片段中，把 <code>v</code> 赋值给 <code>u</code> 的同时也<strong>转移了所有权</strong>；此后，除非给 <code>v</code> 重新赋值，否则<strong>不允许</strong>再访问 <code>v</code>。</p><p>这种<strong>永久</strong>的所有权转移虽然提供了强有力的保证，但在编程时也可能显得笨拙。为了允许在程序的不同部分之间共享值，Rust 使用<strong>借用（borrowing）<strong>的概念，即创建一个</strong>引用（reference）</strong>（以<strong>和号</strong>标记）。引用允许在<strong>不取得所有权</strong>的情况下指向某个值。借用会在一段<strong>有限的时间</strong>内授予读取、以及（在某些情况下）<strong>唯一地修改</strong>被引用值的临时权利。</p><p>时间这一维度又引出了所有权管理中的另一个概念——<strong>生命周期（lifetime）</strong>。对<strong>可变引用</strong>（在上面例子中以 <code>mut</code> 标记），<strong>同一时刻只允许一个</strong>；而对<strong>不可变引用</strong>（没有 <code>mut</code> 标记者），在<strong>不存在任何可变引用</strong>的前提下，<strong>可以并存多个</strong>。如你所料，可变/不可变引用与其生命周期的交互是高度非平凡的。本文聚焦于<strong>可变引用</strong>的分析。</p><hr><h3 id="_2-2-rust-中的指针类型-pointer-types-in-rust" tabindex="-1"><a class="header-anchor" href="#_2-2-rust-中的指针类型-pointer-types-in-rust"><span>2.2 Rust 中的指针类型（Pointer Types in Rust）</span></a></h3><p>与 C 相比，Rust 拥有更丰富的<strong>指针体系</strong>。原生的 C 风格指针（写作 <code>*const T</code> 或 <code>*mut T</code>）被称为<strong>原始指针（raw pointers）</strong>，它们<strong>不会参与</strong>编译器的所有权与生命周期检查。原始指针是不安全 Rust（见下一节）的一个主要来源。</p><p>惯用的 Rust 倡导使用 <strong>box 指针</strong>（写作 <code>Box&lt;T&gt;</code>）作为<strong>拥有指针</strong>，它们对堆分配拥有<strong>唯一所有权</strong>；同时使用<strong>引用</strong>（写作 <code>&amp;mut T</code> 或 <code>&amp;T</code>，见上一小节）作为<strong>非拥有指针</strong>，用于访问由他者所拥有的值。Rust 还提供了在<strong>运行期</strong>检查借用规则的<strong>智能指针</strong>（例如 <code>RefCell&lt;T&gt;</code>）。我们的翻译目标是<strong>不增加运行时开销</strong>地维持 CPU 时间，因此我们<strong>不会</strong>把原始指针重构为 <code>RefCell&lt;T&gt;</code>。</p><p>C 风格的<strong>数组指针</strong>在 Rust 中表示为<strong>指向数组的引用</strong>或<strong>切片引用</strong>，它们的数组边界分别在<strong>编译期</strong>与<strong>运行期</strong>已知。诸如“数组边界”这类元数据的创建超出了所有权分析的范围。在本文中，我们在翻译后的代码里<strong>保留数组指针为原始指针</strong>。</p><hr><h3 id="_2-3-不安全的-rust-unsafe-rust" tabindex="-1"><a class="header-anchor" href="#_2-3-不安全的-rust-unsafe-rust"><span>2.3 不安全的 Rust（Unsafe Rust）</span></a></h3><p>出于<strong>务实的设计</strong>，Rust 允许程序包含一些<strong>编译器无法验证为内存安全</strong>的特性：例如<strong>解引用原始指针</strong>、调用<strong>底层函数</strong>等。这类用法必须用关键字 <strong><code>unsafe</code></strong> 标记，形成<strong>不安全 Rust</strong> 的片段。值得注意的是，<code>unsafe</code> <strong>并不会关闭所有编译器检查</strong>；例如<strong>安全指针</strong>仍会被检查。</p><p>不安全 Rust 经常用于实现<strong>具有复杂共享</strong>的数据结构、弥补编译器尚不完备的能力，以及支持<strong>底层系统编程</strong> [2, 18]。当然，它也可以用于其它原因。比如，<strong>c2rust</strong> [26] 会直接把 C 指针翻译成<strong>原始指针</strong>；如果没有不安全 Rust，这些生成的代码将<strong>无法通过编译</strong>。</p><h2 id="_3-综述-overview" tabindex="-1"><a class="header-anchor" href="#_3-综述-overview"><span>3. 综述（Overview）</span></a></h2><p>在本节中，我们通过两个示例对 <strong>CROWN</strong> 进行概述。第一个示例详细描述了单链表的 <code>push</code> 方法，第二个示例展示了一个来自真实基准程序的代码片段。</p><h3 id="_3-1-将元素压入单链表-pushing-into-a-singly-linked-list" tabindex="-1"><a class="header-anchor" href="#_3-1-将元素压入单链表-pushing-into-a-singly-linked-list"><span>3.1 将元素压入单链表（Pushing into a Singly-Linked List）</span></a></h3><figure><img src="`+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>图<strong>1a</strong> 中的 C 函数 <code>push</code> 会分配一个新结点，用于存放作为参数传入的数据。新的结点随后成为 <code>list</code> 的表头。该代码经由 <strong>c2rust</strong> 翻译为图 <strong>1b</strong> 的 Rust 代码。需要注意的是，<strong>c2rust</strong> 的翻译是<strong>基于语法</strong>的：它只是把所有 C 指针改写为 <code>*mut</code> 原始指针。由于解引用原始指针在 Rust 中被视为不安全操作（例如图 <strong>1b</strong> 第 16 行对 <code>new_node</code> 的解引用），<code>push</code> 方法必须用关键字 <code>unsafe</code> 标注（或者把其放入一个 <code>unsafe</code> 代码块中）。此外，<strong>c2rust</strong> 还为两个结构体定义插入了两条属性指令：<code>#[repr(C)]</code> 和 <code>#[derive(Copy, Clone)]</code>。前者保持与 C 相同的数据布局以便互操作，后者指示相应类型只允许通过“复制”来进行拷贝。</p><p>尽管 <strong>c2rust</strong> 在翻译中使用了原始指针，图 <strong>1b</strong> 的<strong>所有权</strong>方案仍然遵循 Rust 的所有权模型，这意味着这些原始指针是可以被转换为安全指针的。对新分配结点的指针在第 15 行被赋给 <code>new_node</code>，这使我们能够推断：<strong>新结点的所有权最初属于 <code>new_node</code></strong>。随后在第 18 行，所有权从 <code>new_node</code> 转移到 <code>(*list).head</code>。另外，如果在第 17 行之前 <code>(*list).head</code> 已经拥有某个内存对象，那么在第 17 行该所有权又会转移到 <code>(*new_node).next</code>。这种所有权方案对应了安全指针的用法：（i）每个内存对象只与<strong>唯一所有者</strong>关联；（ii）当所有者离开作用域时，该对象会被销毁。关于（i）的一个例子是：当新分配内存的所有权在第 18 行从 <code>new_node</code> 转移到 <code>(*list).head</code> 后，<code>(*list).head</code> 成为唯一所有者，而 <code>new_node</code> 失效且不再被使用。关于（ii），由于 <code>push</code> 的参数 <code>list</code> 是一个<strong>输出参数</strong>（即可以在函数外部观察到），我们假设它在函数返回时必须继续拥有其引用到的对象。因此，在 <code>push</code> 方法中<strong>不会丢弃任何内存对象</strong>，而是将它们“归还”给调用者。</p><p><strong>CROWN</strong> 会推断由 <strong>c2rust</strong> 翻译出的代码的所有权信息，并用这些信息把图 <strong>1b</strong> 的代码进一步翻译为图 <strong>1c</strong> 中更安全的 Rust。具体而言，<strong>CROWN</strong> 首先基于所有权信息把原始指针<strong>重新类型化（retype）<strong>为安全指针，然后</strong>重写它们的使用方式</strong>。</p><h4 id="在-crown-中重新类型化指针-retyping-pointers-in-crown" tabindex="-1"><a class="header-anchor" href="#在-crown-中重新类型化指针-retyping-pointers-in-crown"><span>在 CROWN 中重新类型化指针（Retyping Pointers in Crown）</span></a></h4><p>如果某个指针在其作用域<strong>的任意时刻</strong>拥有某个内存对象，<strong>CROWN</strong> 就把它重新类型化为 <code>Box</code> 指针。例如，在图 <strong>1c</strong> 中，局部变量 <code>new_node</code> 被重新类型化为 <code>Option&lt;Box&lt;Node&gt;&gt;</code>（安全指针类型被包一层 <code>Option</code> 以处理空指针的情况）。变量 <code>new_node</code> 在进入函数时是非拥有的，在第 13 行变为拥有者，并在第 16 行把所有权再次转移出去。</p><p>对于结构体字段，<strong>CROWN</strong> 会检查<strong>该结构体声明作用域内的所有代码</strong>。如果一个结构体字段在其结构体声明的作用域内<strong>的任意时刻</strong>拥有某个内存对象，那么它会被重新类型化为 <code>Box</code>。在图 <strong>1b</strong> 中，字段 <code>next</code> 与 <code>head</code> 分别在第 17 行与第 18 行被赋予所有权；因此它们在图 <strong>1c</strong> 中分别于第 4 行和第 9 行被重新类型化为 <code>Box</code>。</p><p>一个特殊情况是<strong>输出参数</strong>（例如本例中的 <code>list</code>）。此类参数虽然可能是拥有者，但 <strong>CROWN</strong> 会把它们重新类型化为 <code>&amp;mut</code>，以便后续能进行<strong>借用（borrowing）</strong>。在 <code>push</code> 中，输入参数 <code>list</code> 被重新类型化为 <code>Option&lt;&amp;mut List&gt;</code>。</p><h4 id="在-crown-中重写指针使用-rewriting-pointer-uses-in-crown" tabindex="-1"><a class="header-anchor" href="#在-crown-中重写指针使用-rewriting-pointer-uses-in-crown"><span>在 CROWN 中重写指针使用（Rewriting Pointer Uses in Crown）</span></a></h4><p>在重新类型化之后，<strong>CROWN</strong> 会按新的类型与使用环境重写指针用法。由于 Rust 语义的限制，这些重写规则略显繁琐（参见第 6 节）。例如，第 14 行对 <code>new_node</code> 的解引用会被重写为 <code>(*new_node).as_deref_mut().unwrap()</code>，因为它需要可变借用，并且 <code>Box</code> 的可选包装需要先被解包。同样，第 15 行的 <code>(*list).head</code> 会被重写为 <code>((*list.as_deref_mut()).unwrap()).head.take()</code> 作为赋值左值（LHS），因为目标位置期望的是一个 <code>Box</code> 指针。</p><p>在 <strong>CROWN</strong> 的重写之后，先前用于包裹代码的 <code>unsafe</code> 代码块注解已不再必要。然而，<strong>CROWN</strong> 并不会主动移除这些注解。需要特别指出的是：<strong>即便在 <code>unsafe</code> 代码块内，安全指针仍会被 Rust 编译器检查</strong>。</p><h3 id="_3-2-在-bzip2-中释放参数列表" tabindex="-1"><a class="header-anchor" href="#_3-2-在-bzip2-中释放参数列表"><span>3.2 在 bzip2 中释放参数列表</span></a></h3><figure><img src="'+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>下面我们展示一个带有循环结构的真实世界代码片段的转换：来自 <strong>bzip2</strong> 的一段用于释放参数列表的代码。<strong>bzip2</strong> 定义了一种类似单向链表的结构 <strong>Cell</strong>，它保存一组参数名。在图 2 中，我们从源代码中抽取了一个释放参数列表的片段。这里，局部变量 <strong>argList</strong> 已经是一个构造好的参数列表，而 <strong>Char</strong> 是到 C 风格字符的类型别名。需要注意的是，图 2b 和 2c 中的 <strong>Cell</strong> 并不指 Rust 的 <code>std::cell::Cell</code>。</p><p><strong>CROWN</strong> 能够准确地为该片段推断出所有权方案。首先，<strong>argList</strong> 的所有权被转移给 <strong>aa</strong>，随后在循环中被释放。在循环体内部，从 <strong>aa</strong> 访问到的 <strong>link</strong> 的所有权首先被转移给 <strong>aa2</strong>，接着从 <strong>aa</strong> 访问到的 <strong>name</strong> 的所有权在调用 <code>free</code> 时被释放。条件语句之后，<strong>aa</strong> 的所有权也会被释放。最后，<strong>aa</strong> 从 <strong>aa2</strong> 那里重新获得所有权。</p><p><strong>处理循环。</strong> 对于循环，<strong>CROWN</strong> 只对其循环体分析一次，因为这一步已经能暴露出全部的所有权信息。对于像 <strong>Cell</strong> 这样的归纳定义数据结构，进一步展开循环体虽然可以更深入地探索数据结构，但不会暴露任何新的结构体字段：指针变量与结构体指针字段在循环迭代之间并不会改变所有权。另外，<strong>CROWN</strong> 还会在循环入口与出口处发出约束，将所有局部指针的所有权状态配平。例如，<strong>aa</strong> 和 <strong>aa2</strong> 在循环入口处的所有权状态将分别等同于循环出口处被推断出的“拥有（owning）”与“非拥有（non-owning）”。</p><p><strong>处理空指针。</strong> 在 C 中，一个常见习惯是在 <code>malloc</code> 之后或 <code>free</code> 之前与空指针比较，例如：<code>if (!p.is_null()) free(p);</code>。这会带来问题，因为 then 分支与 else 分支会为 <strong>p</strong> 产生彼此冲突的所有权状态。我们采用与 [24] 类似的做法：在空分支中插入一个显式的空赋值，即 <code>if !p.is_null() free(p); else p = ptr::null_mut();</code>。由于我们将空指针同时视为“拥有”与“非拥有”，<strong>p</strong> 的所有权将由非空分支决定，从而使 <strong>CROWN</strong> 能够推断出正确的所有权方案。</p><p><strong>翻译。</strong> 基于上述所有权方案，<strong>CROWN</strong> 按图 2c 的方式进行改写。需要注意的是，我们并不尝试改写 <strong>name</strong>，因为它是一个数组指针（其限制见第 7 节）。</p><h2 id="_4-架构-architecture" tabindex="-1"><a class="header-anchor" href="#_4-架构-architecture"><span>4. 架构（Architecture）</span></a></h2><p>在本节中，我们简要概述 <strong>CROWN</strong> 的架构。CROWN 接收一个包含 <code>unsafe</code> 代码块的 Rust 程序作为输入，并输出一个更安全的 Rust 程序：其中一部分原始指针被<strong>重赋型</strong>（retype）为安全指针（符合 Rust 的所有权模型），并相应地修改它们的使用方式。本文聚焦于将该技术应用到由 <strong>c2rust</strong> 自动把 C 程序翻译成 Rust 的情形：这些程序与原始 C 程序保持高度相似，只是把 C 语法替换成了 Rust 语法。</p><p><strong>CROWN</strong> 在 Rust 的 MIR 上进行若干静态分析，以推断指针的属性：</p><ul><li><strong>所有权分析（Ownership analysis）</strong>：计算代码中指针的所有权信息，即对每个指针在特定程序位置推断它是否为“拥有/非拥有”。</li><li><strong>可变性分析（Mutability analysis）</strong>：推断哪些指针被用于修改它们所指向的对象（受文献 [22,25] 启发）。</li><li><strong>胖瘦分析（Fatness analysis）</strong>：区分数组指针与非数组指针（受文献 [32] 启发）。</li></ul><p>这些分析结果被汇总为<strong>类型限定符（type qualifiers）</strong> [21]。类型限定符是“原子属性”（例如：所有权、可变性与胖瘦）来<strong>修饰</strong>标准指针类型。随后，我们利用这些限定符进行<strong>指针重赋型</strong>。例如，一个“拥有的、非数组”的指针会被重赋型为 <code>Box</code>。指针被重赋型后，<strong>CROWN</strong> 会相应重写它们的用法。</p><h2 id="_5-所有权分析-ownership-analysis" tabindex="-1"><a class="header-anchor" href="#_5-所有权分析-ownership-analysis"><span>5. 所有权分析（Ownership Analysis）</span></a></h2><p>我们的所有权分析目标是：为给定程序计算一个<strong>所有权方案（ownership scheme）</strong>，且该方案服从 Rust 的所有权模型（若此类方案存在）。该方案包含关于程序中指针在特定程序位置是否“拥有或非拥有”的信息。高层来看，我们的分析通过生成一组<strong>所有权约束</strong>（见第 5.2 节），并用 <strong>SAT</strong> 求解器（见第 5.3 节）来求解。对这些约束的一个满足赋值就是一个服从 Rust 语义的所有权方案。</p><p>我们的所有权分析对<strong>控制流</strong>与<strong>字段</strong>均敏感；字段敏感使得我们能够为结构体字段上的指针推断所有权信息。为达到字段敏感性，我们对<strong>访问路径（access paths）<strong>跟踪所有权信息 [10,14,29]。一个访问路径以“如何从初始的基变量被访问”来表示一个内存位置，它由</strong>基变量</strong>和一串<strong>字段选择操作</strong>组成。以图 1b 的程序为例，访问路径的示例包括：<code>new_node</code>（仅包含基变量）、<code>(*new_node).next</code>、以及 <code>(*list).head</code>。</p><p>我们的分析为每个访问路径都关联一个<strong>所有权变量</strong>；例如，<code>p</code> 关联所有权变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">O_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，而 <code>(*p).next</code> 关联所有权变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mrow><mo stretchy="false">(</mo><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">O_{(*p).next}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">∗</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span></span></span></span>。每个所有权变量可取值 <strong>1</strong>（该访问路径为拥有）或 <strong>0</strong>（为非拥有）。当我们说“某访问路径的所有权”时，我们指的是沿该访问路径最后访问到的 <strong>字段（或更一般地，指针）</strong> 的所有权；例如，“<code>(*new_node).next</code> 的所有权”即字段 <code>next</code> 的所有权。</p><h3 id="_5-1-所有权与别名-ownership-and-aliasing" tabindex="-1"><a class="header-anchor" href="#_5-1-所有权与别名-ownership-and-aliasing"><span>5.1 所有权与别名（Ownership and Aliasing）</span></a></h3><p>设计所有权分析的一个主要挑战是<strong>所有权</strong>与<strong>别名（aliasing）<strong>之间的相互作用。为理解问题，考虑下列代码清单中第 3 行的指针赋值。我们假设在该赋值之前的若干行允许推断：<code>q</code>、<code>(*q).next</code> 与 <code>r</code> 是</strong>拥有</strong>的，而 <code>p</code> 与 <code>(*p).next</code> 是<strong>非拥有</strong>的。另假设赋值之后的若干行<strong>要求</strong> <code>(*p).next</code> 必须为拥有（例如稍后会显式释放 <code>(*p).next</code>）。据此，一个所有权分析可能<strong>合理地</strong>得出结论：<strong>所有权转移</strong>发生在第 3 行（因此 <code>(*p).next</code> 变为拥有），并且由此得到的所有权方案服从 Rust 语义。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">r</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">q</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : *</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// p 和 (*p).next 为非拥有；q、(*q).next 与 r 为拥有</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).next </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> r</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 之后 (*p).next 必须具有所有权</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在考虑<strong>别名</strong>。一种可能的假设是：在第 3 行之前，<code>p</code> 与 <code>q</code> 互为别名，这意味着 <code>(*p).next</code> 与 <code>(*q).next</code> 也互为别名。于是，在第 3 行之后，<code>(*p).next</code> 与 <code>(*q).next</code> 仍然别名（指向同一内存对象）。然而，根据上面的所有权方案，二者<strong>都是拥有的</strong>；这在 Rust 中是不允许的，因为一个内存对象必须有<strong>唯一拥有者</strong>。上述（简化的）所有权分析未能检测到该不一致，问题在于它<strong>忽略了别名</strong>。确实，若存在某个<strong>拥有的别名</strong>在所有权转移之后仍继续指向与 <code>(*p).next</code> 相同的对象，那么所有权就<strong>不应</strong>被转移给 <code>(*p).next</code>。</p><p>要精确获得别名信息非常困难，尤其是在存在<strong>递归定义的数据结构</strong>时。本文通过在 Rust 所有权模型下提出一个<strong>强化假设</strong>来减轻对别名检查的需求：我们<strong>限制</strong>指针在某条访问路径上获得所有权的方式，从而限制所有权与别名的相互作用。具体而言，我们引入一个新概念：<strong>所有权单调性（ownership monotonicity）</strong>。该性质指出：沿着一条访问路径，指针的所有权值只能<strong>不增加</strong>（只能下降）。</p><blockquote><p>笔者注：文章不尝试完整分析别名关系</p></blockquote><p>形式化地（见定义 1），令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">x</mi></mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathrm{is\\_prefix}(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathrm">is_prefix</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> 在访问路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 的前缀时返回 <code>true</code>，否则返回 <code>false</code>——例如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">x</mi></mrow><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mtext>  </mtext><mo stretchy="false">(</mo><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>true</mtext></mrow><annotation encoding="application/x-tex">\\mathrm{is\\_prefix}(p,\\;(*p).next)=\\text{true}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathrm">is_prefix</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord text"><span class="mord">true</span></span></span></span></span>。</p><p>回到前述代码清单，所有权单调性蕴含：对访问路径 <code>(*p).next</code> 有</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>O</mi><mi>p</mi></msub><mtext>  </mtext><mo>≥</mo><mtext>  </mtext><msub><mi>O</mi><mrow><mo stretchy="false">(</mo><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex"> O_{p} \\;\\ge\\; O_{(*p).next}, </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">∗</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span></span></p><p>而对访问路径 <code>(*q).next</code> 有</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>O</mi><mi>q</mi></msub><mtext>  </mtext><mo>≥</mo><mtext>  </mtext><msub><mi>O</mi><mrow><mo stretchy="false">(</mo><mo>∗</mo><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex"> O_{q} \\;\\ge\\; O_{(*q).next}. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="mclose mtight">)</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></p><p>这意味着：如果允许 <code>(*p).next</code> 取得所有权，则 <code>p</code> <strong>必须已经是拥有的</strong>。从而，<code>p</code> 的所有别名都必须是<strong>非拥有的</strong>；这又意味着 <code>(*p).next</code> 的所有别名——包括 <code>(*q).next</code> 在内——都是<strong>非拥有的</strong>。</p><h4 id="定义-1-所有权单调性-ownership-monotonicity" tabindex="-1"><a class="header-anchor" href="#定义-1-所有权单调性-ownership-monotonicity"><span>定义 1（所有权单调性，Ownership monotonicity）</span></a></h4><p><strong>给定两条访问路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>，若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">is_prefix</mtext><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\textit{is\\_prefix}(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord textit">is_prefix</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>，则有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">O</mi><mi>a</mi></msub><mo>≥</mo><msub><mi mathvariant="double-struck">O</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">\\mathbb{O}_a \\ge \\mathbb{O}_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</strong></p><p>所有权单调性比 Rust 语义更为严格，这会使得我们的分析能够拒绝一些虽然会被 Rust 编译器接受、但我们不希望在翻译中接受的情形（见§5.4 的讨论）。在本文工作中，我们刻意选择用<strong>所有权单调性</strong>而非<strong>别名分析</strong>作为基础，因为这能让我们对翻译精度拥有更强的可控性。相反地，若采用别名分析，翻译精度就会直接受该分析准确率的支配（例如别名分析的误报，参见 [23, 40]），这可能导致 <strong>CROWN</strong> 放弃翻译那些其实是安全的指针。有了所有权单调性，我们能确切地知道哪些有效的所有权方案被排除了，并且我们可以显式地启用它们（同样见§5.4 的讨论）。</p><hr><h3 id="_5-2-生成所有权约束-generation-of-ownership-constraints" tabindex="-1"><a class="header-anchor" href="#_5-2-生成所有权约束-generation-of-ownership-constraints"><span>5.2 生成所有权约束（Generation of Ownership Constraints）</span></a></h3><p>在生成约束时，我们假设给定一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，它表示程序中<strong>最长访问路径</strong>的长度。这样可以覆盖代码里所有被暴露出来的访问路径的所有权信息。稍后我们会讨论<strong>循环</strong>的处理，因为循环可能暴露更长的访问路径。</p><p>令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi></mrow><annotation encoding="application/x-tex">\\mathcal{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span></span></span> 表示程序中<strong>所有访问路径</strong>的集合；记 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">base_var</mtext><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\textit{base\\_var}(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord textit">base_var</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> 返回访问路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 的<strong>基变量</strong>，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|a|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">a</span><span class="mord">∣</span></span></span></span> 表示从基变量出发、沿字段选择算子前进的<strong>步数</strong>。以上一节代码为语境，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">base_var</mtext><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\\textit{base\\_var}((*p).next)=p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord textit">base_var</span></span><span class="mopen">((</span><span class="mord">∗</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">base_var</mtext><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\\textit{base\\_var}(p)=p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord textit">base_var</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>，因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|p|=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">p</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">|(*p).next|=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>。接着，定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">ap</mtext><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>l</mi><mi>b</mi><mo separator="true">,</mo><mi>u</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\textit{ap}(v, lb, ub)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> 返回以变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 为基变量、其路径长度位于下界 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">lb</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">b</span></span></span></span> 与上界 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">ub</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span></span></span></span> 之间的所有访问路径集合：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext mathvariant="italic">ap</mtext><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>l</mi><mi>b</mi><mo separator="true">,</mo><mi>u</mi><mi>b</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mo stretchy="false">{</mo><mtext> </mtext><mi>a</mi><mo>∈</mo><mi mathvariant="script">P</mi><mo>∣</mo><mtext mathvariant="italic">base_var</mtext><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>v</mi><mo>∧</mo><mi>l</mi><mi>b</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mi>u</mi><mi>b</mi><mtext> </mtext><mo stretchy="false">}</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex"> \\textit{ap}(v, lb, ub) \\;=\\; \\{\\, a \\in \\mathcal{P} \\mid \\textit{base\\_var}(a)=v \\land lb \\le |a| \\le ub \\,\\}. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord textit">base_var</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">}</span><span class="mord">.</span></span></span></span></span></p><p>例如，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>=</mo><mi>p</mi><mo separator="true">,</mo><mtext>  </mtext><mi>l</mi><mi>b</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mtext>  </mtext><mi>u</mi><mi>b</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">v=p,\\; lb=1,\\; ub=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 时，</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext mathvariant="italic">ap</mtext><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mo stretchy="false">{</mo><mtext> </mtext><mi>p</mi><mo separator="true">,</mo><mtext>  </mtext><mo stretchy="false">(</mo><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mtext> </mtext><mo stretchy="false">}</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex"> \\textit{ap}(p,1,2) \\;=\\; \\{\\, p,\\; (*p).next \\,\\}. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">ap</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">}</span><span class="mord">.</span></span></span></span></span></p><hr><h4 id="所有权转移-ownership-transfer" tabindex="-1"><a class="header-anchor" href="#所有权转移-ownership-transfer"><span>所有权转移（Ownership Transfer）</span></a></h4><p>程序中可发生所有权转移的语句包括 <strong>（指针）赋值</strong>与<strong>函数调用</strong>。本节讨论赋值；由于篇幅限制，跨过程的所有权分析规则见扩展版本[41]。我们在赋值处的所有权转移规则遵循 Rust 的 <strong><code>Box</code> 语义</strong>：当一个 <code>Box</code> 指针发生<strong>移动</strong>时，它所指向的对象所有权也随之移动。如下伪 Rust 代码所示：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">q</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Box</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Box</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;&gt;;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> q</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 发生所有权转移</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 之后禁止使用 q 以及 *q</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当所有权从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 转移到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">*q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597em;vertical-align:-0.1944em;"></span><span class="mord">∗</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 也失去所有权。除重新赋值外，失去所有权后的 <code>Box</code> 指针不允许再被使用，因此上面第 3 行的对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">*q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597em;vertical-align:-0.1944em;"></span><span class="mord">∗</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 的使用都是禁止的。</p><p>据此，我们强制如下<strong>所有权转移规则</strong>：若对某个<strong>指针变量</strong>（如例子中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>）发生所有权转移，则对<strong>从该指针可达的所有访问路径</strong>（如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">*p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597em;vertical-align:-0.1944em;"></span><span class="mord">∗</span><span class="mord mathnormal">p</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">*q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597em;vertical-align:-0.1944em;"></span><span class="mord">∗</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>）也必须发生所有权转移。而从当前正在讨论的指针可达的<strong>其他</strong>指针变量的所有权保持不变（例如若代码中出现赋值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo><mi>p</mi><mo>=</mo><mo>∗</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">*p = *q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597em;vertical-align:-0.1944em;"></span><span class="mord">∗</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6597em;vertical-align:-0.1944em;"></span><span class="mord">∗</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 导致发生所有权转移，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 自身仍保留其先前的所有权状态）。</p><hr><h4 id="指针赋值处的可能所有权转移-possible-ownership-transfer-at-pointer-assignment" tabindex="-1"><a class="header-anchor" href="#指针赋值处的可能所有权转移-possible-ownership-transfer-at-pointer-assignment"><span>指针赋值处的可能所有权转移（Possible Ownership Transfer at Pointer Assignment）</span></a></h4><figure><img src="`+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在赋值点的所有权转移由图3 中的规则 <strong>ASSIGN</strong> 给出。记<strong>判定式</strong></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mtext>  </mtext><mo>⊢</mo><mtext>  </mtext><mi>p</mi><mo>=</mo><mi>q</mi><mtext>  </mtext><mo separator="true">;</mo><mtext>  </mtext><mo>⇒</mo><mtext>  </mtext><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex"> C \\;\\vdash\\; p = q \\; ; \\;\\Rightarrow\\; C&#39; </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>表示：在约束集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 的前提下分析赋值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p=q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，并生成新的约束集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>。我们使用<strong>撇号</strong>表示赋值后的变量状态。</p><p>给定指针赋值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p=q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>。令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 分别表示<strong>从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 出发</strong>的所有访问路径集合；令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> 分别表示<strong>从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 的基变量</strong>出发、能抵达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 的访问路径集合。于是，等式</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="double-struck">O</mi><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo>+</mo><msub><mi mathvariant="double-struck">O</mi><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo>=</mo><msub><mi mathvariant="double-struck">O</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex"> \\mathbb{O}_{a&#39;} + \\mathbb{O}_{b&#39;} = \\mathbb{O}_b </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>表达了：对起源于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 的所有访问路径，<strong>存在发生转移的可能</strong>。更具体地：</p><ol><li><strong>若发生转移</strong>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 的所有权转移到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">a&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">O</mi><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo>=</mo><msub><mi mathvariant="double-struck">O</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">\\mathbb{O}_{a&#39;}=\\mathbb{O}_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">O</mi><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\\mathbb{O}_{b&#39;}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>）；</li><li><strong>否则不发生转移</strong>，所有权保持不变（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">O</mi><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo>=</mo><msub><mi mathvariant="double-struck">O</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">\\mathbb{O}_{a&#39;}=\\mathbb{O}_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">O</mi><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo>=</mo><msub><mi mathvariant="double-struck">O</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">\\mathbb{O}_{b&#39;}=\\mathbb{O}_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）。</li></ol><p>最后两个等式</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="double-struck">O</mi><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo>=</mo><msub><mi mathvariant="double-struck">O</mi><mi>c</mi></msub><mtext>  </mtext><mo>∧</mo><mtext>  </mtext><msub><mi mathvariant="double-struck">O</mi><msup><mi>d</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo>=</mo><msub><mi mathvariant="double-struck">O</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex"> \\mathbb{O}_{c&#39;}=\\mathbb{O}_c \\;\\land\\; \\mathbb{O}_{d&#39;}=\\mathbb{O}_d </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>表示：无论（1）还是（2），集合中的访问路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> 都<strong>保留其原有所有权</strong>。注意，“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span></span></span></span>” 按照自然数集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> 上的通常算术加法解释，但我们对每个所有权变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">O</mi></mrow><annotation encoding="application/x-tex">\\mathbb{O}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord mathbb">O</span></span></span></span> 隐式施加约束</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>0</mn><mtext>  </mtext><mo>≤</mo><mtext>  </mtext><mi mathvariant="double-struck">O</mi><mtext>  </mtext><mo>≤</mo><mtext>  </mtext><mn>1.</mn></mrow><annotation encoding="application/x-tex"> 0 \\;\\le\\; \\mathbb{O} \\;\\le\\; 1. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord mathbb">O</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.</span></span></span></span></span></p><hr><h4 id="c-语言中的内存泄漏-c-memory-leaks" tabindex="-1"><a class="header-anchor" href="#c-语言中的内存泄漏-c-memory-leaks"><span>C 语言中的内存泄漏（C Memory Leaks）</span></a></h4><p>在 <strong>ASSIGN</strong> 规则中，我们向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">C&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 额外加入约束 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">O</mi><mi>a</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\\mathbb{O}_a = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord"><span class="mord mathbb">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，用于<strong>强制 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 在赋值之前为“非拥有”</strong>。反之，若在赋值前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 已经拥有所有权，而赋值又让其被重新指向，这就暗示着<strong>原始 C 程序中存在一次内存泄漏</strong>。由于在 Rust 中，内存会被自动回收，若允许该翻译继续，将会通过修复泄漏而改变原程序的语义。因此，我们的设计选择是：<strong>不允许</strong>所有权分析产生这种改变语义的解。正如§8 将进一步解释的，我们希望翻译过程<strong>保留原先的内存使用行为</strong>（包括可能存在的内存泄漏）。</p><h4 id="访问路径上的-同时转移-simultaneous-ownership-transfer-along-an-access-path" tabindex="-1"><a class="header-anchor" href="#访问路径上的-同时转移-simultaneous-ownership-transfer-along-an-access-path"><span>访问路径上的“同时转移”（Simultaneous Ownership Transfer Along an Access Path）</span></a></h4><p>可以注意到，仅靠 <strong>ASSIGN</strong> 生成的约束并<strong>不能</strong>完整刻画上节定义的所有权转移规则：它并未显式保证“只要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>→</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \\to q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 发生转移，则对所有访问路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 上的所有对应指针也同时发生转移”。这一点<strong>由所有权单调性</strong>隐式保证，如定理 1 所述。</p><p><strong>定理 1（所有权转移，Ownership transfer）.</strong><br> 若所有权自 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 转移到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，则依据 <strong>ASSIGN</strong> 规则与<strong>所有权单调性</strong>，所有权也会在访问路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 上的对应指针间转移：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>O</mi><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo>=</mo><msub><mi>O</mi><mi>b</mi></msub><mo separator="true">,</mo><mspace width="2em"></mspace><msub><mi>O</mi><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo>=</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex"> O_{a&#39;} = O_b,\\qquad O_{b&#39;} = 0. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:2em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.</span></span></span></span></span></p><p>（证明见扩展版 [41]）</p><p><strong>所有权与别名：</strong> §5.1 指出，别名可能导致“同一内存对象在转移后有多个所有者”的情况。定理 2 说明在<strong>所有权单调性</strong>下这不会发生。</p><p><strong>定理 2（在所有权单调性下指针赋值的健全性，Soundness）.</strong><br> 在所有权单调性下，若所有已分配的内存对象在赋值<strong>之前</strong>都有<strong>唯一所有者</strong>，则在该赋值<strong>之后</strong>也各自仍有<strong>唯一所有者</strong>。<br> （证明见扩展版 [41]）</p><p>直观地，定理 2 的作用是：指针在获取所有权时<strong>无需显式考虑别名</strong>；发生转移后，这个指针将成为该对象的<strong>唯一所有者</strong>。这一思想与<strong>强更新（strong update）</strong>[30] 相呼应。</p><hr><h4 id="额外的访问路径-additional-access-paths" tabindex="-1"><a class="header-anchor" href="#额外的访问路径-additional-access-paths"><span>额外的访问路径（Additional Access Paths）</span></a></h4><p>需要提醒的是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p,q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 也可能能被<strong>程序中的其它基变量</strong>访问。对这些<strong>未在赋值处显式出现</strong>的访问路径，我们不会为其生成新的所有权变量；因此它们当前的所有权变量按默认<strong>保持不变</strong>。</p><hr><h4 id="所有权转移示例-ownership-transfer-example" tabindex="-1"><a class="header-anchor" href="#所有权转移示例-ownership-transfer-example"><span>所有权转移示例（Ownership Transfer Example）</span></a></h4><p>以下用<strong>单链表</strong>示例说明 <strong>ASSIGN</strong> 规则。设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p,q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 类型均为 <code>*mut Node</code>，需要考虑的四条访问路径为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo separator="true">,</mo><mtext> </mtext><mi>q</mi><mo separator="true">,</mo><mtext> </mtext><mo stretchy="false">(</mo><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mtext mathvariant="italic">next</mtext><mo separator="true">,</mo><mtext> </mtext><mo stretchy="false">(</mo><mo>∗</mo><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mtext mathvariant="italic">next</mtext></mrow><annotation encoding="application/x-tex">p,\\ q,\\ (*p).\\textit{next},\\ (*q).\\textit{next}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord">.</span><span class="mord text"><span class="mord textit">next</span></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mord">.</span><span class="mord text"><span class="mord textit">next</span></span></span></span></span>。采用 SSA 形式时，我们在每行都会为当行出现的访问路径生成新的所有权变量（通过为其下标加 1）。第一次赋值时，可以在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p,q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 间发生转移；第二次赋值时，可以在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mtext mathvariant="italic">next</mtext></mrow><annotation encoding="application/x-tex">(*p).\\textit{next}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord">.</span><span class="mord text"><span class="mord textit">next</span></span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>∗</mo><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mtext mathvariant="italic">next</mtext></mrow><annotation encoding="application/x-tex">(*q).\\textit{next}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mord">.</span><span class="mord text"><span class="mord textit">next</span></span></span></span></span> 间发生转移；而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p,q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 必须保持原有所有权。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>p = q;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>$O_{p1} = 0 ∧ O_{p2} + O_{q2} = O_{q1} ∧ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>O_{(*p1).next} = 0 ∧ O_{(*p2).next} + O_{(*q2).next} = O_{(*q1).next} $</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>(*p).next = (*q).next;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>$O_{p3} = O_{p2} ∧ O_{q3} = O_{q2} ∧ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>O_{(*p2).next} = 0 ∧ O_{(*p3).next} + O_{(*q3).next} = O_{(*q2).next} $</p><hr><h4 id="条件与循环的处理-handling-conditionals-and-loops" tabindex="-1"><a class="header-anchor" href="#条件与循环的处理-handling-conditionals-and-loops"><span>条件与循环的处理（Handling Conditionals and Loops）</span></a></h4><p>如§3.2 所述，我们<strong>只分析一次</strong>循环体，因为这足以暴露所有所需的所有权变量。对<strong>归纳定义的数据结构</strong>而言，进一步展开循环体虽会延长访问路径，但不会暴露新的结构体字段（结构体字段在循环迭代间并不会改变所有权）。</p><p>为处理控制流的<strong>汇合点（join points）</strong>，我们采用 SSA 构造算法的一个变体 [6]：不同路径在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> 结点处汇合。<strong>所有被合并的路径上</strong>的每个所有权变量的取值<strong>必须一致</strong>，否则分析失败。</p><h3 id="_5-3-解决所有权约束-solving-ownership-constraints" tabindex="-1"><a class="header-anchor" href="#_5-3-解决所有权约束-solving-ownership-constraints"><span>5.3 解决所有权约束（Solving Ownership Constraints）</span></a></h3><p>所有权约束系统由一组三变量线性约束与一元等式约束组成：三变量线性约束的形式为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mi>v</mi></msub><mo>=</mo><msub><mi>O</mi><mi>w</mi></msub><mo>+</mo><msub><mi>O</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">O_v = O_w + O_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，一元等式约束的形式为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mi>v</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">O_v = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mi>v</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">O_v = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><p><strong>定义 2（所有权约束系统）</strong><br> 一个所有权约束系统 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">¬</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(P, \\Delta, \\Sigma, \\Sigma_{\\lnot})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">Δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">¬</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 由以下部分构成：一组取值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的所有权变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>；一组三变量等式约束 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mo>⊆</mo><mi>P</mi><mo>×</mo><mi>P</mi><mo>×</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">\\Delta \\subseteq P \\times P \\times P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>；以及两组一元等式约束 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">¬</mi></msub><mo>⊆</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">\\Sigma, \\Sigma_{\\lnot} \\subseteq P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">¬</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>。其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span> 中的等式为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的形式，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">¬</mi></msub></mrow><annotation encoding="application/x-tex">\\Sigma_{\\lnot}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">¬</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中的等式为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的形式。</p><p><strong>定理 3（所有权约束求解的复杂性）</strong><br> 判定定义 2 中所有权约束系统的可满足性是 NP 完全的。（证明见扩展版本 [41]）</p><p>我们通过调用 SAT 求解器来求解所有权约束。所有权约束可能<strong>无解</strong>：这发生在不存在同时满足 Rust 所有权模型与“所有权单调性”性质（在某些情形下它比 Rust 模型更严格）的所有权方案，或原始 C 程序本身存在内存泄漏的情况下。若约束存在多个解，我们取 SAT 求解器返回的<strong>第一个</strong>赋值。</p><blockquote><p>笔者注：NP完全只是一种最坏情况的复杂度结论，并不等于“不可解”，使用SAT只求一个解还是比较容易的。</p></blockquote><p>鉴于 Rust 语义较为复杂，我们并未形式化证明任意可满足赋值都遵循 Rust 的所有权模型。相反，我们在翻译之后通过运行 Rust 编译器来进行该检查。</p><hr><h3 id="_5-4-关于-所有权单调性-的讨论-discussion-on-ownership-monotonicity" tabindex="-1"><a class="header-anchor" href="#_5-4-关于-所有权单调性-的讨论-discussion-on-ownership-monotonicity"><span>5.4 关于“所有权单调性”的讨论（Discussion on Ownership Monotonicity）</span></a></h3><p>如第 5 节先前所述，“所有权单调性”比 Rust 语义更为严格，这可能导致我们的分析<strong>拒绝</strong>一些本会被 Rust 编译器接受的所有权方案。我们识别出两个这样的场景：</p><p><strong>(i) 引用输出参数（reference output parameter）：</strong><br> 这是指作为函数参数传入的引用，但其行为像“输出”——因为它可以在函数外被访问（例如图 1a 中的 <code>list</code>）。对这类参数而言，<strong>基变量</strong>是“非拥有”（因为它是引用）且是可变的，而<strong>从它可达的指针</strong>则可能是“拥有”的（见图 1c 的示例，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>∗</mo><mtext>node</mtext><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mtext>head</mtext></mrow><annotation encoding="application/x-tex">(*\\text{node}).\\text{head}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord text"><span class="mord">node</span></span><span class="mclose">)</span><span class="mord">.</span><span class="mord text"><span class="mord">head</span></span></span></span></span> 被赋值为指向新分配节点的指针）。我们能够检测到这类情况并<strong>显式</strong>地使之可用。具体来说，我们在翻译阶段会把拥有指针 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 显式转换为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">&amp;</mi><mrow><mi mathvariant="monospace">m</mi><mi mathvariant="monospace">u</mi><mi mathvariant="monospace">t</mi></mrow><mo stretchy="false">(</mo><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\&amp;\\mathtt{mut}(*p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">&amp;</span><span class="mord"><span class="mord mathtt">mut</span></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>。</p><p><strong>(ii) 局部借用（local borrows）：</strong><br> 下面这段涉及“可变局部借用”的代码在 <strong>CROWN</strong> 中被视为<strong>无效</strong>，因为它违反了“所有权单调性”：赋值之后，<code>local_borrow</code> 是“非拥有”的，而 <code>*local_borrow</code> 却是“拥有”的。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> local_borrow</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">local_borrow</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> Box</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">new</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>尽管理论上我们可以在翻译时显式处理“局部借用”，但若要<strong>健全</strong>地这么做，就必须对<strong>生命周期信息</strong>进行推理（例如，CROWN 需要检查：同一对象的不同可变引用的生命周期之间不存在重叠）。在本工作中我们选择<strong>暂不</strong>处理，将其留作未来工作（第 7 节“局限性”中亦有提及）。已有研究 [13] 观察到，场景 (i) 的出现频率<strong>远高于</strong>场景 (ii)。此外，我们在基准中还观察到：<strong>输出参数</strong>约占 <strong>93%</strong> 的可变引用（这也解释了 CROWN 中为何加入针对场景 (i) 的特殊处理来启用其翻译）。</p><blockquote><p>笔者注：尚未解决生命周期问题</p></blockquote><h2 id="_6-从-c-到-rust-的翻译-c-to-rust-translation" tabindex="-1"><a class="header-anchor" href="#_6-从-c-到-rust-的翻译-c-to-rust-translation"><span>6. 从 C 到 Rust 的翻译（C to Rust Translation）</span></a></h2><p><strong>CROWN</strong> 利用前述所有权、可变性以及“胖指针（fatness）”分析的结果来执行实际的翻译工作，翻译包含两部分：指针重类型化（第 6.1 节）以及重写指针用法（第 6.2 节）。</p><h3 id="_6-1-指针重类型化-retyping-pointers" tabindex="-1"><a class="header-anchor" href="#_6-1-指针重类型化-retyping-pointers"><span>6.1 指针重类型化（Retyping Pointers）</span></a></h3><p>如第 2.2 节所述，我们并不尝试把<strong>数组指针</strong>翻译为安全指针。以下内容仅聚焦于<strong>可变的、非数组</strong>指针。</p><p>该翻译需要对指针<strong>所有权</strong>进行<strong>全局视角</strong>的把握；而所有权分析本身给出的信息是针对<strong>具体程序位置</strong>的。出于翻译的目的（并考虑到我们会把“拥有指针”重构为 <strong>Box</strong> 指针），我们采用如下约定：若某指针在其作用域内的<strong>任一</strong>程序位置上“拥有”某个内存对象，就将其视为（全局）<strong>拥有</strong>；否则将其视为（全局）<strong>非拥有</strong>。</p><p>当我们给结构体的<strong>指针字段</strong>重类型时，必须把整个结构体声明的<strong>作用域</strong>纳入考虑，这个作用域一般跨越<strong>整个程序</strong>。在该作用域内，每个字段通常会被<strong>多个基变量</strong>访问，这些基变量都需要被纳入考量。举例来说，给定图1b 中的 <code>List</code> 声明，以及两个类型为 <code>*mut List</code> 的变量 <code>l1</code> 与 <code>l2</code>。为了确定字段 <code>next</code> 的所有权状态，我们必须考虑<strong>所有</strong>从 <code>l1</code> 与 <code>l2</code> 这两个基变量出发到达 <code>next</code> 的<strong>访问路径</strong>。</p><p>下表展示了针对<strong>可变、非数组</strong>指针的重类型规则；为处理<strong>空指针</strong>的可能，我们将安全指针类型用 <code>Option</code> 包裹：</p><table><thead><tr><th></th><th>非数组指针</th></tr></thead><tbody><tr><td>拥有（Owning）</td><td><code>Option&lt;Box&lt;T&gt;&gt;</code></td></tr><tr><td>非拥有（Non-owning）</td><td><code>*mut T</code> 或 <code>Option&lt;&amp;mut T&gt;</code></td></tr></tbody></table><p>被保留为<strong>裸指针</strong>（<code>*mut T</code>）的那些<strong>非拥有指针</strong>，对应于<strong>可变的局部借用</strong>。正如第 5.4 节与第 7 节所解释的，目前 <strong>CROWN</strong> 尚不能把<strong>可变局部借用</strong>翻译为安全形式，原因在于我们缺少<strong>生命周期分析</strong>。需要强调的是，这一限制<strong>不适用于输出参数</strong>（它们覆盖了<strong>大多数</strong>可变引用），对这些情况我们会把它们翻译成<strong>可变引用</strong>。同样由于缺少生命周期分析，我们也无法处理<strong>不可变的局部借用</strong>，因此本工作的翻译重点放在<strong>可变指针</strong>上。</p><blockquote><p>笔者注：这些都是未来可以做的内容</p></blockquote><h3 id="_6-2-重写指针用法-rewriting-pointer-uses" tabindex="-1"><a class="header-anchor" href="#_6-2-重写指针用法-rewriting-pointer-uses"><span>6.2 重写指针用法（Rewriting Pointer Uses）</span></a></h3><p>对某个指针表达式的重写取决于它<strong>新的类型</strong>以及其所处的<strong>上下文</strong>。例如，在重写赋值语句 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p = q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 中右侧的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 时，所采用的重写方式取决于变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 被重类型后的新类型。基于这个新类型，我们区分四类上下文：<strong>BoxCtxt</strong>（需要 <code>Box</code> 指针）、<strong>MutCtxt</strong>（需要 <code>&amp;mut</code> 引用）、<strong>ConstCtxt</strong>（需要 <code>&amp;</code> 引用）以及 <strong>RawCtxt</strong>（需要裸指针）。例如，若上例中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 被重类型为 <code>Box</code> 指针，那么我们就把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 置于 <strong>BoxCtxt</strong> 中进行重写。</p><p>随后，重写按照下表进行：列对应“被重写的指针”的<strong>新类型</strong>，行对应可能的<strong>上下文</strong>。</p><table><thead><tr><th></th><th><code>Option&lt;Box&lt;T&gt;&gt;</code></th><th><code>Option&lt;&amp;mut T&gt;</code></th><th><code>*mut T</code></th></tr></thead><tbody><tr><td><strong>BoxCtxt</strong></td><td><code>p.take()</code></td><td>⟂</td><td><code>Some(Box::from_raw(p))</code></td></tr><tr><td><strong>MutCtxt</strong></td><td><code>p.as_deref_mut()</code></td><td><code>p.as_deref_mut()</code></td><td><code>p.as_mut()</code></td></tr><tr><td><strong>ConstCtxt</strong></td><td><code>p.as_deref()</code></td><td><code>p.as_deref()</code></td><td><code>p.as_ref()</code></td></tr><tr><td><strong>RawCtxt</strong></td><td><code>to_raw(&amp;mut p)</code></td><td><code>to_raw(&amp;mut p)</code></td><td><code>p</code></td></tr></tbody></table><p>（表中标记为 <strong>⟂</strong> 的单元格由于我们对<strong>输出参数</strong>的处理方式而<strong>不适用</strong>）</p><p>我们的翻译依赖于 Rust 标准库中的函数，具体如下：</p><ol><li>当 <code>Option&lt;Box&lt;T&gt;&gt;</code> 处在 <strong>BoxCtxt</strong> 中时，我们期望发生<strong>移动（move）</strong>；因此使用 <code>take</code> 将选项中的值取出，并把原位置置为 <code>None</code>；</li><li>使用 <code>as_deref</code> 与 <code>as_deref_mut</code> 的目的是<strong>不消耗</strong>原始的 <code>Option</code> 值，同时<strong>基于其中的引用</strong>创建新的 <code>Option</code> 值；</li><li><code>as_mut</code> 与 <code>as_ref</code> 将<strong>裸指针</strong>转换为<strong>引用</strong>；</li><li><code>Box::from_raw</code> 将<strong>裸指针</strong>转换回 <code>Box</code> 指针；</li></ol><p>此外，我们定义辅助函数 <code>to_raw</code>，用于把安全指针转换为<strong>裸指针</strong>：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> to_raw</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> Option</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Box</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;&gt;) -&gt; *</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">as_deref_mut</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">|</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">|</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> b</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> as</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unwrap_or</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">null_mut</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">())</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面以 <code>Box</code> 为例解释 <code>to_raw</code> 的工作原理（对 <code>&amp;mut</code> 的解释相同，因为 <code>as_deref_mut</code> 是<strong>多态</strong>的）：</p><ol><li>为了把 <code>Option&lt;Box&lt;T&gt;&gt;</code> 转为裸指针，我们首先对整个 <code>Option</code> 进行<strong>可变借用</strong>，作为辅助函数的可变借用形参。这一步是必要的，因为 <code>Option</code> <strong>不可拷贝</strong>，否则会被消耗；</li><li><code>as_deref_mut</code> 将 <code>&amp;mut Option&lt;Box&lt;T&gt;&gt;</code> 转换为 <code>Option&lt;&amp;mut T&gt;</code>；</li><li><code>map</code> 把可选引用中的 <code>Some(&amp;mut T)</code> 映射为 <code>Some(*mut T)</code>（即选项里的引用被转换为<strong>裸指针</strong>的选项）；</li><li>最后，<code>unwrap_or</code> 返回选项中的 <code>Some</code> 值；若为 <code>None</code>，则返回空指针 <code>std::ptr::null_mut()</code>。</li></ol><p><strong>解引用（Dereferences）</strong>：当指针 <code>p</code> 作为更大表达式的一部分被解引用时（例如 <code>(*p).next</code>），我们需要额外调用一次 <code>unwrap()</code>。</p><p><strong>Box 指针检查（Box pointers check）</strong>：Rust 不允许在 <code>Box</code> <strong>失去所有权</strong>之后继续使用该 <code>Box</code>。由于所有权分析无法捕获这条规则，我们在<strong>翻译阶段</strong>检测到此类情形时，会将相关的 <code>Box</code> 指针<strong>回退</strong>为<strong>裸指针</strong>以避免违规。</p><p>为简洁起见，我们省略了对<strong>非指针类型</strong>结构体字段的（略有不同的）处理方式。</p><h2 id="_7-处理真实世界代码的挑战-challenges-of-handling-real-world-code" tabindex="-1"><a class="header-anchor" href="#_7-处理真实世界代码的挑战-challenges-of-handling-real-world-code"><span>7. 处理真实世界代码的挑战（Challenges of Handling Real-World Code）</span></a></h2><p>我们将 <strong>CROWN</strong> 设计成能够分析并翻译真实世界代码的工具，但这会带来一系列重大的工程挑战。本节讨论 <strong>CROWN</strong> 在工程实现上的一些难点以及其当前的局限。</p><h3 id="_7-1-预处理-preprocessing" tabindex="-1"><a class="header-anchor" href="#_7-1-预处理-preprocessing"><span>7.1 预处理（Preprocessing）</span></a></h3><p>在对 C 代码库进行“跨语言转译”（transpilation）时，<strong>c2rust</strong> 将<strong>每个文件</strong>都视为一个独立的<strong>编译单元</strong>，并把它翻译成一个单独的 Rust 模块。由此带来的结果是：结构体定义会<strong>重复</strong>出现，而可用的函数定义会被放进 <code>extern</code> 块中【17】。我们采用与 <strong>Laertes</strong> 的 <em>resolve-imports</em> 工具【17】相似的<strong>预处理步骤</strong>，把这些定义在不同文件之间<strong>链接</strong>起来。</p><h3 id="_7-2-所有权分析的局限-limitations-of-the-ownership-analysis" tabindex="-1"><a class="header-anchor" href="#_7-2-所有权分析的局限-limitations-of-the-ownership-analysis"><span>7.2 所有权分析的局限（Limitations of the Ownership Analysis）</span></a></h3><p>有一些 C 语言结构与习惯用法并未被我们的实现完全支持；在这些情形下，<strong>CROWN</strong> 只能生成<strong>部分的</strong>所有权约束。<strong>CROWN</strong> 的翻译策略是：只要有<strong>任意</strong>约束涉及某变量，我们就尝试对该变量进行重写。其结果是在理论上既非<strong>健全</strong>（sound），也非<strong>完备</strong>（complete）：它<strong>可能</strong>生成<strong>无法通过编译</strong>的代码（不过在 <strong>CROWN</strong> 能产出结果的基准上我们并未观察到这种情况——见第 8 节），并且它<strong>可能</strong>把某些指针<strong>保留为裸指针</strong>，导致翻译<strong>次优</strong>。下面列举可能出现这种情形的具体场景。</p><p><strong>某些不安全的 C 构造（Certain Unsafe C Constructs）</strong>。<br> 对类型转换（type casts），我们只为<strong>头指针</strong>（head pointers）生成所有权转移约束；对 <strong>union</strong>，我们假定其<strong>不含指针字段</strong>，因此<strong>不生成</strong>任何约束；类似地，我们对<strong>变参（variadic）<strong>实参也不生成约束。我们注意到，<strong>union</strong> 与</strong>变参</strong>在某些情况下会导致我们的工具<strong>崩溃</strong>（例如【17】中的三个基准，详见第 8 节）。出现崩溃的情形包括：分析的<strong>访问路径</strong>中包含对 <strong>union 字段</strong>的解引用（而我们此前假定其<strong>无指针字段</strong>），以及分析<strong>向带变参的函数</strong>进行调用、且<strong>指针</strong>作为实参传入的情况。</p><blockquote><p>可变参数示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;stdarg.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> sum_ints</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> ...</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    va_list ap;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    va_start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ap, count);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> total </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> count; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">i) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 注意：小于 int 的整数类型会发生“默认整型提升”</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 这里用 int 取是安全的（因为 char/short 都已提升为 int）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        total </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> va_arg</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ap, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    va_end</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ap);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> total;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sum_ints</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 输出 15</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p><strong>函数指针（Function Pointers）</strong>。<br><strong>CROWN</strong> 不会为<strong>函数指针</strong>生成任何约束。</p><p><strong>C 库中的非标准内存管理（Non-standard Memory Management in C Libraries）</strong>。<br> 部分 C 库会对 <code>malloc</code> 与 <code>free</code> 做封装，常见做法是借助<strong>静态函数指针</strong>（指向分配/释放器的指针存放在静态变量中），或把<strong>函数指针</strong>置于结构体中。对于这种情形，<strong>CROWN</strong> 不生成任何约束。在 C 中，还可以用一次 <code>malloc</code> <strong>分配一大块内存</strong>，然后把它<strong>切分</strong>为若干子区域，分别赋给不同的指针。在我们的所有权分析中，<strong>只有单个指针</strong>会因一次对 <code>malloc</code> 的调用而获得那块内存的所有权。另一类我们未完全支持的 C 习惯用法是：某些指针<strong>可能同时指向</strong>堆上分配的对象，或者<strong>静态分配</strong>在栈上的数组。<strong>CROWN</strong> 仅为<strong>堆</strong>生成所有权约束；因此，这些变量会被<strong>欠约束</strong>（under-constrained）。</p><blockquote><p>示例（某些指针可能指向堆上对象或栈上数据）：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 约定：如果 take_ownership = true，则函数会在内部保存并在稍后 free；</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//       如果为 false，则只借用这段内存，绝不负责释放。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> set_buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> size_t</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> bool</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> take_ownership</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> example</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">bool</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> use_heap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">p;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    size_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (use_heap) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        p </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> malloc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     // 堆：可转移所有权</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        set_buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(p, n, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          // 交出所有权，后续不再 free(p)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> local</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                 // 栈：仅借用</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        p </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> local;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        set_buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(p, n, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">         // 不可转移所有权</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // local 作用域一过期，任何延迟使用/释放都会是 UB</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h3 id="_7-3-crown-的其他局限-other-limitations-of-crown" tabindex="-1"><a class="header-anchor" href="#_7-3-crown-的其他局限-other-limitations-of-crown"><span>7.3 CROWN 的其他局限（Other Limitations of CROWN）</span></a></h3><p><strong>数组指针（Array Pointers）</strong>。 对于数组指针，尽管 <strong>CROWN</strong> 能推断到<strong>正确的所有权信息</strong>，但它<strong>不会</strong>生成综合 Rust 代码所需的<strong>元数据</strong>。</p><p><strong>可变的局部借用（Mutable Local Borrows）</strong>。<br> 如第 6.1 节末段所述，<strong>CROWN</strong> <strong>不会</strong>把<strong>可变的非拥有指针</strong>翻译为<strong>局部可变引用</strong>，因为这需要专门的<strong>生命周期分析</strong>。需要注意的是，<strong>CROWN</strong> <strong>会</strong>为<strong>输出参数</strong>生成<strong>可变引用</strong>。</p><p><strong>破坏“所有权单调性”的访问路径（Access Paths that Break Ownership Monotonicity）</strong>。<br> 如第 5.4 节所讨论，<strong>所有权单调性</strong>在某些情况下<strong>比 Rust 语义更严格</strong>；因此这些访问路径会被我们拒绝，尽管它们在 Rust 中可能是被接受的。</p><h2 id="_8-实验评估-experimental-evaluation" tabindex="-1"><a class="header-anchor" href="#_8-实验评估-experimental-evaluation"><span>8. 实验评估（Experimental Evaluation）</span></a></h2><p>我们将 <strong>CROWN</strong> 实现在 Rust 编译器之上，使用的编译器版本为 <code>nightly-2023-01-26</code>。我们采用 <strong>c2rust</strong> 版本 <code>0.16.0</code>。对于 SAT 求解，我们依赖 <strong>z3</strong> 的 Rust 绑定【20】（版本 <code>0.11.2</code>）。所有实验均在一台搭载 Apple M1 芯片的 MacBook Pro 上进行，8 核（4 性能核 + 4 效率核），16GB 内存，操作系统为 macOS Monterey 12.5.1。</p><p><strong>基准选择（Benchmark Selection）</strong>。 为评估 <strong>CROWN</strong> 的实用性，我们收集了由 20 个程序组成的基准套件（见表1）。其中包含 <strong>Laertes</strong>【17】随论文提供的工件【16】中的基准（表1 中以 * 标记），以及额外的 8 个真实项目（<code>binn, brotli, buffer, heman, json.h, libtree, lodepng, rgba</code>），另加 4 个常用数据结构库（<code>avl, bst, ht, quadtree</code>）。</p><figure><img src="`+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>功能与非功能保证（Functional and Non-functional Guarantees）</strong>。<br> 在<strong>功能</strong>属性方面，我们希望<strong>原始程序</strong>与<strong>重构后程序</strong>在观测上<strong>等价</strong>，即对每个输入产生相同输出。我们使用所有可用的测试集对这一点进行了实证验证（表 1 中的 <code>libtree, rgba, quadtree, urlparser, genann, buffer</code> 等均提供测试）。所有测试在翻译后依然<strong>全部通过</strong>。<br> 在<strong>非功能</strong>属性方面，我们期望保持<strong>内存占用</strong>与 <strong>CPU 时间</strong>，也就是说不希望翻译引入显著的<strong>运行时开销</strong>。我们同样使用这些测试集对该点进行了验证。</p><h3 id="_8-1-研究问题-research-questions" tabindex="-1"><a class="header-anchor" href="#_8-1-研究问题-research-questions"><span>8.1 研究问题（Research Questions）</span></a></h3><p>我们拟回答以下研究问题：</p><ul><li><strong>RQ1.</strong> <strong>CROWN</strong> 能将多少<strong>裸指针/指针用法</strong>翻译为<strong>安全指针/安全指针用法</strong>？</li><li><strong>RQ2.</strong> <strong>CROWN</strong> 的结果与<strong>当前最先进方法</strong>【17】相比如何？</li><li><strong>RQ3.</strong> <strong>CROWN</strong> 的<strong>运行性能</strong>如何？</li></ul><hr><p><strong>RQ1：不安全指针的减少（Unsafe pointer reduction）</strong>。<br> 为评估 <strong>CROWN</strong> 的有效性，我们测量了<strong>裸指针声明</strong>与<strong>裸指针用法</strong>的<strong>减少率</strong>。这一指标能直接反映安全性的提升，因为即使在 <code>unsafe</code> 区域内，<strong>安全指针</strong>仍然会被 Rust 编译器检查。正如前文所述，我们聚焦于<strong>可变、非数组</strong>指针。结果见<strong>表2</strong>：其中，<code>#ptrs</code> 统计某个基准中<strong>裸指针声明</strong>的数量，<code>#uses</code> 统计<strong>裸指针被使用</strong>的次数；表头的 <strong>Laertes</strong> 与 <strong>CROWN</strong> 分别给出了两种工具对“裸指针数量”和“裸指针用法次数”的<strong>减少率</strong>。例如，在基准 <strong>avl</strong> 中，<strong>100%</strong> 的减少率意味着<strong>所有</strong>裸指针声明及其<strong>所有用法</strong>均被翻译为安全形式。注意，<code>robotfindskitten</code> 这一行中的 “–” 符号是因为该基准<strong>没有</strong>任何裸指针用法。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>CROWN</strong> 在全部基准上的<strong>中位减少率</strong>为：</p><ul><li>对<strong>裸指针数量</strong>：<strong>37.3%</strong>；</li><li>对<strong>裸指针用法次数</strong>：<strong>62.1%</strong>。</li></ul><p><strong>CROWN</strong> 在许多<strong>非平凡数据结构</strong>（<code>avl, bst, buffer, ht</code>）中实现了<strong>100%</strong> 的减少率，在 <code>rgba</code> 上也表现良好。对于我们体量最大的基准 <strong>brotli</strong>（由 Google 开发的<strong>无损压缩</strong>算法），减少率分别为 <strong>21.4%</strong> 与 <strong>20.9%</strong>。<strong>brotli</strong> 及少数其他基准（<code>tulipindicators, lodepng, bzip2, genann, libzahl</code>）的较低减少率，源于它们使用了<strong>非标准内存管理策略</strong>（详见第 7 节）。</p><p>值得注意的是，所有被翻译的基准都能在上述 Rust 编译器版本下<strong>成功编译</strong>。作为语义保持性的进一步检验，对于提供测试集的那些基准（<code>libtree, rgba, quadtree, urlparser, genann, buffer</code>），我们翻译后的版本<strong>全部通过</strong>其自带测试。</p><p><strong>RQ2：与最先进方法的对比（Comparing with state-of-the-art）</strong>。<br><strong>CROWN</strong> 与 <strong>Laertes</strong>【17】的比较亦见<strong>表 2</strong>（表中<strong>加粗</strong>表示更好的结果）。Laertes 的数据或是直接摘自其工件【16】，或经作者私下确认。可以看出，<strong>CROWN</strong> 在多数情形下优于当前最先进方法（且往往有<strong>显著</strong>优势）。唯一的例外是 <strong>lodepng</strong>，我们推测其原因同样与前述<strong>非标准内存管理策略</strong>有关；而 <strong>Laertes</strong> 较少受此影响，因为它<strong>不依赖</strong>所有权分析。</p><p><strong>RQ3：运行性能（Runtime performance）</strong>。<br> 尽管我们的分析依赖求解一个被证明为 <strong>NP 完全</strong> 的约束满足问题，但在实际中 <strong>CROWN</strong> 的<strong>运行性能</strong>始终表现出<strong>较高</strong>的效率：对整个基准套件完成“分析 + 重写”的总时间<strong>不超过 60 秒</strong>（其中对我们最大的基准 <strong>brotli</strong> 的用时<strong>不足 10 秒</strong>）。</p><h2 id="_9-相关工作-related-works" tabindex="-1"><a class="header-anchor" href="#_9-相关工作-related-works"><span>9. 相关工作（Related Works）</span></a></h2><p><strong>关于所有权的讨论（Ownership Discussion）。</strong><br> 在面向对象（OO）程序设计中，“所有权”常被用来在运行时堆上的对象图之上施加限制，以实现<strong>受控的别名共享</strong>【11,12】；围绕<strong>自动推断所有权信息</strong>也有诸多工作【1,4,39】；同时，“所有权”的思想也被用于<strong>内存管理</strong>【5,42】。类似地，“所有权”概念也被用于分析 C/C++ 程序。Heine 等【24】为了检测<strong>内存泄漏</strong>而推断指针的所有权信息；Ravitch 等【37】利用静态分析为<strong>自动生成库绑定</strong>推断所有权。由于应用场景不同，这些工作做出了不同的假设：Heine 等【24】假定<strong>间接访问</strong>到的指针（例如经由访问路径访问到的任意指针，如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">(*p).next</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span></span></span></span>）<strong>无法获得所有权</strong>；而 Ravitch 等【37】则假定<strong>所有结构体字段</strong>在未显式注释时<strong>默认是拥有的</strong>。我们借鉴了【24】对<strong>流敏感（flow sensitivity）<strong>的处理，但进一步加入了对</strong>嵌套指针</strong>和<strong>归纳定义数据结构</strong>的分析——我们发现这对翻译真实世界代码至关重要。【24】中的分析将所有<strong>间接访问</strong>到的指针一律赋予默认的“<strong>非拥有</strong>”状态，这排除了许多有趣的数据结构（链表、树、哈希表等）以及常见的习惯用法（例如按引用传参）。相较之下，我们在工作中依赖一个<strong>更强的</strong>、关于 Rust 所有权模型的假设，从而能够处理上述场景与数据结构。最后，“所有权”的思想也被广泛用于<strong>并发分离逻辑</strong>【7–9,19,38】，但这些工作并<strong>非</strong>旨在构建<strong>自动的所有权推断系统</strong>。</p><blockquote><p>笔者注：所有权在C/C++内存泄漏检测方面也有一席之地； 本文相当于是把一些现有的所有权的方法迁移到c2rust领域；</p></blockquote><p><strong>Rust 形式化验证（Rust Verification）。</strong><br> 以分离逻辑为基础的推理框架 <strong>Iris</strong>【28】被用于<strong>形式化</strong> Rust 的类型系统【27】，并对 Rust 程序进行<strong>验证</strong>【34】。尽管这些工作覆盖了<strong>unsafe</strong> 的 Rust 片段，但它们并非<strong>全自动</strong>。当把推理仅限制在<strong>安全 Rust</strong>时，<strong>RustHorn</strong>【35】给出了 Rust 代码行为的一阶逻辑表述，便于进行<strong>完全自动</strong>的验证；而 <strong>Prusti</strong>【3】利用 Rust 编译器的信息生成分离逻辑的验证条件，并由 <strong>Viper</strong>【36】自动消解。在本文中，我们为<strong>unsafe Rust 程序</strong>提供了一种<strong>自动的所有权分析</strong>。</p><p><strong>类型限定符（Type Qualifiers）。</strong><br> 类型限定符是一种<strong>轻量、实用</strong>的机制，用于指定与检查那些传统类型系统所不能捕获的性质。通用的、<strong>流不敏感</strong>（flow-insensitive）的类型限定符框架已被提出【21】；其后续应用包含：分析 <strong>Java</strong> 引用的<strong>可变性</strong>【22,25】与 <strong>C</strong> 的<strong>数组边界</strong>【32】。我们将这些工作<strong>迁移到 Rust</strong>，分别用于本文中的<strong>可变性分析</strong>与<strong>胖指针分析</strong>。</p><blockquote><p>笔者注：静态程序分析的相关知识运用：引用可变性分析、胖指针分析</p></blockquote><p><strong>从 C 到 Rust 的翻译（C to Rust Translation）。</strong><br> 我们已在前文讨论了 <strong>c2rust</strong>【26】：这是一款工业级工具，用于把 C 转换为 Rust 的<strong>语法</strong>。<strong>c2rust</strong> 并不尝试修复不安全特性（如裸指针），其生成的程序总是带有 <code>unsafe</code> 注解。尽管如此，它仍是其它翻译工作的基础。<strong>CRustS</strong>【31】通过基于 AST 的代码变换来移除由 <strong>c2rust</strong> 产生的<strong>多余的 <code>unsafe</code> 标注</strong>，但它也<strong>不会</strong>修复不安全特性。<strong>Laertes</strong>【17】是第一个能够<strong>自动减少</strong>不安全代码比例的工具：它把 Rust 编译器当作<strong>黑盒预言机</strong>，并搜索那些<strong>移除裸指针</strong>的代码修改；这与 <strong>CROWN</strong> 的方法不同（实验性比较见第 8 节）。后续工作【15】提出了一个评测方法，用于研究把<strong>不安全裸指针</strong>翻译为<strong>安全引用</strong>的现有技术的局限性。该工作采用了一个新的“<strong>伪安全（pseudo safety）</strong>”概念，在此概念下，<strong>原始程序的语义保持</strong>不再得到保证。正如第 8 节所述，我们的目标是<strong>保持语义等价</strong>。</p><hr><h2 id="_10-结论-conclusion" tabindex="-1"><a class="header-anchor" href="#_10-结论-conclusion"><span>10 结论（Conclusion）</span></a></h2><p>我们提出了一种针对由 <strong>c2rust</strong> 翻译得到的 Rust 程序的<strong>所有权分析</strong>。该分析具有<strong>可扩展性</strong>（可在 <strong>10 秒内</strong>处理<strong>50 万行</strong>代码）与<strong>精确性</strong>（能够处理<strong>归纳式数据结构</strong>），其关键在于我们对 Rust 所有权模型进行了<strong>强化</strong>，并将其称为“<strong>所有权单调性（ownership monotonicity）</strong>”。基于这一新的分析，我们实现了一个<strong>原型重构工具</strong>，用于把 <strong>C 程序</strong>翻译为 <strong>Rust 程序</strong>。实验评估显示，所提出的方法能够处理<strong>真实世界基准</strong>，并在多数情形下<strong>优于</strong>当前最先进的方法。</p>',207)]))}const k=a(o,[["render",h],["__file","Ownership_Guided_C_to_Rust_Translation.html.vue"]]),u=JSON.parse(`{"path":"/posts/scholar/Ownership_Guided_C_to_Rust_Translation.html","title":"Ownership Guided C to Rust Translation","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-10-13T00:00:00.000Z","category":["Rust"],"tag":["c2rust"],"description":"Ownership Guided C to Rust Translation 论文来自 Computer Aided Verification (CAV 2023) 的《Ownership Guided C to Rust Translation》。 Github | zenodo 摘要 Rust 常被称为更安全的 C，它是一门将内存安全与低层次控制相...","head":[["meta",{"property":"og:url","content":"https://iXanadu13.github.io/posts/scholar/Ownership_Guided_C_to_Rust_Translation.html"}],["meta",{"property":"og:site_name","content":"Xanadu13's Blog"}],["meta",{"property":"og:title","content":"Ownership Guided C to Rust Translation"}],["meta",{"property":"og:description","content":"Ownership Guided C to Rust Translation 论文来自 Computer Aided Verification (CAV 2023) 的《Ownership Guided C to Rust Translation》。 Github | zenodo 摘要 Rust 常被称为更安全的 C，它是一门将内存安全与低层次控制相..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://iXanadu13.github.io/assets/images/scholar/Ownership_Guided_C_to_Rust_Translation/figure1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-14T03:24:21.000Z"}],["meta",{"property":"article:tag","content":"c2rust"}],["meta",{"property":"article:published_time","content":"2025-10-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-14T03:24:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Ownership Guided C to Rust Translation\\",\\"image\\":[\\"https://iXanadu13.github.io/assets/images/scholar/Ownership_Guided_C_to_Rust_Translation/figure1.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/Ownership_Guided_C_to_Rust_Translation/figure2.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/Ownership_Guided_C_to_Rust_Translation/figure3.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/Ownership_Guided_C_to_Rust_Translation/table1.png\\",\\"https://iXanadu13.github.io/assets/images/scholar/Ownership_Guided_C_to_Rust_Translation/table2.png\\"],\\"datePublished\\":\\"2025-10-13T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-14T03:24:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Xanadu13\\",\\"url\\":\\"https://github.com/iXanadu13\\"}]}"]]},"headers":[{"level":2,"title":"摘要","slug":"摘要","link":"#摘要","children":[]},{"level":2,"title":"1. 引言（Introduction）","slug":"_1-引言-introduction","link":"#_1-引言-introduction","children":[]},{"level":2,"title":"2. 背景（Background）","slug":"_2-背景-background","link":"#_2-背景-background","children":[{"level":3,"title":"2.1 Rust 的所有权模型（Rust Ownership Model）","slug":"_2-1-rust-的所有权模型-rust-ownership-model","link":"#_2-1-rust-的所有权模型-rust-ownership-model","children":[]},{"level":3,"title":"2.2 Rust 中的指针类型（Pointer Types in Rust）","slug":"_2-2-rust-中的指针类型-pointer-types-in-rust","link":"#_2-2-rust-中的指针类型-pointer-types-in-rust","children":[]},{"level":3,"title":"2.3 不安全的 Rust（Unsafe Rust）","slug":"_2-3-不安全的-rust-unsafe-rust","link":"#_2-3-不安全的-rust-unsafe-rust","children":[]}]},{"level":2,"title":"3. 综述（Overview）","slug":"_3-综述-overview","link":"#_3-综述-overview","children":[{"level":3,"title":"3.1 将元素压入单链表（Pushing into a Singly-Linked List）","slug":"_3-1-将元素压入单链表-pushing-into-a-singly-linked-list","link":"#_3-1-将元素压入单链表-pushing-into-a-singly-linked-list","children":[]},{"level":3,"title":"3.2 在 bzip2 中释放参数列表","slug":"_3-2-在-bzip2-中释放参数列表","link":"#_3-2-在-bzip2-中释放参数列表","children":[]}]},{"level":2,"title":"4. 架构（Architecture）","slug":"_4-架构-architecture","link":"#_4-架构-architecture","children":[]},{"level":2,"title":"5. 所有权分析（Ownership Analysis）","slug":"_5-所有权分析-ownership-analysis","link":"#_5-所有权分析-ownership-analysis","children":[{"level":3,"title":"5.1  所有权与别名（Ownership and Aliasing）","slug":"_5-1-所有权与别名-ownership-and-aliasing","link":"#_5-1-所有权与别名-ownership-and-aliasing","children":[]},{"level":3,"title":"5.2 生成所有权约束（Generation of Ownership Constraints）","slug":"_5-2-生成所有权约束-generation-of-ownership-constraints","link":"#_5-2-生成所有权约束-generation-of-ownership-constraints","children":[]},{"level":3,"title":"5.3 解决所有权约束（Solving Ownership Constraints）","slug":"_5-3-解决所有权约束-solving-ownership-constraints","link":"#_5-3-解决所有权约束-solving-ownership-constraints","children":[]},{"level":3,"title":"5.4 关于“所有权单调性”的讨论（Discussion on Ownership Monotonicity）","slug":"_5-4-关于-所有权单调性-的讨论-discussion-on-ownership-monotonicity","link":"#_5-4-关于-所有权单调性-的讨论-discussion-on-ownership-monotonicity","children":[]}]},{"level":2,"title":"6. 从 C 到 Rust 的翻译（C to Rust Translation）","slug":"_6-从-c-到-rust-的翻译-c-to-rust-translation","link":"#_6-从-c-到-rust-的翻译-c-to-rust-translation","children":[{"level":3,"title":"6.1 指针重类型化（Retyping Pointers）","slug":"_6-1-指针重类型化-retyping-pointers","link":"#_6-1-指针重类型化-retyping-pointers","children":[]},{"level":3,"title":"6.2 重写指针用法（Rewriting Pointer Uses）","slug":"_6-2-重写指针用法-rewriting-pointer-uses","link":"#_6-2-重写指针用法-rewriting-pointer-uses","children":[]}]},{"level":2,"title":"7. 处理真实世界代码的挑战（Challenges of Handling Real-World Code）","slug":"_7-处理真实世界代码的挑战-challenges-of-handling-real-world-code","link":"#_7-处理真实世界代码的挑战-challenges-of-handling-real-world-code","children":[{"level":3,"title":"7.1 预处理（Preprocessing）","slug":"_7-1-预处理-preprocessing","link":"#_7-1-预处理-preprocessing","children":[]},{"level":3,"title":"7.2 所有权分析的局限（Limitations of the Ownership Analysis）","slug":"_7-2-所有权分析的局限-limitations-of-the-ownership-analysis","link":"#_7-2-所有权分析的局限-limitations-of-the-ownership-analysis","children":[]},{"level":3,"title":"7.3 CROWN 的其他局限（Other Limitations of CROWN）","slug":"_7-3-crown-的其他局限-other-limitations-of-crown","link":"#_7-3-crown-的其他局限-other-limitations-of-crown","children":[]}]},{"level":2,"title":"8. 实验评估（Experimental Evaluation）","slug":"_8-实验评估-experimental-evaluation","link":"#_8-实验评估-experimental-evaluation","children":[{"level":3,"title":"8.1 研究问题（Research Questions）","slug":"_8-1-研究问题-research-questions","link":"#_8-1-研究问题-research-questions","children":[]}]},{"level":2,"title":"9. 相关工作（Related Works）","slug":"_9-相关工作-related-works","link":"#_9-相关工作-related-works","children":[]},{"level":2,"title":"10 结论（Conclusion）","slug":"_10-结论-conclusion","link":"#_10-结论-conclusion","children":[]}],"git":{"createdTime":1760364229000,"updatedTime":1760412261000,"contributors":[{"name":"Xanadu13","email":"xanadu13@qq.com","commits":4}]},"readingTime":{"minutes":46.19,"words":13858},"filePathRelative":"posts/scholar/Ownership_Guided_C_to_Rust_Translation.md","localizedDate":"2025年10月13日","excerpt":"\\n<p>论文来自 Computer Aided Verification (CAV 2023) 的《<a href=\\"https://link.springer.com/chapter/10.1007/978-3-031-37709-9_22\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Ownership Guided C to Rust Translation</a>》。</p>\\n<p><a href=\\"https://github.com/KomaEc/crown\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Github</a> | <a href=\\"https://zenodo.org/records/7966511\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">zenodo</a></p>","autoDesc":true}`);export{k as comp,u as data};
