import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as t,b as n,e as l,f as a,g as r,r as s,o as d}from"./app-D137JRMy.js";const c={};function h(g,e){const p=s("RouteLink");return d(),i("div",null,[e[3]||(e[3]=t('<h1 id="面试真题整理" tabindex="-1"><a class="header-anchor" href="#面试真题整理"><span>面试真题整理</span></a></h1><h2 id="_1-一亿个数选出最大的100个" tabindex="-1"><a class="header-anchor" href="#_1-一亿个数选出最大的100个"><span>1. 一亿个数选出最大的100个</span></a></h2><p><em>多方面考虑，全面回答</em></p><h3 id="_1-流式-内存受限-固定大小最小堆" tabindex="-1"><a class="header-anchor" href="#_1-流式-内存受限-固定大小最小堆"><span>（1）流式/内存受限：固定大小最小堆</span></a></h3><p>维护一个大小为100的最小堆</p><p>先把前100个数建堆，之后每读到一个新数 x：若 x &gt; heap_min，弹出堆顶并压入 x；否则丢弃。扫描完毕，堆中即为最大的100个；如需从大到小输出，再做一次 O(k log k) 的排序即可。</p><p>时间复杂度：O(n log k)（这里 log 100 很小，常数低，单次比较少）。</p><p>空间复杂度：O(k)。</p><p><strong>优点</strong>：一次遍历、可在线处理、适合数据在磁盘/流式来源、实现简单且稳定。</p><h3 id="_2-内存足够一次装下数据-选择算法-quickselect" tabindex="-1"><a class="header-anchor" href="#_2-内存足够一次装下数据-选择算法-quickselect"><span>（2）内存足够一次装下数据：选择算法（Quickselect）</span></a></h3>',10)),n("p",null,[e[1]||(e[1]=n("strong",null,"值得一提的是，C++中std::nth_element也是基于Quickselect实现的。",-1)),e[2]||(e[2]=l(" 详见")),a(p,{to:"/nth_element%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"},{default:r(()=>e[0]||(e[0]=[l("GPT的分析")])),_:1})]),e[4]||(e[4]=t('<p><strong>思路</strong>：找出第100大的“阈值”t，使得 ≥t 的恰好100个（含重复）。</p><ul><li><p>用 Quickselect 在平均 O(n) 时间内把数组划分为“≥t”和“&lt;t”的两部分。</p></li><li><p>取“≥t”的前100个，再 O(k log k) 排序输出。</p></li></ul><p><strong>复杂度</strong>：</p><ul><li><p>平均时间 O(n)；最坏 O(n^2)（可用 BFPRT/Median-of-Medians 将最坏收敛到 O(n)，但常数大、实现复杂）。</p></li><li><p>空间：原地 O(1) 额外空间。</p></li></ul><p><strong>优点</strong>：一次性内存足够时，理论更优；缺点是实现难度与最坏情况风险。</p><h3 id="_3-外部存储-分布式-分块-top-k-归并" tabindex="-1"><a class="header-anchor" href="#_3-外部存储-分布式-分块-top-k-归并"><span>（3）外部存储/分布式：分块 Top-k + 归并</span></a></h3><p><strong>单机外存</strong>（数据在多文件/磁盘上）：</p><ul><li><p>把数据按块读取（如每块装内存的 1/10~1/50），对每块用“最小堆法”求局部 top-100。</p></li><li><p>将所有块的候选（块数×100，数量远小于 n）再用一次“最小堆法”或排序得到全局 top-100。</p></li></ul><p><strong>MapReduce(如Hadoop)/分布式</strong>：</p><ul><li><p><strong>Mapper</strong>：对分片做局部 top-100 输出。</p></li><li><p><strong>Reducer</strong>：对所有候选合并为全局 top-100。 复杂度：每块 O(m log k)，合并 O((B·k) log k)（B为块/分片数）。I/O 友好，工程可落地。</p></li></ul><h3 id="_4-值域已知且较小-桶计数-直方图" tabindex="-1"><a class="header-anchor" href="#_4-值域已知且较小-桶计数-直方图"><span>（4）值域已知且较小：桶计数/直方图</span></a></h3><p>若数值是非负整数且值域 R 不大（如 ≤1e7）：</p><ul><li>计数排序思路建立频次数组 cnt[0..R]，自大到小累计直到覆盖100个元素，输出对应的值（处理重复频次）。</li></ul><p>复杂度：O(n + R)；对大值域或浮点数不适用。</p><h3 id="_5-并行化实现要点" tabindex="-1"><a class="header-anchor" href="#_5-并行化实现要点"><span>（5）并行化实现要点</span></a></h3><ul><li><p><strong>多线程</strong>：每线程处理一段数据，维护本地最小堆（无锁），最后把所有线程的候选（线程数×k）在主线程再合并一次。</p></li><li><p><strong>NUMA/缓存友好</strong>：分块处理、减少跨核共享；堆操作集中在小内存块，命中率高。</p></li><li><p><strong>避免假共享</strong>：多线程输出的统计/结果结构体要按 64B cache line <strong>填充对齐</strong>，别把多个线程的计数写到同一行。</p></li><li><p><strong>GPU</strong>：常用做全局选择/分段排序（如 radix select + top-k 归并），工程复杂度更高。</p></li></ul>',16))])}const k=o(c,[["render",h],["__file","interview.html.vue"]]),_=JSON.parse(`{"path":"/posts/interview.html","title":"面试真题整理","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-08-04T00:00:00.000Z","description":"面试真题整理 1. 一亿个数选出最大的100个 多方面考虑，全面回答 （1）流式/内存受限：固定大小最小堆 维护一个大小为100的最小堆 先把前100个数建堆，之后每读到一个新数 x：若 x > heap_min，弹出堆顶并压入 x；否则丢弃。扫描完毕，堆中即为最大的100个；如需从大到小输出，再做一次 O(k log k) 的排序即可。 时间复杂度：...","head":[["meta",{"property":"og:url","content":"https://iXanadu13.github.io/posts/interview.html"}],["meta",{"property":"og:site_name","content":"Xanadu13's Blog"}],["meta",{"property":"og:title","content":"面试真题整理"}],["meta",{"property":"og:description","content":"面试真题整理 1. 一亿个数选出最大的100个 多方面考虑，全面回答 （1）流式/内存受限：固定大小最小堆 维护一个大小为100的最小堆 先把前100个数建堆，之后每读到一个新数 x：若 x > heap_min，弹出堆顶并压入 x；否则丢弃。扫描完毕，堆中即为最大的100个；如需从大到小输出，再做一次 O(k log k) 的排序即可。 时间复杂度：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-09T09:28:40.000Z"}],["meta",{"property":"article:published_time","content":"2025-08-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-09T09:28:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试真题整理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-08-04T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-09T09:28:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Xanadu13\\",\\"url\\":\\"https://github.com/iXanadu13\\"}]}"]]},"headers":[{"level":2,"title":"1. 一亿个数选出最大的100个","slug":"_1-一亿个数选出最大的100个","link":"#_1-一亿个数选出最大的100个","children":[{"level":3,"title":"（1）流式/内存受限：固定大小最小堆","slug":"_1-流式-内存受限-固定大小最小堆","link":"#_1-流式-内存受限-固定大小最小堆","children":[]},{"level":3,"title":"（2）内存足够一次装下数据：选择算法（Quickselect）","slug":"_2-内存足够一次装下数据-选择算法-quickselect","link":"#_2-内存足够一次装下数据-选择算法-quickselect","children":[]},{"level":3,"title":"（3）外部存储/分布式：分块 Top-k + 归并","slug":"_3-外部存储-分布式-分块-top-k-归并","link":"#_3-外部存储-分布式-分块-top-k-归并","children":[]},{"level":3,"title":"（4）值域已知且较小：桶计数/直方图","slug":"_4-值域已知且较小-桶计数-直方图","link":"#_4-值域已知且较小-桶计数-直方图","children":[]},{"level":3,"title":"（5）并行化实现要点","slug":"_5-并行化实现要点","link":"#_5-并行化实现要点","children":[]}]}],"git":{"createdTime":1754311591000,"updatedTime":1754731720000,"contributors":[{"name":"Xanadu13","email":"xanadu13@qq.com","commits":3}]},"readingTime":{"minutes":2.54,"words":763},"filePathRelative":"posts/interview.md","localizedDate":"2025年8月4日","excerpt":"\\n<h2>1. 一亿个数选出最大的100个</h2>\\n<p><em>多方面考虑，全面回答</em></p>\\n<h3>（1）流式/内存受限：固定大小最小堆</h3>\\n<p>维护一个大小为100的最小堆</p>\\n<p>先把前100个数建堆，之后每读到一个新数 x：若 x &gt; heap_min，弹出堆顶并压入 x；否则丢弃。扫描完毕，堆中即为最大的100个；如需从大到小输出，再做一次 O(k log k) 的排序即可。</p>\\n<p>时间复杂度：O(n log k)（这里 log 100 很小，常数低，单次比较少）。</p>\\n<p>空间复杂度：O(k)。</p>\\n<p><strong>优点</strong>：一次遍历、可在线处理、适合数据在磁盘/流式来源、实现简单且稳定。</p>","autoDesc":true}`);export{k as comp,_ as data};
