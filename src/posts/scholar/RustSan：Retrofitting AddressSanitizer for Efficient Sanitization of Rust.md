---
icon: pen-to-square
date: 2025-10-15
category:
  - Rust
---

# RustSan: Retrofitting AddressSanitizer for Efficient Sanitization of Rust

论文收录于第33届 USENIX Security Symposium（USENIX Security ’24，CCF A） 的会议论文集，链接：[https://www.usenix.org/conference/usenixsecurity24/presentation/cho-kyuwon](https://www.usenix.org/conference/usenixsecurity24/presentation/cho-kyuwon)。

## 摘要

Rust 正在作为一种安全的系统编程语言迅速普及，凭借其强类型与内存安全保证而受到关注。然而，Rust 的保障并非牢不可破。使用 *unsafe Rust*（Rust 的一个子变体）时，程序员可以暂时跳出 Rust 严格的语言语义，以安全换取灵活性；但 `unsafe` 代码块中的内存错误会对程序安全造成深远影响。因此，传统的动态内存错误检测（如模糊测试 *fuzzing*）已成为 Rust 生态中的常见实践，并通过不断披露的 CVE 战果证明了其有效性。

**RustSan** 是对 AddressSanitizer（ASan）的“改造式”设计，用于高效检测 Rust 程序中的动态内存错误。我们的观察是：将 ASan 编译插桩到 Rust 程序后，许多被插桩的内存访问点在 Rust 语义保证下实际上是**冗余**的，即这些位置的内存安全在语义上仍然成立。RustSan 的做法是：识别并仅对那些**必然**或**可能**破坏 Rust 安全保证的位置进行插桩，同时在**安全位置**移除插桩。为此，RustSan 采用跨 IR 的程序分析，以精确追踪 `unsafe` 位置，并扩展了 ASan 的影子内存方案，用于检查 Rust 所需的**非均匀内存访问**（non-uniform memory access）验证机制。我们在 57 个 Rust crate 上，对 RustSan 的检测能力与性能进行了全面评估。RustSan 成功检测出 31 个实际 CVE 案例中的**全部**内存错误。在通用基准中（20 个 crate），相较 ASan，RustSan 的性能平均**提升 62.3%**。在对 6 个 crate 的模糊测试实验中，RustSan 的平均性能**提升 23.52%**，最高可达**57.08%**。

---

## 1. 引言

Rust 作为一种实用的**安全**系统编程语言正日益受到欢迎。它通过严格的**编译期规则**与轻量的**运行期检查**来保证内存安全。许多新项目已将 Rust 作为主要编程语言（例如文献 [2, 4–8, 17, 21, 41]）。此外，Linux 内核中对 Rust 基础设施的纳入 [2] 也是 Rust 持续被广泛采纳的里程碑事件。

然而，这些安全保证并非没有代价。Rust 通过施加严格的语言语义，要求程序员与之“合作”。借此，语言设计与程序员共同产出能够被编译器与最小化运行时检查所验证的代码。Rust 的安全模型在某些需要精细化掌控的场景里可能过于严格。为此，Rust 提供了一个变体 **unsafe Rust**，它存在于使用 `unsafe` 关键字声明的代码块中。与在 Rust 中被禁止的行为相比（例如原始指针访问、绕过严格的所有权检查 [9]），`unsafe` 允许不受限制地访问这些语言语义。在某些程序中（例如与低层组件交互），或当程序员为了灵活性而选择以安全换取效率时，使用 `unsafe` 往往是不可避免的。

先前的研究已经考察了在 Rust 中使用 `unsafe` 的常见实践，以及在 Rust 程序中使用 `unsafe` 的影响 [22, 56]。这些工作发现：在 Rust 程序中，几乎**所有**内存错误都源自 `unsafe Rust` 的使用 [56]。作为回应，研究者提出了用于发现 Rust 内存错误的**静态分析**方法 [14, 26, 36, 37]，以及在运行时将**安全 Rust**与**不安全 Rust**隔离的方案 [15, 31, 33, 38, 45]。

静态分析方法在检测**高度复杂的缺陷**或**仅在运行时暴露**的问题方面能力有限。运行时隔离框架为识别 Rust 程序中不安全的子程序集合、以保护安全 Rust 部分奠定了基础。运行时隔离是**遏制影响**而非**直接检测**来自 `unsafe Rust` 的内存错误。此外，已有隔离方案往往依赖硬件特性（例如 Memory Protection Key，MPK）[15, 31]，从而阻碍了可移植性。随着“安全语言”兴起，人们正努力改造既有技术以在 Rust 中实现动态检测。但据我们所知，**专为 Rust 设计**且**可移植**的动态内存错误检测工具（即 **sanitizers**）仍然缺乏。

事实上，Rust 社区已经广泛采用 **fuzzing** 来测试 Rust，并报告了大量 Rust 程序的内存安全漏洞 [1, 3, 13]。Rust 编译器通过编译选项支持用 **AddressSanitizer (ASan)** 与其他 sanitizer 编译 Rust 程序 [3]。不幸的是，现有的动态测试实践与基础设施是从**不安全语言**（如 C/C++）沿袭而来，并**未充分考虑** Rust 内存错误的特殊性质。

ASan [24, 47] 由于其良好的**检测能力**与**可移植性**，已经成为动态内存错误检测的事实标准。然而，它的**运行时开销**与**内存开销**众所周知地较高。既有研究尝试改进 ASan 的运行时与内存负担 [27, 59, 60]。其中，优化 sanitizer 的**元数据**已被证明能显著降低包括 ASan 在内的运行时开销 [27]。更近的工作表明：**消除**强加在内存访问点上的**冗余**sanitizer 检查，是优化 ASan 的一个有前景方向 [59, 60]。

ASan 与其他 sanitizers 是为 C/C++ 等**不安全语言**而设计的，默认假定**程序各处**都可能存在内存错误。然而，即便与其“不安全邻居”比邻而居，Rust 程序中依然有**大量代码**保持着语言级的**安全保证** [15, 31, 38]。这意味着：我们有机会在**不牺牲检测能力**的前提下，显著减少 ASan 在 Rust 程序上的运行时开销。

---

我们提出 **RustSan**：一种对 ASan 的“改造式”设计，充分利用 Rust 程序的独特性质——**绝大多数内存访问**仍然遵守语言的**安全保证**。RustSan 能**精确识别**内存对象与内存访问点的安全性，从而在**安全的访问点**上消除代价高昂的运行时检查。

RustSan 的**跨 IR 分析（cross-IR）**是其关键设计之一：它在 Rust 的**高阶 IR（HIR）**与**中阶 IR（MIR）**层面引入细粒度分析。我们的发现是：诸如 `unsafe` 之类的 Rust 语义**并不会**被充分传播到后端的 **LLVM IR** 层。这要求我们发展**Rust 专属**的分析技术。更重要的是，正如我们的分析所展示的，**仔细审视** Rust 的多级 IR 能提升精度，并减少后续分析阶段的复杂性。

基于上述安全信息，RustSan 在**影子内存**方案上扩展了 ASan，支持**选择性插桩（selective instrumentation）**与**非均匀内存访问**的校验。RustSan 在**安全位置**移除影子内存检查，同时对**具有不同安全级别**的内存访问点执行适当的验证。

我们对 RustSan 进行了**广泛评估**，涵盖共计 **57** 个 Rust crate。通过复现 **31** 个由 CVE 披露的内存错误，我们验证了：即使移除了大量**冗余**sanitizer 检查，RustSan 仍**保持** ASan 的检测能力。同时，我们在 **18** 个通用 Rust 程序的基准上测量了 RustSan 的性能：相对 ASan，平均**提升 62.3%**。在**模糊测试**场景中，RustSan 的平均性能提升**23.52%**，最高可达**57.08%**。

**总之，我们的贡献概括如下：**
- 提出一种**改造式 ASan 设计**：通过**选择性插桩**显著降低 Rust 程序的运行时 sanitizer 开销。
- 融合**跨 IR 的静态分析**：精确识别 Rust 中的 `unsafe` 代码块及其**数据流传播**。
- **改造** ASan 的影子内存方案：支持**选择性插桩**，并为**安全 Rust**与**不安全 Rust**提供**非均匀内存校验**模型。
- 对 **57** 个 Rust crate 进行**全面评估**：验证检测能力、可扩展性与性能改进。
- **开源发布** RustSan，希望促进社区采用，从而高效开展 Rust 程序的动态测试。

## 2. 背景（Background）

本节我们简要说明理解本文所需的关键概念。

### 2.1 AddressSanitizer

ASan [24, 47] 是一种通用的内存错误检测器，因其与主流编译器良好的兼容性与可用性而被广泛采用。值得注意的是，ASan 在许多动态测试场景（包括模糊测试 fuzzing）中，已成为事实上的标准化 **sanitizer** 组件。

ASan 通过维护一片**影子内存**（shadow memory）来表示进程虚拟地址空间中各字节地址的有效性，以此提供内存安全。影子内存的每个字节都可以编码成所谓的 **redzone** 值，用来把相应的内存地址标记为**不可访问**（invalid）。ASan 在影子内存里编码了多种 redzone 值，以区分不同类型的错误。当检测到一次对带有**非零**影子值（例如 `0xfd`）的 redzone 的非法访问时，ASan 会用该 redzone 值去索引一个**预定义表**（包含根因信息），并据此生成报告。凡是用 ASan 编译的程序中出现的**所有内存访问指令**，在执行之前都要通过查询影子内存来完成校验。

ASan 通过在对象的**前后**插入 redzones 来检测对象上的**空间（spatial）内存安全**违规。这样，所有**越界访问**都会在 sanitizer 检查里被发现，因为这些检查会查询影子内存。ASan 还会在堆对象（use-after-free）以及可选的栈对象上检测**时间（temporal）内存安全**违规。通过用 redzones 标记对象的地址范围，该对象会在影子内存中被**作废**（invalidated）。例如，ASan 会对**最近释放**的一组堆对象维持一片**隔离区**（quarantined set），方式是在这些对象上打 redzone 标记，以捕获**释放后使用**（use-after-free）。

### 2.2 Rust 的安全模型（Rust safety model）

Rust 通过其**所有权（ownership）**模型来提供内存安全。在该模型下，Rust 编译器在**静态**层面强制每个内存对象**恰好**隶属于**一个**拥有者变量（owner）。当某个变量离开作用域时，编译器会**自动插入**释放其所拥有内存对象的代码，从而让程序员摆脱显式内存管理的负担。

然而，这样的所有权模型对一些通用程序来说可能**过于严格**。为支持更灵活的编程范式，Rust 还支持对内存对象进行**借用（borrowing）**，以便在**无所有权**的前提下访问资源。为了安全地启用借用，Rust 为资源关联**生命周期（lifetime）**，并引入 **借用检查器（borrow checker）** 以保证被借用的引用不会活得比其底层资源更久。

**不安全 Rust 与 Rust 的安全保证。** Rust 提供了一个以 `unsafe` 关键字标示的**不安全子语言**，用于在**暂时**绕过其严格的所有权模型时使用。正如既有研究所报道的那样 [22]，`unsafe Rust` 在实践中相当普遍，我们的评测对象中也能见到这种情况。需要强调的是，`unsafe` 的**不安全性并不局限**于 `unsafe` 代码块的边界之内；事实上，在 `unsafe` 块里发生交互的对象会沿着**数据流路径**被传播到代码块之外，从而**危及**原本对**安全 Rust**所作的安全假设 [15, 31, 38]。位于 `unsafe` 内部的**被破坏对象**可能会被安全 Rust 消费，并**诱使**安全 Rust 产生内存错误。因此，即便某些内存访问点位于**安全 Rust**（即不在 `unsafe` 块内），它们也可能被**转化为不安全**。

**在运行时隔离不安全 Rust。** 既有工作提出了运行时隔离方案，用于把安全 Rust 从 `unsafe` 带来的内存不安全中**保护**起来 [10, 15, 31, 33, 38, 45]。这一任务不仅要**约束** `unsafe` 代码块本身的操作，还要处理由于**越界传播的受损对象**在安全 Rust 中被使用而**可能发生的漏洞** [15, 38]。

## 3. RUSTSAN 概览

**图1** 展示了 **RustSan** 的整体框架。本文这一节将先介绍后续用于描述 RustSan 设计所需的概念与术语（见 §3.1），随后给出 **编译期**（§3.2）与 **运行期**（§3.3）两部分操作流程的总览。

![](/assets/images/scholar/RustSan/figure1.png)

### 3.1 定义与内存校验模型

本小节介绍贯穿全文的术语体系，用以描述 **RustSan** 的设计。

**对象（objects）与访问点（access sites）。** RustSan 在**影子内存（shadow memory）**中维护**内存对象**的有效性状态。程序中的内存访问指令（即 *load* 与 *store*）会被插桩，在执行前查询影子内存以进行有效性校验。我们将这些插桩指令统称为**访问点**（*access sites*，简称 **sites**）。

**对象的安全性。** 我们与既有工作 [15, 38] 一样，区分**安全对象**与**不安全对象**：当某个对象在 `unsafe` 代码块内被**修改**时，它会成为**不安全传播的源（source）**。所有经由该不安全源沿**数据流**受到影响的对象，均被视为**不安全对象**。**安全对象**含义不言自明——凡**非不安全**者皆为安全对象。RustSan 还定义了另一类与对象安全性相关的概念，称为**重叠对象（overlapping objects）**。在介绍其他相关概念之后，我们会再回到这一概念。

**访问点的安全性。** 访问点是否安全由其**可能访问到的对象**决定。举例来说，**安全访问点**按定义应当在**任何控制流路径**下都**只能**访问到**安全对象**。**不安全访问点**是指**位于 `unsafe` 代码块内部**的访问点。我们用术语 **伪安全访问点（false-safe site）** 表示**位于安全 Rust 中、但可能会访问到不安全对象**的那些访问点。更具体地说，若某访问点**不在** `unsafe` 代码块内，但**在运行时可能访问到不安全对象**，则它是伪安全的。

**重叠对象（overlapping objects）。** 可借助 **points-to** 关系 [11] 来解释。当一个**伪安全访问点**在运行时**既可能**访问到安全对象**又可能**访问到不安全对象时，凡**可能被该访问点指向**的所有对象构成其 **may-point-to** 集合。我们将**属于该 may-point-to 集合中的安全对象**定义为**重叠对象**（它们与不安全对象同属一个 may-point-to 集）。这种对象安全性的划分在 RustSan 的**内存校验模型**与其**影子内存方案**中具有重要意义；在后文展开程序分析时我们还会再次讨论它。

**访问点的内存校验模型。** 在**移除安全访问点**上的 sanitizer 检查的同时，RustSan 会对**剩余的**不安全与伪安全**内存访问点**实施**分离的访问校验**；这些校验与 ASan 基于 redzone 的**越界**错误检查**并行存在**。RustSan 会检测**来自不安全访问点**对**安全对象**的**一切访问**——注意，按定义且经离线分析识别，**安全对象本不应从不安全访问点可达**。对于**伪安全访问点**，RustSan **只允许**访问两类对象：1）**重叠对象**（安全对象的一个子集），以及 2）**不安全对象**。

**`unsafe` 关键字 与 “unsafe”。** 在阐明了访问点与对象的（不）安全性之后，我们再强调本文术语中的区分：当我们指 **Rust** 的关键字 `unsafe` 时，始终写作 **`unsafe`**（加粗并打字机体）；而 **“unsafe”**（不加代码体）一词用于**一般意义**，指**可能被破坏**、并且**在任意访问点都可能被访问**的对象。

### 3.2 跨 IR 分析（Cross-IR analysis）

RustSan 的第一项任务，是依据前述定义为**对象**与**访问点**划分安全性。为此，RustSan 实现了一个**细粒度分析**，以提取**仅存在于 Rust IR（HIR 与 MIR）**中的信息。其中之一是：位于 `unsafe` 块中的**会修改内存的语句**。这些语句在后续的 LLVM IR 分析中，会被作为**不安全性的源（source）**，用于判定对象与访问点的安全性（图 1 中的 **①**）。向 LLVM IR 阶段提供越**细粒度**的信息，可使该阶段的分析更加高效。下一类关键信息是：**Rust 特有的分配函数**；我们的 LLVM IR 分析需要识别它们，才能**可靠追踪堆分配点**（**②**）。

更具象的分析与插桩发生在**LLVM IR 编译阶段**。在 LLVM 中，RustSan 采用依赖 **Value-Flow Graph** [50] 的 **points-to 分析** [11]，以**迭代地**确定对象与访问点的安全性；其起点是前一阶段 MIR/HIR 分析中提炼出的**源（sources）**（**③**）。同时，RustSan 还通过**分配点识别方案**跟踪 Rust 的分配位置，使其在插桩中能够**可靠地重载堆对象的分配**（**④**）。

---

### 3.3 RustSan 的影子内存方案（RustSan shadow memory scheme）

编译期分析得到的信息与能力，随后会在 RustSan 的**影子内存方案**中被物化为**影子内存管理**与**插桩**。RustSan 将其**非均匀访问校验模型**改造并嵌入 ASan 的影子内存机制之中，从而为被分类为**安全**、**不安全**与**伪安全**的访问点，强制执行**不同的内存视图（memory views）**。

RustSan 首先引入一种**分配器重载（allocator overriding）**方案：在影子内存中对**安全对象**与**不安全/重叠对象**进行上色（coloring）。做法是：将**不安全对象**与**重叠对象**的**堆内存分配点**替换为 RustSan 的**分配器封装（allocator wrappers）**（图 1 的 **⑤**）。

随后，RustSan 基于其跨 IR 分析得到的**访问点安全信息**，**扩展**了 ASan 的插桩方案：对被判定为**安全**的内存访问点**移除 ASan 插桩**；而对**不安全**与**伪安全**的访问点，则**插桩**以在访问前查询影子内存，获取被访问对象的安全性，从而落实其**感知安全性的内存校验模型**（**⑥**）。

## 4. 跨 IR：Rust 的 HIR/MIR 分析

**RustSan** 在 Rust 的 **HIR/MIR** 层实现了细粒度分析，使对 Rust 特有信息的分析更加**准确**且**高效**。已有工作 [15, 38] 也使用了 MIR，但它们大多仅将 **`unsafe` 块内的所有语句**统一打标并一路传播到 **LLVM IR**。我们的发现是：Rust 的 `unsafe` 语义**并不能**很好地传播到 LLVM IR。`unsafe` 是一种供 **HIR/MIR** 编译阶段消费的语言语义，最终生成的 LLVM IR **并不携带**这类信息；同时，与 `unsafe` HIR 语句相对应的 LLVM IR 指令在多轮变换后**难以区分**。此外，若在 HIR/MIR 层进行**预分析**，某些分析还能变得更高效。

因此，我们在 HIR/MIR 层必须识别如下四类**关键信息**（information）：

- **I1**：`unsafe` 块中的**内存访问语句**
- **I2**：`unsafe` 块中的**内存修改语句**
- **I3**：**分配堆内存**的 Rust 函数
- **I4**：**可能**分配堆内存的 Rust 特有方法

若不在此阶段收集，上述信息在后续的翻译或编译中**可能丢失**，也会让后续阶段的分析更加复杂。**I1** 将用于**访问点安全性分类**时定位内存访问点，并最终用于在 RustSan 的影子内存方案中实施**选择性插桩**（见 §3.1）。**I2** 是**不安全对象的“出生地”**：凡在 `unsafe` 中至少被修改过一次的对象，都被视作不安全，这些语句也就构成了**不安全传播的源**。因此，对**内存修改语句**与其超集（**I1**）做精细区分，能够减少对对象**过度着色**（overtainting）。**I3** 与 **I4** 则是后续 LLVM 分析**准确识别堆分配点**所必需的信息。

在提取这些信息的过程中，RustSan 的 HIR/MIR 分析器引入了三项新技术：
1) **语句级内存访问跟踪**（Statement-level memory accesses tracking），  
2) **递归安全作用域分析**（Recursive safety scope analysis），  
3) **分配函数识别**（Allocation function identification）。  

下面详细说明 RustSan 的分析流程。

---

### 4.1 背景：Rust 的 HIR/MIR

Rust 前端编译器 **rustc** 在内部使用两种 IR：**HIR** 与 **MIR**。`unsafe` 块**只能**在 **HIR** 层被识别；一旦代码被翻译到 MIR，`unsafe` 的边界就**不可见**。因此，RustSan 使用 **HIR** 来提取与 `unsafe` 块相关的信息；而在更细粒度的**语句级分析**上，则使用对分析更友好的 **MIR**。另外，MIR 与 HIR 之间存在**一一映射**，从而允许我们在分析 MIR 语句时**回查**其对应的 HIR 以获取 HIR 专属信息。

---

### 4.2 语句级内存访问跟踪（Statement-level memory access tracking）

RustSan 实现了**语句级分析**来精确跟踪内存访问语句（**I1**），并从中进一步提炼出**写入语句**（**I2**）。若对 **I2** 采用过度保守的近似，就会在 LLVM IR 阶段**人为扩大**不必要的不安全对象集合，并以**级联方式**增加不安全与伪安全访问点的数量。因此，即便能减少很小一部分 **I2**，对 RustSan 的性能收益也**至关重要**——其来源正是**移除了安全访问点上的检查**。

**区分写入语句。** 我们通过分析 **MIR** 语法在 **I1** 中将**写入**与**读取**区分开来。我们系统梳理了 Rust MIR 中**所有可能的“写内存”语句形式**，从而构建出 **I2**（是 **I1** 的一个**子集**）。注意：虽然我们只跟踪 `unsafe` 中的**写语句**（因为它们是不安全对象的**来源**），但对由此产生的不安全对象进行 sanitizer 检查时，**读写**都会被检测到。

**剔除严格局部写入。** 语句级分析还允许进一步缩减 **I2**。RustSan 使用 **MIR 数据流分析**来找出修改**严格局部（strictly-local）变量**的语句：这类变量从其当前不安全作用域**没有**向外的数据流边，因此可以**安全剔除**，因为它们不会污染任何安全变量。对于**修改了严格局部变量**的语句，RustSan 将该局部变量的**栈分配**标记为“分配了一个不安全对象”，并从 **I2** 中移除对应写语句，以**减轻**后续 LLVM IR 分析的负担。

---

### 4.3 递归安全作用域分析（Recursive safety scope analysis）

除了限制过度近似，我们还缓解了 MIR 分析中可能出现的一类**漏报**。在 Rust 中，**作用域（scope）**是代码块的基本单位（例如 `unsafe { ... }` 本身就是一个作用域）。我们观察到：当 MIR 级优化器在 `unsafe` 块内将**内联函数调用**包上一层内部作用域（例如插入花括号）时，`unsafe` 内部**经常出现嵌套作用域**。

回忆：一个代码块是否安全（即**是否处于 `unsafe` 内**）在 MIR 中**不可见**。因此，在 MIR 分析中判定作用域安全与否，必须通过**带作用域 ID 的回查**去查询 HIR。我们发现，若不**显式**地把作用域分析做成**递归**（即向上遍历到最外层作用域）且**感知 HIR**，则 `unsafe` 内部的嵌套作用域**可能被误判为安全**。后果是：可能**遗漏**整段**内联函数**中的**不安全内存访问语句**。既有工作 [38] 并未正确识别这些嵌套作用域，导致在 **I1** 上出现漏报。由于相关实现尚未公开，我们无法确认 **TRust** [15] 是否也存在同类问题。

> 笔者注：也就是说，需要递归将unsafe从外部作用域传递到子作用域

---

### 4.4 分配函数识别（Allocation function identification）

最后，RustSan 基于仅在 **MIR** 可用的**类型信息**提出两条 **Rust 特有的启发式**，用于识别**可能的堆分配函数/方法**：

1. **基于分配器 trait 的实现。** 若某类型实现了**分配器相关 trait**（如 `Global` 或 `bumpalo`），我们就把其实现的方法（如 `Global::alloc()`）标记为**堆分配函数**（**I3**）。后续在 LLVM 中基于 **SVF** 的 points-to 分析会使用这些信息来建模 Rust 的堆对象分配。

2. **以分配器 trait 为边界的类型。** 对于以**分配器 trait**作为**边界（bounds）**的类型（如 `Vec<T, A: Allocator>`），RustSan 将其**所有实现的方法**都视为**潜在**的堆分配方法（**I4**）。随后在 LLVM 中，我们通过检查**调用图**（§5.2）这些方法是否**实际触发**了堆分配，把这些“潜在方法”**细化**为**真实的分配方法集合**。

识别这些分配函数并将其作为**污点源**，可**降低程序分析复杂度**。此启发式避免了在 LLVM 分析中，从 Rust 层的分配函数一路追踪到**本地分配函数**（如 C 库的 `malloc`）所带来的不必要复杂度提升。

## 5. 跨 IR：LLVM IR 分析

**图2** 展示了 **RustSan** 在 **LLVM IR** 层执行的各类分析。当上一阶段的 **MIR** 已被翻译为 **LLVM IR**，并携带了前述提取的关键信息（**I1–I4**）后，RustSan 会据此识别如下信息：

![](/assets/images/scholar/RustSan/figure2.png)

- **I5**：内存**访问点**的安全性（safe / unsafe / false-safe）
- **I6**：内存**分配点**的安全性（safe / unsafe / overlapping）

以上信息用于支撑 RustSan 运行期组件对**影子内存**的管理以及对**访问点插桩**的实施。  
**I5** 使 RustSan 能按访问点的安全级别**选择性**地应用检查：对**安全**访问点**省略**插桩；而对**不安全**与**伪安全**访问点，则提供**不同的内存访问视图**（详见 §6）。  
**I6** 则用于识别所有可能被用来分配**不安全/重叠**堆对象的 Rust 分配函数（例如已得到的 **I3、I4** 集合中的函数）。这些**分配点（allocation sites）**将被替换为**包装分配函数**，以便**更新影子内存**中与对象安全信息对应的条目。

---

### 5.1 对象与访问点的分类流水线（Object and site classification pipeline）

RustSan 采用 **SVF** 中对 **Andersen 指针分析**的实现（字段敏感、上下文不敏感、流不敏感）[11]，以分类内存对象与内存访问点的安全性（**I5**）。这种“上下文不敏感、但字段敏感”的流不敏感分析在保证一定精度的同时，能**扩展到大型程序**——这是 sanitizer 的必要要求。

> 笔者注：
> - **字段敏感（field-sensitive）**：
>  把同一结构体/对象的不同字段当作**彼此独立**的内存位置来分析。
>  例：对 `struct S { A *f; B *g; }`，分析会区分 `p->f` 与 `p->g` 的指向，不会把它们混为一谈。这样能减少“不同字段被误认为可达”的假阳性。
>
> - **上下文不敏感（context-insensitive）**：
>  不区分函数在**不同调用点（调用上下文）**下的行为；一个函数只分析一次，把所有调用者的影响都合并。
>  例：`foo(x)` 被多处以不同实参调用，分析把这些调用的别名关系合在一起，可能导致保守的（过近似的）结果，但可显著提升可扩展性。
>
> - **流不敏感（flow-insensitive）**
>  忽略**程序内语句的执行顺序与控制流**，把同一变量的所有可能赋值统一考虑；等价于“把块内语句当作可任意排列”。
>  例：对
>
>  ```c
>  p = &a;
>  p = &b;
>  ```
>
>  或者相反顺序，分析都会得到 `p` 可能指向 `{&a, &b}`。这同样是保守近似，换来更快的全局解。
>
> 综合起来：**字段敏感 +（上下文、流）不敏感** 是一种常见折中：在对象内部保持较高精度（区分字段），而在跨调用与控制流层面做合并，以保证在大型程序上的可扩展性。


我们遵循 **SVF** 的内存模型 [50]：把**内存对象**按照其**分配点**建模，分配点既可以是**栈分配**（`alloca` 指令），也可以是**堆分配**（调用 **I3** 中识别的 `exchange_malloc` 等堆分配函数）。RustSan 与既有工作 [15, 38] 类似，使用**points-to** 与**数值流**分析来找出**每个内存访问点可能访问到的对象集合**（may-points-to set）。随后我们依据 §3.1 的定义利用这些 points-to 信息来对对象与访问点进行分类。细节如下：

**不安全访问点集合（Unsafe site set）。** 首先把位于 `unsafe` 中的**内存访问语句**标记为**不安全访问点**。做法是将 **I1** 中语句在 LLVM 中的等价指令加入“不安全访问点集合”。

**不安全对象集合（Unsafe object set）。** 接着识别**不安全对象**：回忆“凡在 `unsafe` 块内被**修改**的对象都是不安全对象”。由 HIR/MIR 阶段精炼得到的**写语句集合 I2** 已被翻译为一组 **LLVM IR** 指令。RustSan 在这组指令上执行 points-to 分析，找出**这些指令可能指向的内存对象**——也即**可能被 `unsafe` 修改**的对象。由此得到的对象即被归类为**不安全对象集合**。

**伪安全访问点集合（False-safe site set）。** 在这一阶段，所有**不在**“不安全访问点集合”中的访问点**暂视为安全**。RustSan 需要从中识别并分离出**伪安全访问点**：按照我们的定义，凡**不属于 `unsafe` 块**，但**会访问至少一个“不安全对象集合”中的对象**的访问点，都是**伪安全**。因此，我们对这批“暂时安全”的访问点再次执行 points-to 分析，从而得到**分离出的伪安全集合**。

**重叠对象集合（Overlapping object set）。** 最后识别**重叠对象**：它是**安全对象集合**的一个**子集**（即与“不安全对象集合”互补的那部分中的子集）。若某个对象与**至少一个伪安全访问点**之间存在**被指向（pointed-by）**关系，则把它纳入**重叠对象集合**。我们在已识别的伪安全访问点集合上**迭代执行** points-to 分析以得到该集合。  
需要注意的是，**重叠对象**与**不安全对象**共同构成**伪安全访问点**的同一组 may-points-to“住户”（tenants），因此名为 **overlapping**（“重叠”）。

### 5.2 分配点安全性的识别（Allocation site safety identification）

到这里，我们已经具备判定**分配点**安全性（**I6**）所需的信息。**RustSan** 必须识别出对象的**分配位置**，以便在后续插桩中对其进行**重载**，从而把对象的**安全信息**写入**影子内存**（§6 将解释）。Rust 通过对象的 **trait** 还表现出**间接**的堆分配行为。因此，除了直接堆分配点之外，我们还提出了一个**面向 Rust 的方法**来处理**间接堆分配点**。

**直接堆分配点。** 首先确定由 **I3** 中“堆分配函数”**直接**产生的堆内存分配点的安全性。针对这类分配点，其安全性已经在 §5.1 的分析中完成了分类。因此，我们只需要**把该分配点打上“所分配对象的安全级别”**的标记，以便后续的插桩能据此进行**重载**处理。

**间接堆分配点。** **RustSan** 还实现了一套方案来给由 **trait 方法调用**触发的**间接堆分配**进行安全性分类。我们在 **Listing 1a** 中演示了这种间接分配：第 1 行定义了一个 Rust 对象，第 4 行在 `unsafe` 中对其进行了修改。其编译后的 LLVM IR 对应代码见 **Listing 1b**；其中，第 4 行的 `Vec::set_len` 调用被分类为**不安全访问点**，而第 1 行分配的栈对象被分类为**不安全对象**。第 3 行调用 `Vec::reserve()`（一个会触发堆分配的 trait 方法），并把结果写回栈对象 `%v`。然而，**如果我们只看第 4 行实参 `%v` 的 points-to 集合**，它只包含栈对象 `%v` 本身，就**检测不到**这次堆对象分配。

![](/assets/images/scholar/RustSan/listing1.png)

为了追踪这类分配点的安全性，**RustSan** 从分析 **I4** 所识别的方法在 LLVM 中的**调用点**入手。针对这些调用点，RustSan 检查如下条件：  
1）被调用的对象方法在其**调用图**上必须能**连接到**某个**堆分配函数**（**I3**）；  
2）该方法调用中使用的**某个实参**必须**指向**一个**不安全/重叠对象**。  
若某次方法调用同时满足这两个条件，**RustSan** 便把该调用**标记为“堆分配点”**，并把“被指向的对象”的**安全级别**附着到该分配点上。利用这一启发式，RustSan 将 **Listing 1b** 的第 5 行识别为**不安全对象的间接堆分配点**。

> 笔者注：原文如此，实际是第3行，“第5行”应该为笔误

---

### 5.3 将分析技术适配到 Rust（Adapting analysis techniques to Rust）

我们的 LLVM IR 分析依赖 **SVF** [50] 的**先进**数值流（Value-Flow）分析与 **Andersen** 指针分析实现 [11]。不过，我们对 SVF 进行了若干**改动**，以便更好地兼容 Rust：

**面向 Rust 的分配函数。** 首先，我们修改 SVF，使其能**识别**我们在 HIR/MIR 分析（**I3**）中发现的**Rust 堆分配函数**。这样，SVF 就能把这些函数返回的对象指针识别为**新分配的堆对象**。

**指针操作 trait 的模拟。** 若某对象类型没有**重载**其指针运算符，那么可重载运算符实际会从 Rust 标准库的**运算符模块**（`std::ops`）中调用到**默认符号**。我们发现，只需把这些运算替换为**默认的取址/解引用语义**，就能**最小化** points-to 分析的复杂度。

**支持常用指令。** 我们为 LLVM 指令 **`ExtractValue`** 与 **`InsertValue`** 等添加了对 SVF 的**支持**。这些指令在 Rust 编译中被**大量使用**，但原版 SVF 并不识别。最近一篇工作 [15] 也提到了对 SVF 的类似改动；由于其实现发表时尚未公开，我们文中的 **SVF 修改**均为**自研实现**。

## 6. RustSan 的影子内存方案（shadow memory scheme）

RustSan 对 ASan 影子内存机制的改造，会利用编译期得到的信息（**I5、I6**），以执行**感知安全性的对象分配**与**选择性插桩**。

### 6.1 感知安全性的对象分配（Safety-aware object allocation）

RustSan 实现了**感知安全性的对象分配**：把对象的**安全信息（I6）**编码进影子内存。为达此目的，RustSan 在 ASan 的**堆内存分配器**之上做扩展，使其在管理影子内存时能够**反映对象的安全类别**。随后，RustSan 的插桩会把对象的**分配点**替换为三类之一的**分配器封装**（wrapper）：`safe`、`unsafe`、`overlapping`。这些封装会在堆分配成功后，依据**新返回的堆地址**为对应对象**更新影子内存条目**。

**分配点重载（Allocation site override）。**  
RustSan 通过 ASan 现有的方法，钩住程序默认使用的**安全分配器**。对**不安全对象**与**重叠对象**的分配点，RustSan 编译器依据 **I6** 的安全信息进行替换：从分配点出发，遍历其**调用图**，把被调用的函数**克隆**成专门用于“在某一安全级别下分配对象”的版本；例如把 `foo` 克隆为 `foo`、`foo_unsafe` 与 `foo_overlapping`。然后在调用图上以“分配点的安全级别”为依据，**替换**对应的函数调用。最后，再把调用图上出现的“堆分配调用”，统一替换为 RustSan 的**分配器封装**，以执行影子内存管理。

**影子字节方案（Shadow byte scheme）。**  
RustSan 按**对象的安全类别**为对象“着色”。**不安全对象**不着色；为了便于读者理解（见图3），我们将**安全对象**概念性地对应为**洋红色**，**重叠对象**对应为**粉色**（pinkzone）。在影子字节的**高 5 位**中，ASan 已用来表示各种 **redzone**；RustSan 选取其中的**第 4 与第 5 位**来表示**安全对象**与**重叠对象**：  

![](/assets/images/scholar/RustSan/figure3.png)

安全对象与重叠对象的影子字节形如 `0b00001aaa` 与 `0b00010aaa`，其中低 3 位 `aaa` 由 ASan 使用，用于在影子内存映射的“每 8 字节真实内存”区间内，表达**可寻址字节**的位置。

> 笔者注：低3位表示8字节空间中可寻址字节的offset

除“安全/重叠”两种着色外，我们还使用了此前未占用的两种**5 位组合**来表示**隔离（quarantined）的不安全对象**与**隔离的重叠对象**。例如，当一个**重叠对象**被释放时，会把其对象内存对应的影子字节更新为**隔离的粉色对象**。随后，我们扩展了 ASan 在检测到内存错误后调用的 `report()` 函数，使其能够报告**发生在不安全对象或重叠对象上的 use-after-free** 情况。

### 6.2 选择性插桩（Selective instrumentation）

在依据 **I5** 完成对象安全性分类之后，**RustSan** 需要按各访问点的安全级别进行插桩。通过**移除安全访问点**上代价高昂的、基于影子内存的检查，RustSan 显著降低了运行时开销。不过，对**伪安全**与**不安全**访问点，RustSan 仍会执行其**跨安全级别的内存访问校验**，同时保留 **ASan** 既有的内存错误检测功能。下面对这两点做更细致的说明。

**跨安全级别的内存访问校验（Cross-safety memory access validation）。**  
RustSan 引入一种独特的**跨安全级别**内存访问校验模型：对**伪安全**与**不安全**访问点施加**不同**的内存访问校验逻辑（见 *Listing 2*）。  

<div style="width: 100%; margin: auto; text-align: center;">
  <img src="/assets/images/scholar/RustSan/listing2.png" style="width: 70%;" />
</div>

- 对**不安全访问点**，只要影子字节值**非零**，RustSan 就报告**非法访问错误**（*Listing 2a*）。这意味着：对 **洋红色（安全对象）** 与 **粉色（重叠对象）** 的访问都会在 sanitizer 检查时被发现。  
- 另一方面，**伪安全访问点**被允许访问**粉色的重叠对象**，因此它们既可以访问**不安全对象**，也可以访问**重叠对象**（*Listing 2b*）。

由此，对**安全对象**的访问会在**不安全**与**伪安全**访问点上被检测出来。

请注意，RustSan 在伪安全访问点上的设计是**有意识的取舍**：ASan 的“基于地址”的净化方式**无法**进行**上下文敏感**的检查，因为没有可行的办法在运行时区分对象到底沿哪条数据流路径传播而来。因此，我们的设计选择是**继承 ASan 的兼容性与性能**，同时在伪安全访问点上**放宽**检测覆盖面。

**与 ASan 既有能力的互操作（Interoperability with existing ASan capabilities）。**  
RustSan 的影子内存方案在**不安全**与**伪安全**访问点上**完整保留**了 ASan 的检测能力。回顾 ASan 的检测机制：它通过两种方式利用 **redzone**——（1）在对象之间插入 redzone 以检测**越界**；（2）在对象被释放时，以 redzone **作废对象本身**。由于（1）中“对象间 redzone”与对象安全级别**无关**，因此在不安全与伪安全访问点发生的**越界**都能被检测。例如，如果一次**合法**的对象访问（如伪安全点上对重叠或不安全对象的访问）**越界**触碰到“对象末端 redzone”，该错误就会被发现并报告。

同样地，**不安全对象**与**重叠对象**也适用 ASan 基于**隔离区（quarantine）**的 **use-after-free** 检测：通过**对象作废**实现。RustSan 的堆分配器保留了 ASan 分配器的“对象作废与放入隔离区”的机制——即用 redzone 标记对象地址范围并放入隔离列表。RustSan 的一个关键增补是：利用影子字节中**未使用的位**来表示“**隔离的不安全对象**”与“**隔离的重叠对象**”（前文已述），这有助于在错误检测时**生成更丰富的报告**（同时包含访问点与对象安全级别的信息）。

> 笔者注：ASan也能检测use-after-free，只是RustSan利用影子字节中未使用的位，使检测结果更细化

## 7. 评估（Evaluation）

本节我们评估 **RustSan** 的实现。实现基于 **LLVM 13.0.0** [39] 与 **rustc 1.66.0 nightly** [46]。所有实验均在一台工作站上完成：**AMD Ryzen Threadripper 3990X**（64 核 @ 2.9GHz）、**256GB RAM**、**Ubuntu 20.04 LTS**。

我们用大规模测试集从**检测能力**、**可扩展性**与相对 **ASan** 的**性能改进**三方面评估 **RustSan**。为此，我们构建了四类 Rust 程序测试集：**CVE 复现实验集**、**可扩展性评估集**、**通用性能基准集**与**模糊测试基准集**。  
其中，**CVE 复现实验集**是一些含有一个或多个**CVE 披露的内存错误**的程序版本，并附带**确定性的输入序列**来触发这些缺陷。我们在 §7.2 中通过复现这些 CVE 来**经验性验证** RustSan 的检测能力。  
**可扩展性评估集**包含**相对较大的代码库**，我们在 §7.4 中用它评估 RustSan 的**程序分析过程**在**大型 Rust MIR 与 LLVM IR** 上的可扩展性。  
**通用性能**与**模糊测试**两套基准用于度量 RustSan 对目标程序引入的**运行时开销变化**（见 §7.6 与 §7.7）。

---

### 7.1 `unsafe` Rust 的使用统计（Unsafe Rust usage statistics）

![](/assets/images/scholar/RustSan/table1.png)

**Table 1** 展示了我们用于评估的全部 Rust crates 中，**内存访问点的出现与安全性**统计。表中给出了**所有内存访问指令**（包括**内存内建指令**）的总数。跨所有 crates 统计，**不安全访问点比例**（`unsafe` 代码块 + **伪安全**）的**平均值**为 **10.24%**。值得注意的是，那些**需要原始指针操作**（如 `linked_list`）或**处理底层数据**（如 `string`、`bytes`）的 crates，往往具有**更高比例**的 `unsafe Rust`。

这一不安全访问点比例支持了 **RustSan** 的动机与方法：**需要 sanitizer 检查**的内存访问点，最多可达**34.60%**（`vec_deque`），而最低仅**0.7%**（`uuid`）。不过，这些数字**并不直接等价于** RustSan 能**消除的运行时开销**，因为实际性能还取决于**程序执行期间实际遇到的检查次数**。关于运行时开销降低，我们在后文的 **crate 基准**（§7.6）与**模糊测试实验**（§7.7）中详细讨论。

---

### 7.2 检测能力：选择性插桩的稳健性（Detection capability: robustness of selective instrumentation）

围绕检测能力，我们对 **RustSan** 可能的**漏报（false negatives）**进行经验性验证；换言之，我们验证 **RustSan** 所**移除的检查**不会导致**漏报**。为此，我们选取了**31** 个可被 **ASan** 检出的**内存相关 CVE**，并用 **RustSan** 复现这些结果。

**CVE 测试集收集（CVE test set collection）。**  
我们从常见 Rust 程序中收集了一批可复现、且可被 **ASan** 检测的**CVE 级内存漏洞**测试用例。漏洞来源于 **RustSec Advisory Database** [55]（其中汇总了来自 **crates.io** 的 Rust 程序 CVE 报告）。我们收集了数据库中**全部 408 条** CVE，并评估其**可复现性**。在这 408 条中，依据数据库里的类别字段，我们识别出**227 条**为**内存相关漏洞**；其中 **91 条**包含**可复现漏洞的 PoC 代码**，**52 条**能被 **ASan** 成功检测。**RustSan** 同样**全部检出**了这 **52** 个案例。

> 笔者注：可以学一下怎么去找CVE

**检测结果（Detection results）。**  
**表2** 重点列出了 52 个复现案例中的 **31** 个，用以展示 **RustSan** 的**稳健性**。这些案例是通过**内联的影子内存检查**（受 RustSan 的**选择性插桩**控制）检出的。尽管 **RustSan** **大幅减少**了 Rust 程序中的影子内存检查（见 **Table 1**），但**所有 CVE 案例**都**成功检出**。另外 **21** 个未在 **Table 2** 列出的复现案例（如**双重释放**），是通过**拦截标准库调用**（例如 `free`）来检测的；这部分不受 **RustSan** 的“检查消除”影响，因而如预期般被 **RustSan** 检出。

<div style="width: 100%; margin: auto; text-align: center;">
  <img src="/assets/images/scholar/RustSan/table2.png" style="width: 50%;" />
</div>

**伪安全访问点中的内存错误（Memory errors in false-safe sites）。**  
**Table 2** 的 **FS/U\*** 列显示：31 个复现的内存错误中，有 **21 个**是**在伪安全访问点**被检测到的。我们还在 `unsafe` 内部的内存指令上**额外放置插桩**，由此识别出 **10** 个**位于 `unsafe` 内部**的案例。大量**发生在伪安全内存指令**上的错误，进一步印证了 **RustSan** 对**伪安全访问点识别**的**准确性**，以及所改造的**影子内存方案**的**正确性**。我们对这 21 个伪安全案例中的部分 CVE 做了**人工复核**；例如在**附录 A（Appendix A）**中，我们给出了一个**堆溢出**（CVE-2018-21000）与一个 **use-after-free**（CVE-2021-45713）的**代码示例**。

### 7.3 检测能力：跨安全级别的对象访问（Detection capability: cross-safety object access）

本节评估 **RustSan** 的独有能力——§6.2 所述的**对安全对象访问的检测**。我们准备了两个**合成示例**，展示来自 **unsafe** 与 **false-safe** 位置对**安全对象**进行破坏的情形（见 *Listing 3*）。

<div style="width: 100%; margin: auto; text-align: center;">
  <img src="/assets/images/scholar/RustSan/listing3.png" style="width: 70%;" />
</div>

之所以采用合成示例而不是真实漏洞，是因为真实案例往往**难以定位与复现**。许多真实世界的内存错误是通过 ASan 的**对象间 redzone（inter-object redzones）**首先被发现的。我们发现：如果一个错误发生在 **unsafe** 或 **false-safe** 访问点，并且**不触碰任何对象间 redzone**，而只是**破坏了安全对象的内容**（即**对象内部破坏，intra-object corruption**），则 ASan 往往**不会报警**，而且这样的真实案例过于**特定**、难以识别与复现。两个示例均受到真实 CVE（CVE-2017-1000430 与 CVE-2018-21000）的启发，并做了轻微改动，使攻击者可以对**安全对象**任意进行内存破坏。在 *Listing 3a* 与 *Listing 3b* 中，攻击者分别可以在 **unsafe** 与 **false-safe** 访问点处控制函数实参，使其指向**安全对象**。

这些案例**不一定**触碰 redzone，但能够只破坏**安全对象的内容**。这些示例说明了 **RustSan** 的**跨安全级别内存访问检测**：**未改造的 ASan** 无法检测到这类错误，而 **RustSan** 通过扩展 ASan，具备了检测**Rust 特有**新类别内存错误的能力。

> 笔者注：不越界，只是通过让伪安全/不安全的访问点指向安全对象，从而只破坏安全对象的内容

---

### 7.4 使用 RustSan 的编译时间（Compile time with RustSan）

我们接下来在**较大的 Rust crates** 上测量 **RustSan** 的**编译时间**，以评估其可扩展性。

**可扩展性测试集收集。**  
我们基于 crate 的**受欢迎程度**（例如 Github ★≥1 万）以及**代码规模**选择了 9 个 crate。**表3** 展示了可扩展性集合中大型程序的 **RustSan** 编译时间。

![](/assets/images/scholar/RustSan/table3.png)

**结果讨论。**  
整体而言，**RustSan** 将这些 crate 的**编译时间**提升为**原来的 19.50×**。其中 **wasmtime**（WebAssembly 解释器）产生的**整程序 LLVM IR** 最大，大小为 **2253MB**；使用 **RustSan** 的编译耗时 **29 分 56 秒**，比带插桩的**常规构建**慢 **30.45×**。第二大的是 **RustPython**，其 **LLVM IR** 为 **2127MB**、编译耗时 **1688s（28 分 8 秒）**，相当于常规构建的 **24.82×**。

> 笔者注：虽然编译时间的增长非常恐怖，但编译完的程序在跑测试时往往以天为单位跑，用较长的编译时间换取编译后程序的性能提升有一定意义。

我们认为，即便对大程序，**RustSan** 的计算复杂度仍在**可接受范围**。一个促成因素是 HIR/MIR 层的**精炼信息抽取**：与既有工作 [38] 相比，我们把**污点源数量**（将 §4 中的 **I2** 从 §4b 的规模）在实验中**降低了 12.86%**（详见**附录 B**）。

考虑到 **RustSan** 面向的典型**动态测试场景**，在测试前对目标程序用 **RustSan** 进行一次构建的**额外成本**是**可承受的**。TRust [15] 提到其处理超大程序的策略是**回退到精度较低的上下文敏感分析**；该工作在评估中以 **tokio** 与 **hyper** 作为大型程序的示例（二者也包含在我们的 **Table 3** 中）。由于其实现撰写时尚未公开，难以进行**直接对比**。然而，我们展示了 **RustSan** 可以用**可管理的编译时间**构建**更大规模**的程序。

> 笔者注：意思是比TRust好点？怎么不跟baseline ASan比，何意味？

### 7.5 微基准（Microbenchmarks）

我们针对 **RustSan** 的“感知安全性的影子内存方案”和“改造后的堆分配器”做了微基准测试。对这两个组件开销的细化观察，有助于理解随后在本节后半部分给出的通用应用与模糊测试基准结果。

**影子内存检查。**  
**RustSan** 的影子内存方案在**伪安全访问点**上引入了一步额外的**影子字节掩码**操作（见 *Listing 2b*）。因此，尽管 **RustSan** 通过**消除检查**显著提升了净化器（sanitizer）的运行性能，但其在伪安全访问点上的检查**可能**带来少量额外开销。为了测量此类“**先掩码、再分支**（mask-then-branch）”检查的**独立**开销，我们将 **nbench** [52] 编译为两个版本：一个使用**未改造的 ASan**，另一个使用**理论上的最坏情形 RustSan**。所谓最坏情形，是指 **RustSan** 在**所有**内存访问点都插入伪安全访问点那样的“mask-then-branch 检查”，并且**不**进行任何检查消除。**图4** 显示了最坏情形 **RustSan** 与未改造 **ASan** 的对比：平均而言，ASan 版本的**运行时开销**为 **2.06×**，而理论最坏情形的 **RustSan** 版本为 **2.08×**。实验表明，**伪安全访问点检查**带来的**性能开销极小**。

![](/assets/images/scholar/RustSan/figure4.png)

**堆分配器。**  
我们的基准显示：**RustSan** 的堆分配器在 **ASan** 的基础上**额外**引入了 **5.52%** 的开销。鉴于其开销很小且实验方法直观，我们将详细讨论放在**附录 C**。

---

### 7.6 通用应用中的运行时开销（Runtime overhead in general applications）

我们用各个 crate 自带的基准集（即 `cargo bench`），对比测量 **RustSan** 相对 **ASan** 在**通用 Rust 程序**中的运行时开销。

**通用应用基准集收集。**  
我们从 **Crates.io** [20] 收集了**下载量最高**的 Rust 程序，并参考了既有工作的被基准化程序 [15, 38]。我们对这些基准逐一进行**人工验证**，确保其能够**正确运行**并产生**单一数值**，便于直接比较 **RustSan** 与 **ASan** 的性能。

**基准结果。**  
**图5** 比较了 **ASan** 与 **RustSan** 的**运行时开销**：将完成基准所用的平均执行时间**归一化**到未插桩版本。结果显示，ASan 的**平均归一化执行时间**为 **2.40×**（即 **+140.3%** 开销），而 **RustSan** 为 **1.53×**（即 **+52.9%** 开销），**RustSan 平均将开销降低至 62.3%**。为验证性能提升确由“消除检查”带来，我们提出了一个指标 **sanitizer 检查命中减少率**（**Check Hit Decr. (%)**，见图 5）：该指标表示 **ASan** 运行期的**sanitizer 命中次数**中，有多少**被 RustSan 消除了**。我们确认**性能提升与该指标近似成正比**。

![](/assets/images/scholar/RustSan/figure5.png)

在各个 crate 中，**开销下降幅度最大**的是 **adler**：ASan 插桩版本的**运行速度**下降 **5.4×**，而 **RustSan** **移除了 100% 的检查**，几乎达到了**接近原生**的速度。另一方面，部分 crate 的 ASan 开销**几乎没有下降**，例如 `vec_deque` 与 `vec`。我们推测这些程序在运行时**极少遇到**不安全或伪安全访问点，因此**难以从 RustSan 的“检查移除”中获益**。

在被评测的 crates 中，**wasmtime** 与 **RustPython** 属于 Rust 生态中**最复杂且规模较大**的项目（两者也包含在我们的可扩展性集合里）。实验因此也表明：**RustSan** 在**大型 Rust 程序**上是**可行**的，更不用说其**显著的性能改进**（相对 ASan 分别提升 **64%** 与 **63%**）。

除了性能之外，这些 crates 在基准执行期间**没有出现**因 **RustSan** 导致的**误报**而引发的**程序崩溃**。

### 7.7 模糊测试（Fuzzing）

我们进一步在模糊测试场景下考察 **RustSan** 相对 **ASan** 的性能收益。

**模糊测试集收集。**  
我们从 Rust 的 trophy-case [13] 中挑选目标程序，选取**已报告缺陷数最多**且**自带 fuzzing harness** 的前六个 crate。

**性能度量。**  
与通用应用基准相同，我们分别用 **RustSan** 与 **ASan** 编译这些 crate。随后，使用 **AFL++** [23] 4.05c 版本对每个 crate 的两个版本分别进行 **24 小时**的 fuzz。我们使用各 crate 自带的 harness 与种子集。我们以**每秒执行次数（run executions per second）**这一模糊测试性能评估中被广泛接受的统计量来展示 **RustSan** 的性能增益 [23, 60]。得益于 **RustSan** 的**运行时开销降低**，在固定持续时间（24 小时）下，fuzzer 能在 **RustSan** 版本上执行**更多轮次**。

![](/assets/images/scholar/RustSan/table4.png)

**表4** 对比了 **RustSan** 与 **ASan**。首先从**每秒执行次数**看，**RustSan** 相比 **ASan** 的**平均性能提升**为 **23.52%**（记作 **Incr(%)**）。为更好地说明性能提升的来源，我们还测量了**每次执行的平均检查数（average checks per execution）**。由于 **RustSan** 的**总执行次数**通常多于 **ASan**，我们使用**平均值**而非总检查次数。各目标中，**brotli-rs** 的改善最显著（**57%**）：在运行期间，**RustSan** 每次执行大约移除了 **39 万次** sanitizer 检查，这能直接解释其性能提升。相对地，**cpp_demangle** 的整体开销下降很小（**0.87%**），尽管**检查减少率**很高（**98.37%**）。原因在于该目标的**内存访问出现次数**本就有限（**2535.67 次检查/秒**），总体开销被其它因素主导（如种子变异、进程重启等）。

**结果讨论。**  
在多个 crate 的模糊测试中（如 **brotli-rs**），**RustSan** 展现出可观的性能收益。然而，模糊测试的整体性能受多种因素影响。例如，目标程序中**load/store 指令占比**可能较低；又如，某些程序中**纯目标代码的执行时间**较短，导致 fuzzer 自身操作（进程重启、种子变异等）主导了总执行时间。在这些情况下，**RustSan** 只能在**尽量减少影子内存检查**（即 **表4** 中的 **Reduc.%**）上做出贡献。本实验的重点是在**真实场景**下展示 **RustSan** 的**独立**性能增益。我们预计 **RustSan** 还可以与其它 **ASan** 优化结合以缓解上述因素。例如 **FuZZan** [27] 优化了影子内存初始化，能直接降低 fuzzer 的进程重启时间。

**检测到的错误。**  
无论是 **ASan** 还是 **RustSan**，都**未**发现由**内存错误检测**导致的崩溃。结合这些 crate 的 harness 与文档，我们推测原因是它们**此前已被 fuzz 到一定程度**（例如已超过 24 小时），因此容易触达的缺陷大概率**已被修复**。即便如此，该结果至少说明 **RustSan** **没有**出现**误报**导致的崩溃。

## 8. 安全性与稳健性讨论

**Sanitizer**（净化器）始终是一种“尽力而为（best-effort）”的解决方案：为了实用性，它们必须在**检测覆盖率**、**可移植性**与**性能**之间权衡。就此而言，我们认为 **RustSan** 通过大量实证测试，已经展示出其作为一种**实用方案**的价值。下面我们从**稳健性视角**重新审视前文的评估，并**定性**讨论 **RustSan** 中潜在的不正确性来源。

---

### 8.1 实证验证（Empirical validation）

我们的评估不仅确认了 **RustSan** 的**性能优势**，在**测试样本数量很大**的前提下也对其效果给出了**经验性验证**。正如在 **CVE 复现实验（§7.2）**中所述，我们确认 **RustSan** 能**成功检出**全部 CVE 案例。

在所有基准测试中，**RustSan 未出现任何误报**（即不会因为检测而导致**程序崩溃**）。这些 crate 自带的基准并非用于“触发缺陷”，因此它们也可以被视作对 **RustSan** 的一次**独立稳健性测试**。回溯来看，**RustSan** 在 18 个 Rust crate 上共检查了**约 15 亿**次**内存访问点**；若其中**任意一个真正的安全访问点**被错误地标记为 **unsafe** 或 **false-safe**，就会导致**程序崩溃式的误报**，因为这类访问点随后将**无法访问安全对象**。

在模糊测试实验中，**RustSan** 在 6 个 crate 上、**24 小时**内共检查了**890 亿**次内存访问点，同样**未出现误报**。与 CVE 实验一样，模糊测试实验也可被视作**漏报**的间接验证。不过，正如我们提到的，基线 **ASan** 在该时段也未发现**此前未知**的内存错误。要在本文范围内进一步验证，还需针对**相对未被充分测试的 Rust crate**进行理解与选择，并**手工构造 fuzzing harness**，这是一项相当艰巨的工作，因而未纳入本研究。

---

### 8.2 定性分析（Qualitative analysis）

尽管 **RustSan** 在程序分析技术上**有意识地保持保守**，但对于**复杂程序分析**而言，要完全保证**完备性**与**健全性**（soundness）仍具挑战。我们借助 **表5**，系统性地讨论 **RustSan** 验证模型可能面临的问题。

![](/assets/images/scholar/RustSan/table5.png)

**（1）HIR/MIR 分析不完整。**  
情形 **MC1** 与 **MC2** 可能源自**HIR/MIR 分析不完整**。回忆定义：**unsafe 访问点**是位于 `unsafe` 代码块内部的**内存访问点**，应由 **MIR 层**来识别。若被误分，后果是：一个 **unsafe** 访问点可以**悄然破坏安全对象**（对应 **MC1**），或**破坏重叠对象**（对应 **MC2**）。这二者均会削弱 **RustSan** 的**内存验证模型**，属于**漏报**。

**（2）HIR/MIR 分析不健全。**  
相反地，**不健全**的 HIR/MIR 分析可能把**位于 `unsafe` 之外**的**安全/伪安全**访问点误判为**unsafe**（情形 **MC3、MC5**）。其中 **MC5** 会在本应**合法访问安全对象**的地方触发**误报**；此外，它还会**降低性能优势**，因为系统被迫加入**不必要的检查**。**MC3** 同样是**误报**：在 **RustSan** 的验证模型下，**伪安全**访问点应当可以访问**安全对象**；一旦被误判，它为了访问**沿着安全数据流在运行期送达**的安全对象而触发告警。

**（3）RustSan 的 HIR/MIR 分析的稳健性。**  
我们的 **MIR 分析**是**针对 `unsafe` 代码块**的**定向分析**，而这些代码块仅占 Rust 程序的**极小部分**。因此，**MIR 分析**是可以做到**完整且健全**的。进一步地，**RustSan** 在 MIR 分析中引入了**递归的作用域安全性**识别，修复了既有工作 [38] 中的一类**漏报来源**。据此，我们认为 **HIR/MIR 分析是稳健的**，相关误判应当**极为罕见**；此外，我们的**实证评估**也从侧面证明了**没有误报**。

**（4）points-to（指向关系）分析不完整。**  
**不完整的数据流/points-to 分析**可能导致 **MC4**：分析器**遗漏**了“访问点 ↔ 不安全对象”之间的指向关系。结果是：某个**必须只能访问重叠/不安全对象**的**伪安全访问点**被**错误地“证明”为安全，绕过了检查**。此时 **RustSan** 将**无法感知**该访问点对**安全对象**的破坏——这是**漏报**。

**（5）points-to 分析不健全。**  
**不健全的 points-to 分析**可能导致 **MC6**：把真实的**安全访问点**误分为**伪安全访问点**。与 **MC5** 类似，这会引发**误报**并因**不必要的检查**而**降低性能**。

**（6）points-to 分析的稳健性。**  
**RustSan** 采用了**先进的程序分析工具** [50]，该工具已在**软件安全**领域被广泛使用 [15, 18, 28–30, 38, 44]。我们的评估显示，**MC6-型误报**应当**罕见**。不过，**MC4 的风险**仍然存在，因为 points-to 工具是一个**外部依赖**；尽管如此，基于其在该领域的**广泛实践**，我们仍认为该工具**总体可靠**。

## 9. 相关工作（Related Work）

### 9.1 面向内存缺陷检测的 Sanitizer

Sanitizer 长期以来被用于检测以**不安全内存语言**编写的程序中的缺陷，用以发现各种**内存错误** [12, 34, 40, 42, 47-49, 53, 58]。其中既包括**空间类**内存错误的净化（sanitization）[12, 19, 40, 42, 47, 54]，也包括**时间类**内存错误的净化 [34, 47, 53, 58]；在程序动态测试领域已有多种成熟的替代方案。

在众多设计中，**ASan** [24, 47] 是**最为广泛使用**并**集成进主流编译器**的 sanitizer，得益于其**轻量的影子内存检查机制**与**高度兼容性** [48]。**RustSan** 的目标，是在保留 ASan 的可移植性与兼容性的前提下，**为 Rust “改造”ASan**，通过**消除冗余检查**来提升性能。

---

### 9.2 面向性能的 Sanitizer 优化

Sanitizer 往往带来**很高的运行时开销**，因此已有大量工作尝试对其进行优化。

**消除 sanitizer 检查。**  
识别并删除**冗余检查**是一条降低开销的重要路径 [16, 25, 32, 43, 51, 60]。不少研究通过**精确的静态分析**定位并移除不必要的检查，同时**不牺牲检测覆盖率**。例如 **SANRAZOR** [59] 结合**动态代码覆盖率**与**静态数据依赖**来发现冗余检查；**ASan--** [60] 则采用**轻量静态分析**来检测/移除**重复性**检查，并优化 sanitizer 检查。这些工作大多面向 ASan 的**典型目标**（如 C/C++ 程序）进行优化。与之相对，**RustSan** 指出了 ASan 在**部分不安全**（partially-unsafe）的 Rust 程序上的**低效**，并给出了解决方案。

**做性能—检测权衡。**  
也有工作提出在既定的**性能预算**下，对“检测能力与性能”进行**权衡**。例如 **ASAP** [47] 对目标程序做 profile，找出移除检查后**收益最大的热区**；**SANRAZOR** [59] 提供可配置的**多档位权衡**。与这些工作不同，**RustSan** **保留**了 ASan 的检测能力，同时**新增**了**Rust 特定的安全对象保护**。

**优化 sanitizer 运行期。**  
另一些工作直接优化 sanitizer 的**运行时机制**，使其更适配特定负载（如 fuzzing）。**Fuzzan** [27] 为 redzone 管理设计了**高效元数据**，加速了“ASan+fuzzing”；**PartiSan** [35] 将应用划分为**带净化**与**不带净化**的切片，使后者**不承受额外开销**；**Bunshin** [57] 则在**并行运行**的程序间**分摊**sanitizer 检查。我们预计 **RustSan** 可以与这些技术**组合**，进一步优化其性能。

---

### 9.3 Rust 程序加固

**用于加固 Rust 的静态分析。**  
已有静态分析器被用于检测 **unsafe Rust** 中的缺陷。例如 **Rudra** [14] 在 Rust 的 MIR/HIR 上引入了**可扩展静态分析**来寻找特定模式的漏洞；**MirChecker** [37] 结合**数值分析**与 **MIR 符号执行**以检测**运行期 panic**与**内存错误**；**Rupair** [26] 可在 `unsafe` 代码中**自动检测越界**并用 MIR 上的**轻量数据流分析**修复。**RustSan** 同样利用 HIR/MIR 分析，但进一步做了**更细粒度的信息提取**（面向 `unsafe` 代码块的语句级分析）。静态/动态测试各有优劣，具体适用取决于场景；与这些工作不同，**RustSan** 是**运行期**的 sanitizer（例如可在 fuzzing 期间发现内存错误）。

**Rust 程序的运行期隔离。**  
有大量工作提出了**运行时隔离**机制，以**约束**（contain）由 `unsafe` 代码块与**不安全外部库**触发的内存错误带来的影响。**XRust** [38] 与 **TRust** [15] 引入了**分离的内存分配器方案**：将被 `unsafe` 触及的对象放入**不安全堆**；同时，它们还提供**定制插桩框架**，用以**隔离**会受不安全对象影响的**安全内存指令**（即本论文 §3.1 所述的 *false-safe*）。此外，也有研究探索基于 **MPK（Memory Protection Key）** 的隔离，用于限制 C 库的内存访问 [15, 31, 45]；例如 **PKRUSafe** [31] 通过**动态剖析**自动识别在 Rust 与 C 间共享的对象，并用 MPK 隔离对这些对象的访问。

这些用于识别 Rust 程序指令与对象安全性的**静态分析方法** [15, 38] 启发了 **RustSan**；而 **RustSan** 则在 MIR 中把它们**细化到语句级**。另一方面，**RustSan** 作为一个 sanitizer，需要**在错误发生时**检测出来。它**有意识地继承**了 ASan 的**兼容性**与**可移植性**：一个明确的设计选择是**避免**依赖**体系结构特定**的特性（如 MPK）。此外，它也**避免**了如 **上下文敏感 points-to 分析** [15] 这类**计算开销巨大**的技术，以保证**可扩展性**。

---

## 10 结论（Conclusion）

本文提出了 **RustSan**：一种为 Rust 程序 **“改造” AddressSanitizer（ASan）** 的设计。**RustSan** 通过对**内存访问点的选择性插桩**，显著提升了 ASan 在 Rust 程序上的性能。核心洞见在于：**大量访问点**在含有 `unsafe` 的程序中依然**保持 Rust 的安全性保证**，因此可以被**识别**并**免除**sanitizer 检查。我们的评估通过**CVE 复现**实证证明了 **RustSan** 的**检测能力**；在**通用应用基准**上，**RustSan** 相比 ASan 展现出 **62.3%** 的性能提升；在**模糊测试**实验中，平均提升为 **23.52%**。


## 附录

### A. CVE case study

我们在此给出若干**案例研究**，分析 Rust 中内存错误的根因以及 **RustSan** 对它们的检测。

<div style="width: 100%; margin: auto; text-align: center;">
  <img src="/assets/images/scholar/RustSan/listing4.png" style="width: 50%;" />
</div>

#### 案例 1：CVE-2018-21000
该 CVE 属于 Rust 对 `transmute` 的实现中的**堆溢出**。问题的根源在 *Listing 4a* 的第 5 行：`Vec::from_raw_parts` 是 Rust 标准库函数，用于从**原始指针**构造新的向量对象，函数参数依次为**向量长度**与**容量**。这里的错误是**第二、第三个参数的顺序被颠倒**。在 Rust 术语中，**容量**（capacity）表示为未来插入元素所预留的**最大空间**，而**长度**（length）表示当前向量中**实际元素个数**。因此，被错误构造的向量极易在后续使用中导致**对象边界之外**的内存访问。在我们的复现中，**RustSan** 报告了在一个**伪安全站点**（false-safe site）上，对一个**不安全对象**触及了**对象末端 redzone** 的访问。

#### 案例 2：CVE-2021-45713
该 CVE 发生在 `rusqlite` 中，是一起**释放后使用（use-after-free）**，由 **unsafe Rust** 中**违背 Rust 对象生命周期保证**引起。在 *Listing 4b* 的第 16 行，`update_hook` API 将闭包**强制转换**为函数指针，并把它**注册**到 `unsafe` 代码块中的**外部（C/C++）库**。`unsafe` Rust 与这些外部库**都不遵守** Rust 的生命周期保证。其结果是：当该**闭包被回调**且相关对象被**销毁**时，产生了**释放后使用**。在本 CVE 的复现中，**RustSan** 在一个**伪安全站点**上报告了对**已隔离（quarantined）的安全对象**的访问。

### B. Taint source reduction with HIR/MIR analysis

![](/assets/images/scholar/RustSan/table6.png)

我们还评估了 **RustSan** 与 **XRust** [38] 在 **HIR/MIR 分析**中用于**污点源（taint source）识别**的方法（即§4中所述的 $I1$ 与 $I2$）。需要注意的是，**XRust** 将 $I1$（即 **所有位于 `unsafe` 代码块中的语句**）**直接**视为污点源；而 **RustSan** 使用的是 $I2$，它是 $I1$ 的**精炼子集**，**只包含写语句**。此外，**RustSan** 能够识别**内联函数**中的语句，而 **XRust** 会**遗漏**这类语句。因而，采用 $I2$ 会**减少**污点源的数量；但与此同时，**把内联函数中的语句也纳入考虑**，又会使 RustSan 的污点源集合**相较 XRust 增加**。即便如此，实验显示 **RustSan** 的污点源集合规模**平均减少了 12.86%**。这意味着 **RustSan** 在 HIR/MIR 阶段输出了**更为精细**的分析结果，**传递**到 LLVM 阶段后，**缓解**了 LLVM IR 分析的复杂度。


### C. Heap allocator microbenchmark

![](/assets/images/scholar/RustSan/figure6.png)

**RustSan** 修改了 **ASan** 的堆分配器，使其按照 **RustSan** 的影子内存（shadow memory）方案为新分配的内存“着色”。  
为衡量**运行期影子内存管理**所带来的开销，我们比较了在 **RustSan** 与 **ASan** 下，对于不同分配尺寸时 `malloc()` 的**平均执行时间**。对每一种内存大小，我们将分配操作（`malloc()`）**重复执行 1000 万次**。

**图6** 展示了实验结果：相对于 **ASan** 的分配器，**RustSan** 的分配器**平均额外开销为 5.52%**。基于该微基准结果，我们认为：在通用应用与模糊测试（fuzzing）基准中，由堆分配器改动引入的影响**可以忽略不计**。

## Citation

