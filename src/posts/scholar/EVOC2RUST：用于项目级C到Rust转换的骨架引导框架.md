---
icon: pen-to-square
date: 2025-10-21
category:
  - Rust
tag:
  - c2rust
---

# EVOC2RUST: A Skeleton-guided Framework for Project-Level C-to-Rust Translation

论文来自 [arXiv预印本](https://arxiv.org/abs/2508.04295)

## 摘要

Rust 在编译期提供的安全性保证，使其非常适合用于安全关键系统，因此对将遗留的 C 代码库迁移到 Rust 的需求不断增长。尽管已有多种方法被提出来完成这一任务，但它们都存在固有权衡：基于规则（rule-based）的方法在满足代码安全性与 Rust 习惯用法方面面临挑战；而基于大语言模型（LLM）的方法由于整个代码库中模块之间存在大量依赖，常常无法生成**语义等价**的 Rust 代码。近期研究表明，这两类方案都主要局限于**小规模程序**。

本文提出 **EVOC2RUST**，一个用于将**整套 C 项目**自动转换为**等价 Rust 项目**的框架。EVOC2RUST 采用一种由**骨架（skeleton）引导**的项目级翻译策略。其流水线包含三个“进化式”的阶段：  
1) 首先将 C 项目分解为功能模块，使用**特征映射（feature mapping）增强**的 LLM 来转换定义与宏，并生成通过类型检查的**函数桩（stub）**，从而形成**可编译的 Rust 骨架**；  
2) 随后**增量式地**翻译各个函数，用翻译结果替换相应的桩占位符；  
3) 最后通过**结合 LLM 与静态分析**来修复编译错误。

凭借这种进化式增强，EVOC2RUST 结合了基于规则方法与基于 LLM 方法的优势。我们在开源基准与**六个工业级项目**上的评估表明，EVOC2RUST 在**项目级 C→Rust 翻译**上具有更优性能：平均而言，相比基于 LLM 的方法，语法与语义准确率分别提升 **17.24%** 与 **14.32%**；相比基于规则的工具，**代码安全率**提高 **96.79%**。在**模块级**上，即使面对复杂代码库与长函数，EVOC2RUST 在工业项目上仍可达到 **92.25%** 的编译通过率与 **89.53%** 的测试通过率。

## 索引词

C-to-Rust Conversion, Project-level Code Translation, Skeleton Guided, Feature Mapping, Large Language Models


## 1. 引言

将遗留的 C 代码库迁移为同等功能的 Rust 项目，已在软件工程领域成为**强烈的现实需求** [1][2]。在实际生产环境中的 C 系统里，**内存安全**相关的漏洞是最常见的一类严重安全缺陷；来自 Google 与 Microsoft 的行业报告显示，这类漏洞约占**高危漏洞的 70% 左右** [3]。这一共识推动了工程实践的范式转变：转向通过**安全的编程语言**在**编译期**提供严格的安全保证 [4]。作为回应，现代系统编程语言 **Rust** 崭露头角，凭借在编译期**强制**执行严格的**所有权/借用模型**，提供内存安全保障，成为领先的替代方案 [5]。

近期工作提出了**基于规则（rule-based）**的工具 [6]–[8]，主要在一种简洁的编译中间表示上施行**以语法为主**的转换，将 C 代码转为 Rust。此类翻译天然容易生成**不符合 Rust 惯用风格**的低层次结构代码，且可能包含**语义不准确**之处 [9]。另一类工作采用**基于大语言模型（LLM）**的方法 [10]–[12]，利用代码 LLM 的理解能力完成翻译。但由于缺乏**成对（平行）的 C↔Rust 训练数据**，且两种语言在语义/风格上差异显著，这些方法常常无法生成**语义等价**的 Rust 代码 [13]。尽管**自动化代码翻译**已被广泛研究 [14]–[16]，**项目级**的 C→Rust 翻译仍面临特殊挑战：

### 挑战一：为保证安全而产生的显著“语言鸿沟”

C 与 Rust 在**安全模型**上存在根本差异：C 允许**宽松的类型检查**、**不受限的指针运算**以及**手动内存管理**；而 Rust 则在编译期强制执行**严格的类型安全**、基于**所有权**的内存安全保证，并通过**借用规则**约束引用的使用。现有**基于规则**的转换器常为达成功能而**牺牲安全性**，依赖**裸指针**、`unsafe` 块或**外部 C 函数** [9]。**基于 LLM** 的方法虽能在一定程度上改进安全性，但常**缺乏充分的上下文理解**（例如变量作用域、指针生命周期等），可能导致逻辑错误或**内存安全违规**，使得译出的 Rust 代码仍不可靠 [17]。因此，**单独**依赖基于规则或基于 LLM 的方法，往往**难以稳定满足** Rust 严苛的安全要求。

### 挑战二：项目级的代码依赖与结构一致性

将**整个 C 项目**完成迁移，远比翻译**孤立函数**更具挑战：译出的 Rust 项目必须**保留跨模块依赖**并维持**一致的项目结构层级** [18][19]。代码类 LLM 往往难以处理如此**大尺度的上下文**，从而引发**引用断裂**、**API 不一致**或**模块边界错误** [9]。结果是，现有方法多仅在**小规模程序**（例如 $\le 100$ 行代码）上表现良好 [10][20]，在**真实项目场景**中表现不足。

---

在本文中，我们提出 **EVOC2RUST**：一个用于将**完整 C 项目**自动翻译为**等价 Rust 代码**的框架。为弥合语言差异并确保安全（对应**挑战一**），EVOC2RUST 以**安全保持（safety-preserving）映射**增强 LLM，覆盖**七类核心语言要素**：**类型（types）**、**宏（macros）**、**函数（functions）**、**运算符（operators）**、**语法结构（syntax structures）**、**全局量（globals）**以及**可变参数（variadic arguments）**。为实现**项目级**翻译（对应**挑战二**），EVOC2RUST 引入 **骨架引导（skeleton-guided）** 的三阶段翻译策略：

1. **分析与分解**：解析输入的 C 项目，抽取高层元数据，并将项目**分解为功能模块**；随后生成一个**可编译的 Rust 骨架**，其中各函数以 **占位桩（stub）** 形式存在。  
2. **增量式翻译**：利用结合了上述**特征映射**的 LLM，**逐步**将这些函数桩翻译为具体实现，并**替换**骨架中的占位符。  
3. **迭代式修复**：将 LLM 与**静态分析**结合，**迭代修复编译错误**并细化输出结果。

这种**进化式**流程有效融合了**基于规则**与**基于学习**两类方法的优势，在自动化 C→Rust 迁移中，于**正确性**与**安全性**之间取得**务实平衡**。

我们在一个名为 **Vivo-Bench** 的开源基准 [21]，以及我们自建、包含 **6** 个工业级项目的数据集 **C2R-Bench** 上评估 **EVOC2RUST**。实验结果表明，EVOC2RUST 在项目级 C→Rust 翻译任务上**显著优于**各类基线方法。与**基于 LLM**的方法相比，EVOC2RUST 在**编译通过率**上平均提升 **$23.72\%$**，在**行级接受率（line acceptance rate）**上平均提升 **$23.05\%$**，同时**代码安全性**也略有优势。与**基于规则**的方法相比，EVOC2RUST 的**代码安全率**平均**高出 $70.19\%$**，而**编译通过率**与**行级接受率**仍保持在**同一竞争水平**。在**模块级**评测中，EVOC2RUST 在工业项目上的**编译通过率**达到 **$92.25\%$**，**测试通过率**达到 **$89.53\%$**。我们的**消融实验**进一步验证了各组件在 EVOC2RUST 中的关键作用，其中**安全保持映射（safety-preserving mapping）**是该方法的**基石**。


主要贡献：

- 我们提出了一种**面向项目级**的 C→Rust 代码翻译新方法，兼顾**语法正确性**、**语义等价性**与**内存安全性**。
- 我们在 C 与 Rust 的**核心语言要素**之间定义了**安全保持映射**，以增强 LLM 的**安全意识**与**约束遵循能力**。
- 我们在**开源场景**与**工业场景**对 EVOC2RUST 进行了系统评测。结果显示，EVOC2RUST **整体优于**现有基线，能够将 C 项目**有效翻译**为**正确且安全**的 Rust 代码。

## 2. 方法（APPROACH）

![](/assets/images/scholar/EVOC2RUST/figure1.png)

图 1 展示了 **EVOC2RUST** 的整体架构，包含三个关键步骤：（1）**骨架构建（Skeleton construction）**：将 C 项目分解为模块，并构建一个用于组装 Rust 模块的 **Rust 项目骨架**（见 §II-A）；（2）**增量式翻译（Incremental translation）**：依据**安全保持的语言映射**翻译骨架中的各个模块（见 §II-B）；（3）**生成后修复（Post-generation repair）**：将基于 LLM 的细化与**静态分析**结合，用于代码优化（见 §II-C）。

### A. 项目骨架构建（Project Skeleton Construction）

一种直接的项目级翻译思路是**逐个函数翻译**，再把它们汇总成项目。然而，**天真地聚合**已翻译的函数常会导致**级联的相互依赖错误**。为此，**EVOC2RUST** 采用**骨架引导**的策略：在**项目元数据**的指导下构建一个**可编译的 Rust 项目骨架**，并**增量式**地用已翻译的函数去填充它。

对给定的 C 项目，EVOC2RUST 使用 **Tree-sitter** [22] 解析**函数签名**、**调用图**、**结构体**与**类型定义**。这些元素被组织为**项目元数据**，包括：文件名、`include` 语句、宏定义、类型声明、全局标识符、函数签名，以及 **“声明 ↔ 源文件”** 的映射表。随后，这些元数据被**系统化地**通过**基于规则**的转换替换为 Rust 等价物。例如：C 的 `include` 依赖被转换为 Rust 的 `use` 导入；标识符声明被转换为 Rust 的 `pub use` 语句（如 `pub use {Rust_filename}::{identifier_name}`），其中文件名由**声明到文件**的映射表提供。

![](/assets/images/scholar/EVOC2RUST/figure2.png)

基于转换后的元数据，EVOC2RUST 构建了一个**忠实保留原始 C 项目结构组织**的 **Rust 项目骨架**（见图 2）。骨架由从 C 的**定义、宏与函数签名**自动翻译得到的 Rust 结构组成。每个 C 函数都会在 Rust 中分配一个**通过类型检查**的**占位“哑函数”**：其签名为翻译后的签名，函数体使用 `unimplemented!()` 宏占位。这样的**占位符**是**安全的替身**，即使函数体尚未翻译，项目也能**先行通过编译**。

这种**骨架引导**的做法，使得函数体可以被**逐步翻译并插入**，从而保证**上下文正确性**，并**消除函数间依赖错误**。因此，即便是**具有复杂模块交互**的大型项目，该流程也能**平滑地**支持翻译、编译与修复。

### B. 基于安全保持映射的模块翻译（Module Translation with Safety-preserving Mapping）

EVOC2RUST 使用 **LLM** 将 C 模块自动翻译为 Rust 结构：先把**定义、宏、函数签名**转换出来以组装骨架，再把**函数体**翻译后**填充**骨架中的占位哑函数。为在翻译过程中**保持安全与语义一致**，EVOC2RUST 用一套**全面的语言映射**来增强 LLM，涵盖**七大类**：

![](/assets/images/scholar/EVOC2RUST/table1.png)

1) **类型映射（Type Mapping）**。对每一种 C 类型，我们都建立了一个对应的 Rust 类型（见表I）。例如，我们引入 `cstr!()` 宏来保证经由该宏得到的所有字符串都**保持以空字节结尾（null-terminated）**的性质，从而避免在**加密/压缩**算法中出现不一致。基于每种 C 类型可用的操作，我们在 Rust 中实现**对应的操作**。鉴于 C 的**指针**支持**加减运算**、**取址**和**下标访问**等，我们在 Rust 中实现了与之对应的 **trait**；对于 C **数组**可**衰变为指针**的特性，我们允许数组通过 `cast()` 方法**转换为指针类型**。

2) **类型转换（Type Conversion）**。我们实现了 `CastIntoTyped` **trait** 来在 Rust 中执行类型转换，涵盖**整数之间**以及**不同指针类型之间**的转换；同时**允许指针→整数**（但**禁止整数→指针**）的转换。示例：`a = (uint16_t)b` 可译为 `a = b.cast::<u16>()`；`pi = (int*)pu` 可译为 `pi = pu.cast::<Ptr<i32>>()`。由于 Rust 具备**类型推断**，我们也允许不带显式类型的 `cast()` 来模拟 C 的**隐式转换**。在**修复阶段**，当需要修正由隐式转换导致的类型错误时，**无类型参数**的 `cast()` 能显著提升 LLM 优化的成功率。

3) **宏/函数映射（Macro/Function Mapping）**。对 C 的原生宏（如 `NULL`、`__LINE__`），我们提供 Rust 端的对等实现。对 C 的原生函数（如 `malloc`、`free`、`memcpy`），我们实现**等价功能的 Rust 函数**，并**优先采用安全方法**，而非直接调用与之**逐字对等**但**不安全**的底层实现（例如用不安全的 `std::ptr::copy` 来实现 `memmove` 仅作为内部细节）。通过简明的提示，LLM 会遵循**将原生 C 函数 `name()` 翻译为 `c_name!()` 宏**的规则。

> 笔者注：简单地基于提示词实现？

4) **语法结构映射（Syntax Structure Mapping）**。Rust 的 `for` 循环与 C 的 `for` 在行为上**并不相同**，直接逐字翻译可能带来**语义错误**；此外，C 的 `do while` 在 Rust 中**没有直接等价物**，而 `switch` 与 Rust 的 `match` 也存在差异，容易诱发**逻辑错误**。为此，我们实现了 `c_for!`、`c_do!`、`c_switch!` 等宏，以**复现 C 的语法与逻辑**；并通过提示引导 LLM 将原始语法**翻译为这些宏**。

5) **运算符映射（Operator Mapping）**。我们为 C 特有的运算符在 Rust 中提供对应实现，包括 `++`、`--`、`&` 与 `sizeof()`。其中，`sizeof()` 被映射为两个宏：`c_sizeof!()` 与 `c_sizeofval!()`。自增/自减被实现为**四个函数**（涵盖**前缀**与**后缀**），适用于**所有整数与指针类型**。我们还要求模型不要把 `&` 翻译为 Rust 的借用运算符 `&` / `&mut`，而是翻译为**获取当前值指针**的 `c_ref!()` 宏。

6) **全局变量映射（Global Variable Mapping）**。在 Rust 中使用**可变的全局变量**（`static mut`）是不安全的，因此我们定义 `Global<T>` 类型来**安全地管理**全局量；其实现内部使用 `Mutex` 来保证**线程安全**，从而**消除不安全代码**的需求。我们还提供 `global!()` 宏以支持**惰性初始化**。

> 笔者注：能否明确地分析出线程安全无同步的情况（例如ThreadLocal）？

7) **可变参数映射（Variadic Argument Mapping）**。可变参数主要用于**日志**和**字符串格式化**。因此我们定义 `VaList` 类型（本质为一个 `Slice`，内部包含对多个实现了 `Display` trait 的值的引用），并提供 `va_format!()` 宏用于字符串格式化。我们还利用可变参数来实现 C 函数（如 `snprintf`）在 Rust 端的**等价物**。

上述**特征映射**均被表述为**转换样式（pattern）**，每个样式明确给出其**动机**、**影响**、**解决方案**及**对应代码示例**（见表II）。通过凝练高级工程师的实践经验，这些样式把**隐性专业知识**固化为**可复用的 C→Rust 迁移规则**。

![](/assets/images/scholar/EVOC2RUST/table2.png)

为引导 LLM 进行**准确且合乎惯用法**的翻译，我们会基于**输入的 C 代码**检索最相关的样式：具体而言，同时对**输入片段**与**样例样式**编码为**稠密向量**，计算**余弦相似度**，选出 **Top-K** 个最接近的样式。随后将这些样式**注入到 LLM 提示词**中，以如下**结构化模板**来约束其输出。

#### （提示模板）将 C 模块翻译为 Rust
~~~ text
将 C 的［macro/definition/function］翻译为 Rust。
Patterns（样式）：{retrieved transformation patterns}
Demonstrations（示例）：{paired C-to-Rust examples}
C Source Code（C 源码）：{input source code}
~~~

### C. 生成后修复（Post-Generation Repair）

最终，**EVOC2RUST** 在编译驱动下对已翻译的 Rust 代码进行**级联式修复**：把**基于 LLM**的修补与**语法规则**相结合。对每段代码片段，它会依据编译器反馈**生成多个修复候选**，只保留那些能够**减少错误计数**的结果，并**迭代**直到无法进一步改进为止。

虽然**基于规则**的方法擅长处理**琐碎且定义清晰**的错误，而 **LLM** 更善于应对**复杂问题**，但我们观察到：一些**持续存在的低层语法错误**（例如**括号/括弧不匹配**）会严重削弱两种修复技术的效果，尤其会让**确定性的规则修正**束手无策。为此，EVOC2RUST 设计了**三步修复链**：

1) **括号修复（Bracket Repair）**  
   使用 LLM 分析**编译输出**与**报错信息**，以修正不匹配的括号及类似的语法问题。提示词包含：修复**指南**、**错误/正确**示例对、当前错误的 Rust 片段以及**对应的编译错误**。

   #### （提示模板）括号修复
   ~~~ text
   请依据下述编译错误信息，修复下面这段 Rust 代码中的编译问题（可能由括号/圆括号不匹配引起）。
   只修复“括号不匹配”的行，不要修改任何其它代码。
   Demonstrations（示例对）：{example pairs of incorrect/correct Rust code}
   Rust Source Code（Rust 源码）：{input source code}
   Compilation Error Messages（编译错误信息）：{input error messages}
   ~~~

2) **规则修复（Rule-Based Repair）**  
   我们将常见的**语法层**问题抽象为一组**基于正则**的转换样式（修复规则），例如：`derive` 宏的调整、去除**冗余的** `cast()` 操作、以及修复像 `s[s.i]` 这类数组访问模式（它会同时触发**可变/不可变借用**冲突）等。

3) **LLM 细化（LLM Refinement）**  
   最后一步继续借助 LLM 处理遗留的**语义差异**与更**复杂的编译级**问题，例如**类型不一致**、**不符合惯用法的用法**或**结构性不一致**。提示词包含：**细化指南**、**示例修复对**、错误的 Rust 翻译及其**编译信息**。

   #### （提示模板）LLM 细化
   ~~~ text
   请依据以下编译信息，修复下面这段 Rust 代码中的编译问题：
   Instruction（细化指南）：{refinement guidelines}
   Demonstrations（示例对）：{example pairs of incorrect/correct Rust code}
   Rust Source Code（Rust 源码）：{input source code}
   Compilation Information（编译信息）：{input compilation information}
   ~~~

## 3. 实验设置（EXPERIMENTAL SETUP）

我们开展实验以评估 **EVOC2RUST** 的有效性，旨在回答以下研究问题：

- **RQ1：** EVOC2RUST 将**完整 C 项目**翻译为**等价且安全**的 Rust 项目有多有效？
- **RQ2：** EVOC2RUST 在**模块级**能够达到怎样的转换准确度？
- **RQ3：** EVOC2RUST 的关键组成模块对其**整体性能**的贡献程度如何？

### A. 比较方法（Comparison Methods）

我们将 EVOC2RUST 与三类 C→Rust 翻译方法进行对比：**基于规则**（C2Rust）、**基于 LLM**（Self-Repair 与 Tymcrat）、以及**混合技术**（C2SaferRust）。此外，我们还引入**不带仓库上下文**的**直接 LLM 生成**作为基线。

具体而言，我们与以下基线进行对比评估：

- **C2Rust** [6]：一种**基于规则**的 C→Rust 翻译器，依赖 **AST 分析**与**手工定义**的转换规则完成迁移。
- **C2SaferRust** [23]：一种**混合式**方法，在 C2Rust 框架之上融合 **LLM 驱动的后处理**，并采用**测试驱动的优化**来提升生成 Rust 代码的**惯用性**与**安全性**。我们采用原工作默认配置，进行 **5** 轮优化迭代。
- **Self-Repair** [24]：一种**多智能体自修复**框架，面向**项目规模**的 C→Rust 翻译；在**文件级**翻译中引入**迭代式编译-测试反馈**以自动修错。我们使用默认设置：每个任务进行 **3** 轮自修复（含编译驱动与测试驱动两类修复）。
- **Tymcrat** [25]：一种**项目级**翻译方法，通过**类型迁移**、为每个函数生成**多个候选 Rust 签名**，并结合**编译器反馈**迭代解决类型错误，从而提高翻译质量。我们采用默认配置：**每个函数输出 4 个候选签名**。
- **LLM-direct**：一种**零样本提示**的直接 C→Rust 翻译基线。为缓解其在**项目一致性**与**依赖解析**方面的先天不足，我们将该方案**嵌入到我们的项目骨架构建框架**之中实现。

所有基线均基于其**官方发布代码**实现。为确保公平比较，我们将其原始**主干模型**统一替换为 **DeepSeek-V3** [26]。

### B. 评估策略与指标（Evaluation Strategy and Metrics）

我们在**项目级**与**模块级**两种粒度评估 C→Rust 翻译性能。

#### 项目级评估（Project-level Evaluation）

我们在项目级翻译上与各基线进行对比。为模拟**真实场景**中**缺少标准实现**的情况，我们从基准中**移除所有参考实现**。评测遵循一种**增量式的编译验证策略**：先构建包含**占位 Rust 模块**的**项目骨架**，随后**逐步**以翻译代码替换这些占位模块，并在每次替换后进行编译验证；任一失败的模块会**回退**为原占位实现。

项目级性能通过三项指标衡量：

- **Incremental Compilation Pass Rate（ICompRate）**：当模块被**增量集成**进项目骨架时，**成功通过编译**的模块比例，用以度量语法正确性（定义见 [18]）。
- **Line Acceptance Rate（AccRate）** [27]：考虑到**整个项目**的编译难度，我们评估翻译代码与**人工校正版本**的一致性。**Precision** 统计初次翻译中**未被修改**的行，**Recall** 统计这些行在最终**验证解**中的保留情况。
- **Code Safe Rate（SafeRate）** [28]：生成 Rust 代码中**内存安全语句**所占的比例。

#### 模块级评估（Module-level Evaluation）

我们进一步通过一种**填空式验证策略**评估模块级的转换准确度：对测试集中的每个 C 模块（如 `Func_C`），若存在已知的 Rust 等价实现（如 `Func_R`），则从 Rust 参考实现中**移除** `Func_R`，使用翻译方法由 `Func_C` 生成 `Func_R'`，将其集成到**部分 Rust 项目**中，并通过**编译与测试用例**验证其正确性。

模块级的**语法与语义**正确性通过两项指标衡量：

- **Fill-in Compilation Pass Rate（FCompRate）**：当把生成模块**替换**至 Rust 参考实现中对应位置时，能够**成功编译**的模块比例。
- **Test Pass Rate（TestRate）** [24]：在上述替换条件下，能够**通过全部对应测试用例**的模块比例。

### C. 数据集（Datasets）

我们在 **Vivo-Bench** [21] 开源数据集与自建的 **C2R-Bench**（包含 6 个工业级项目）上评估 **EVOC2RUST**。  
**Vivo-Bench** 来自 *2025 Vivo C-to-Rust 创新竞赛*，包含 19 个算法型 C 项目，覆盖 **200** 个函数、**95** 个定义与 **29** 个“非函数”宏。这些项目由 **1–3** 个文件组成，单文件代码行数（LOC）从 **33** 到 **630** 不等。两位 Rust 开发者在 LLM 的辅助下通过修错与补测，产出经验证的译文，确保**函数级完整覆盖**，共得到 **113** 个顶层测试用例。

为了评估**工业场景**，我们构建了 **C2R-Bench**：来自华为软件生态的 **6** 个**生产级** C 项目的基准。所选项目均为**单线程**的**用户态应用**，仅依赖**标准 C 库**。这些项目具有**多文件架构**与显著的**跨文件依赖**，源码规模从 **280** 到 **3,724** LOC 不等。三位高级开发者采用**LLM 辅助翻译**产出参考实现，随后通过执行 **222** 个顶层测试用例来验证 Rust 输出。

Vivo-Bench [21] 与 C2R-Bench 中的每个项目均包含 4 个关键组成：**C 源码、C 测例、Rust 翻译结果**以及**对应的 Rust 测试用例**。详尽统计见表III。

![](/assets/images/scholar/EVOC2RUST/table3.png)

### D. 实现细节（Implementation Details）

我们以 **DeepSeek-V3** [26] 作为基础模型实现 **EVOC2RUST**，利用其在多种编程语言（含 C 与 Rust）上的大规模预训练，以加强**跨语言理解**。  
用于**代码翻译**时，我们配置模型为**贪心解码**（greedy decoding），并设置 $ \text{max\_tokens} = 4096 $。  
用于**代码分析**时，我们采用 **Tree-sitter v0.22.3** [22] 解析 C 项目，并使用 **rustc** [29] 作为 Rust 编译器。  
我们使用 **BGE-M3** [30] 生成代码向量表征，通过**余弦相似度**检索**最相近的 Top-10** 个转换样式（patterns）。在**效率**与**效果**之间做权衡，我们将修复迭代上限设为：**括号修复 5 轮**，**LLM 细化 3 轮**。

为测量**行级接受率**（AccRate），我们为所有评测方法**人工建立并验证**参考实现。遵循严格的验证流程：由 3 位作者分别使用目标方法对每个项目的源码与测试套件完成**完整翻译**；生成的 Rust 代码先进行**编译与测试**，随后在 **Claude Sonnet 4** [31] 的交互式辅助下**手动迭代修正**，直到**全部测试通过**。最后，另外 3 位工程师对这些参考实现进行**代码评审**，以再次确认其**语义正确性**。

所有实验均在 Linux 服务器上进行：**Ubuntu 23.10**，两块 **NVIDIA GeForce RTX 4090** GPU，**CUDA 12.4**。

## 4. 结果与分析（RESULTS AND ANALYSIS）

### A. 主要结果（RQ1）

EVOC2RUST 的主要实验结果见表IV。它在两个数据集上**全面优于**所有基线方法，在三项综合指标上均取得**最高分**。

![](/assets/images/scholar/EVOC2RUST/table4.png)

与**基于规则**与**混合式**基线相比，EVOC2RUST 在**生成安全的 Rust 代码**方面展现出显著优势。尽管 **C2Rust** 与 **C2SaferRust** 在**编译通过率**上接近完美（例如在 Vivo-Bench 上为 100%），它们**容易生成不安全代码**：在两个数据集上的**代码安全率**，C2Rust 仅为 **0%** 与 **1.83%**；C2SaferRust 即便结合了 LLM 的优化，也仅达到 **60%** 与 **48.24%**。这说明：**单纯的语法级翻译**，即使叠加 LLM 的后处理，也**无法稳定满足** Rust 的安全要求。我们的方法通过**由“安全保证”的特征映射增强的 LLM 翻译**，**主动抑制**不安全代码的产生。

在**基于 LLM**的方法中，EVOC2RUST 在所有评测指标上也保持**稳定领先**。在 **Vivo-Bench** 上，它的**编译成功率**比所有基线**高出 12.65%～64.51%**，**行级接受率**高出 **7.57%～46.30%**，同时仍保持 **98%** 的高**代码安全率**。在更具挑战的 **C2R-Bench** 上，它实现 **93.84%** 的编译成功（**比各基线高 21.82%～44.63%**），且**行级接受率超过 97%**。这些优势源自我们**骨架引导**、**特征映射增强**的翻译路径。

更具体地，与 **Self-Repair** 相比，EVOC2RUST 在 **C2R-Bench** 上的**编译成功率**提升 **44.63%**，**行级接受率**提升 **54.38%**。Self-Repair 的**文件级处理**经常超过 DeepSeek-V3 的 **4096** token 输出上限，导致**代码截断**与**程序不完整**这一关键限制。与 **Tymcrat** 相比，EVOC2RUST 在更具挑战的 C2R-Bench 上**编译成功率**也高出 **21.82%**。Tymcrat 通过**多样化签名生成**与**上下文增强**降低初始错误，但因为缺少**专家提炼的结构化翻译指导**，在复杂场景中效果受到限制。**LLM-direct** 表现最差：平均**编译成功率**仅 **46.08%**；**行级接受指标**也偏低（**Precision 55.40%**、**Recall 52.33%**），其原因在于 **C↔Rust 语言差异**与**Transformer 上下文窗口**的先天约束。

> 笔者注：这里的数据有点乱啊，和表格里的很多都对不上，比如55.40%从未在表格里出现

> **RQ1 的回答。** 在将**完整 C 项目**翻译为 Rust 的任务上，EVOC2RUST 在两个数据集上相较所有基线方法**始终占优**，并在**编译成功**、**行级接受**与**代码安全**三项指标的综合得分中居首。

---

### B. 模块级翻译（RQ2）

我们进一步针对 EVOC2RUST 的**模块级代码翻译准确度**进行专门评估——这是该方法的**核心技术组件**之一。评估在 **Vivo-Bench** 与 **C2R-Bench** 上进行，并采用两种基础模型：**DeepSeek-V3** 与 **Qwen3-32B** [32]，以覆盖不同的模型规模与架构范式。

![](/assets/images/scholar/EVOC2RUST/table5.png)

如表V所示，EVOC2RUST 在**模块粒度**上表现突出：  
在 **DeepSeek-V3** 下，它在 **Vivo-Bench** 上达到 **100%** **编译通过**与 **99.07%** **测试通过**；在 **C2R-Bench** 上也保持稳健（**92.25%** 编译通过，**89.53%** 测试通过）。即便在参数量小 **20×** 的 **Qwen3-32B** 上，EVOC2RUST 仍取得**可接受**结果（**80.63%** 编译通过，**77.91%** 测试通过），显示出**对模型规模的鲁棒性**。

值得注意的是，**测试通过率**与**编译成功率**之间呈现**高度一致**：能正确编译的 Rust 模块通常也能通过测试。这一一致性来自我们方法的**双重机制**：**特征映射**抑制语义错误，**编译器引导的修复**维持逻辑正确的纠错过程。

我们的评估还揭示了影响翻译质量的**两个关键因素**：**项目复杂度**与**函数长度**。复杂项目（控制流与数据依赖精细、宏与依赖繁多）会持续挑战 LLM 的理解能力——这在我们对 C2R-Bench 中 6 个工业项目的分析中得到体现。例如，**cmpt1z** 项目（复杂宏与依赖）在不同模型下的**测试通过率**为 **86.35%** 与 **70.79%**；而更“简单”的 **sha256** 则稳定达到 **100%**。此外，**函数长度**与**翻译成功**显著**负相关**（见图 3）：

![](/assets/images/scholar/EVOC2RUST/figure3.png)

对 **DeepSeek-V3**，随着函数变长，测试通过率从 **97.46%** 降至 **81.13%**；  
对 **Qwen3-32B**，下降更加明显——从 **88.68%** 至 **41.96%**。  
尽管存在这种随长度下降的趋势，EVOC2RUST 在 **DeepSeek-V3** 下的**平均通过率**仍达 **94.02%**，表明即便面对**长函数**也具备**良好鲁棒性**。

> **RQ2 的回答。** 我们的方法在**模块级翻译**上表现稳健：在不同模型规模下的**编译成功率**为 **92.25%～100%**、**测试通过率**为 **77.91%～99.07%**，证明其在应对**代码复杂度**与**函数长度**挑战时同样有效。

### C. 消融实验（RQ3）

为评估 **EVOC2RUST** 各组件的贡献并验证我们的设计选择，我们进行**消融实验**：逐步移除方法中的关键组件——**括号修复**、**规则修复**、**LLM 细化**与**特征映射**。我们基于 **DeepSeek-V3** 作为基础模型，在 **C2R-Bench** 数据集上评估各变体。

![](/assets/images/scholar/EVOC2RUST/table6.png)

如表VI 所示，EVOC2RUST 的每个组件都对整体效果至关重要。其中，**特征映射**机制影响最大：一旦移除，该机制，**ICompRate** 与 **FCompRate** 将分别从 **74.29%** 降至 **56.67%** 与从 **81.06%** 降至 **33%**；对**语义正确性**的影响同样显著，**TestRate** 从 **79.91%** 降至 **30.27%**。这强调了特征映射在**桥接 C 与 Rust 结构差异**方面的重要性：通过**预定义转换样式**将 C 的惯用法映射到**安全的** Rust 等价实现，尤其在缺少一一对应构造时更为关键。

**级联修复链**也显著促进了 C→Rust 的翻译质量。若同时移除三种修复（`-w/o repair#1-3`），性能将明显下降：**ICompRate** 降低 **19.55%**、**FCompRate** 降低 **11.19%**、**TestRate** 降低 **9.62%**。在这条链路中，**规则修复（repair#2）**贡献最大：平均提升**编译通过率** **9.68%**、**测试通过率** **4.45%**。**LLM 细化（repair#3）**在此基础上进一步带来 **4.27%** 的**语法**收益与 **8.98%** 的**语义**收益，且不会牺牲代码安全。

值得注意的是，在大多数消融变体中，**代码安全**基本稳定在 **≈97%**，这归功于特征映射机制：它将**低层操作**封装进**经验证的安全构造**中，从而保证**不安全代码**比例稳定（安全分仅有 **≤1%** 的轻微波动）。然而，**无引导的直接生成**（同时**缺失映射与修复**）会使安全性**骤降**到 **82.43%**，从反面证明了我们机制的必要性。

> **RQ3 的回答。** EVOC2RUST 的每个组件都对总体性能**有显著贡献**。其中，**特征映射**为弥合 C↔Rust **语义鸿沟**提供了**安全且可靠**的底座；而**级联修复链**进一步**清除残余错误**，最大化**语法与语义正确性**。

---

### D. 案例研究（Case Study）

![](/assets/images/scholar/EVOC2RUST/figure4.png)

我们选取红黑树的核心函数 `rb_tree_rotate` 作为案例（见图4），展示 **EVOC2RUST** 的有效性。该函数涉及的**复杂指针操作**代表了**低层 C 代码**中**最难以**安全、正确翻译的一类场景，也揭示了其他方法常见的失效模式。

如图 4 所示，基线方法在此场景中表现不佳：  
**LLM-direct** 因**项目级接口不匹配**而失败——在需要**可变引用**（`&mut`）的地方传入了**裸指针**（`*mut`）。这暴露出其**缺乏项目级上下文感知**；且依赖裸指针会不可避免地引入 `unsafe` 块，从根本上**削弱内存安全**目标。**Self-Repair** 虽尝试以 `Box<T>` 进行更符合 Rust 惯用法且更安全的翻译，但在函数层面引入了**所有权错误**（例如 *use of moved value*），说明在**缺乏系统化框架**的情况下，手工将 **C 风格内存管理**重构为**安全的 Rust 惯用法**非常困难。

相较之下，**EVOC2RUST** 生成了**正确且稳健**的译文。其成功源于我们的**特征映射**：使用统一的 **`Ptr<T>` 智能指针**在**项目范围内**保持**C 式指针语义**与**类型一致性**；再结合**灵活的**`.cast()` **类型转换**方法，同时解决了**接口不匹配**与**所有权**两类导致其他方法失败的问题。通过将**低层 C 操作**系统化地映射到**安全的抽象层**，EVOC2RUST 在其他方法难以奏效的地方，依然能够产出**正确且完全安全**的翻译。

> 笔者注：体现了引入对等抽象层的重要性（`Ptr<T>`对应c语言的指针，`.cast()`对应c语言的任意类型转换）

## 5. 讨论（DISCUSSION）

### A. 为什么 **EvoC2RUST** 有效？

**EvoC2RUST** 将 LLM 的能力、多智能体协作、知识增强技术、静态程序分析与基于规则的转换**综合进一个统一框架**，用于自动化的项目级 C→Rust 翻译。其有效性主要来源于以下三点：

1) **骨架引导的翻译（Skeleton-guided Translation）。**  
   **EvoC2RUST** 利用程序分析将大型 C 项目**分解为可复用的模块组件**，为模块装配生成一个**可编译的 Rust 骨架**，并通过**将已转换的 Rust 代码插入骨架结构**来执行**增量式的函数级翻译**。这种骨架引导策略使得翻译、编译与修复都与原始项目结构保持一致，并且**在 LLM 的上下文窗口限制内**完成，同时允许**并行的模块翻译**而不被**跨模块依赖**牵制。

2) **特征映射（Feature Mapping）。**  
   **EvoC2RUST** 通过带有**安全保证**的特征映射，引导 LLM 弥合 C→Rust 的**语义鸿沟**，覆盖 **types、macros、functions、operators、syntax structures、globals、variadic arguments** 等要素。按需**动态检索**的映射使 LLM 能对齐到**精确的一一对应**，从而**有效抑制幻觉**。

3) **级联的生成后修复（Cascading Post-Generation Repairs）。**  
   在 LLM 完成初译之后，**EvoC2RUST** 采用**以编译为驱动**的级联修复机制：（1）在**编译检查**的保障下**迭代细化** Rust 代码；（2）将 **LLM 的语义理解** 与 **基于规则的语法修正** 协同起来；（3）提供**可扩展的体系结构**，以便在未来**集成新的修复技术**。

---

### B. 局限性与效度威胁（Limitations and Threats to Validity）

我们识别出以下对本方法效度的限制与潜在威胁：

**内部效度（Internal Validity）。**  
主要威胁来自**正确性验证**目前依赖预定义的测试用例。若采用更健壮的验证技术，如 **fuzzing** [33] 与 **self-debugging** [34][35]，可提升测试覆盖率并发现**细微的语义错误**。在**行级接受率**的度量上，我们使用由 **Claude** 生成、并经**人工专家复核**的结果作为**真实标注**。此类人工验证确保了超越自动化测试的正确性，但**在更大规模数据集上可能难以扩展**。未来工作应探索**半自动化验证**，在**准确性**与**效率**间取得平衡。

**外部效度（External Validity）。**  
外部效度主要受两方面威胁：  
1) **可泛化性（Generalizability）。** 虽然我们的翻译流水线被设计为可支持**多语言对**，但当前实现**专注于 C→Rust**，以便推动**项目级迁移研究**。受资源限制，当前评测仅涉及 **DeepSeek-V3** 与 **Qwen3-32B** 两个基础模型。这一选择并不影响对**框架本身**的评估有效性——本文的重点在于**方法架构**而非**模型对比**。我们明确指出，**引入更多模型**进行扩展评测是重要的后续方向。  
2) **数据集特性（Dataset characteristics）。** 我们的评估使用了**开源 Vivo-Bench** 与**工业级 C2R-Bench**；然而，这两类数据集目前**限定为单线程、用户态 C 项目**，并依赖 **ISO C 标准库**。未来工作应进一步覆盖更复杂的场景，例如**多线程**、**第三方库**以及**内核态代码**。

## 6. 相关工作（RELATED WORK）

### A. C→Rust 翻译

现有的自动 C→Rust 翻译方法大致分为三类：**基于规则**、**基于 LLM** 与**混合式**技术。

**基于规则的翻译。**  
此类方法通过分析程序语法并**手工设计**转换规则来完成程序变换，常见如基于 AST 的转换。开源转译器 **C2Rust** [6] 即是代表：借助 Clang 的 AST 生成**语义等价**的 Rust 代码。然而，它往往产生**非惯用**的 Rust 代码，并且在几乎所有函数签名上都需要 `unsafe`。鉴于这些局限，后续研究提出了有针对性的改进：Emre 等 [20][36] 将 **rustc** 的编译反馈引入以提升**指针安全**；Zhang 等 [7] 对指针操作进行**静态所有权分析**；Ling 等 [28] 以**模式匹配**做**源码到源码**的 API 安全转换；Hong 等 [8][37]–[39] 则通过自定义分析处理一系列特定构造，如**锁 API**、**输出参数**、**联合体**与 **I/O API**。此外，Han 等 [40] 用 **C 风格语法糖**在 Rust 中模拟控制流差异；Fromherz 等 [41] 给出将 C 的一个**子集**形式化翻译到**安全的** Rust。然则，这些方法通常需要专家投入大量时间**手工编写规则**；而最终生成的目标程序常常在**可读性**与**安全性**上仍显不足。

**基于 LLM 的翻译。**  
近年，大语言模型因**无需手工规则**即可生成**更合乎惯用法**的代码，而在代码翻译上展现潜力。Eniser 等 [10] 提出 **FLOURINE**，利用 **fuzz 测试**在无需现有测试用例的情况下验证译后 Rust 与原始 C 代码的**语义等价**；Yang 等 [11] 使用 **MSWasm** 的测试框架，将其适配到**多语言（含 C）→Rust** 的翻译；Nitin 等 [12] 将**静态规格**、**I/O 测试**与**自然语言描述**结合以增强 LLM 翻译；Farrukh 等 [42] 构建了一个**多智能体框架**，进行**迭代式纠错**。不过，相较基于规则的方法，当前基于 LLM 的方法在**翻译准确率**上仍偏低，主要原因在于缺乏**大规模 C↔Rust 平行语料**，难以弥合两种语言的**根本语义差异** [13]。

**混合式技术。**  
近期研究显示，将**基于规则**与**基于 LLM**的方法结合，能在 C→Rust 翻译中发挥互补优势。例如 **C2SaferRust** [23] 采用 **LLM 后处理**对 C2Rust 的输出进行**迭代细化**，在**自动化验证测试**的帮助下同时提升**安全性保证**与**代码惯用性**，并保持**功能等价**。在此基础上，**EvoC2RUST** 提出一种**新的混合框架**：在**两阶段**中协同整合**基于规则**与**基于 LLM**的方法。翻译阶段用**语言特征映射（即转换规则）**引导 LLM 解决 C→Rust 的**语义差异**；修复阶段采用**以编译为驱动**的**级联修复**机制，将 LLM 的**语义理解**与**基于规则的语法修正**结合，优化生成 Rust 代码的整体质量。我们的方法在**翻译准确性**与**安全保证**之间取得了**务实的平衡**，以支持自动化的 C→Rust 迁移。

### B. 以 LLM 实现的项目级代码翻译

尽管多数现有方法聚焦于**小规模**的 C 代码翻译，近来的工作开始探索**项目级** LLM 翻译。其做法通常是：先通过程序分析将 C 项目分解为**基于依赖**的翻译单元，再进行翻译并**重新装配**为可运行的 Rust 项目。

Shiraishi 等 [18] 率先开展了项目级翻译，利用**项目元数据**维持跨单元的一致性；但其主要关注**编译成功**，并未确保**功能等价**。**Syzygy** [19] 与 **RustMap** [43] 同时翻译 C 函数及其关联测试，并利用**编译/测试反馈**修复生成的 Rust 代码；但它们需要关于目标函数的**完整依赖上下文**，这并非总能自动抽取，有时还需要**人工补充**（例如 RustMap 的 “ASK Me” 机制）。此外，其**测试与分析框架**在工业场景下面对**复杂特性与数据结构**（如**复杂对象结构**与**循环引用**）时，**可扩展性受限**。

Khatry 等 [24] 与 Ou 等 [13] 构建了**仓库级**的 C/C++→Rust 评测基准，并配套了诸如 **Self-Repair** 等技术。然而，它们的方法依赖**带标注的 Rust 函数接口**，而这在工业场景中**很少可用**。为缓解该限制，Hong 等 [25] 提出 **Tymcrat**，一种基于**类型推断**的**自动函数签名翻译**方法。

不同于按依赖顺序**串行**翻译模块、且需要完整项目上下文的做法，**EvoC2RUST** 引入了**骨架引导**策略：首先构建一个**可编译的 Rust 骨架**，然后执行**增量的函数级翻译**。该策略不仅支持**并行翻译**，还通过**将 LLM 与跨模块依赖解耦**来降低翻译复杂度，从而**提升翻译正确性**。

## 7. 结论（CONCLUSION）

我们提出 **EvoC2RUST**，一个由 LLM 驱动的**整项目** C→Rust 自动翻译新框架。EvoC2RUST 采用**特征映射增强**的 LLM 实施**骨架引导**的代码翻译，并在此基础上结合 **LLM 能力**与**静态分析**进行**混合式错误修复**。在开源与工业两类基准上，EvoC2RUST 在**语法准确性**、**语义等价性**与**内存安全性**方面均表现出**持续领先**的性能。

尽管近年已有进展，C→Rust 翻译仍是一个**开放挑战**，尤其在涉及**多线程**、**第三方库**以及**内核态代码**等跨领域复杂场景时更为困难。为推动该领域发展，我们提出两条关键的研究方向：  
(1) **开发新的细化技术**，充分利用持续演进的 LLM 能力（例如 **fuzzing** [33] 与**自调试** [34][35] 等）；  
(2) **探索将语言模型作为自主智能体** [44] 的路径，使其具备**多步推理**与**反思**能力，以更好地处理复杂的翻译任务。  
这些方向为后续研究提供了**有前景的路线**。


## Reference

### Translating C to safer Rust

> PACMPL – OOPSLA 2021（OOPSLA 专刊）、CCF A

### Aliasing Limits on Translating C to Safe Rust

> PACMPL – OOPSLA 2023（OOPSLA 专刊）、CCF A

### Forcrat: Automatic I/O API Translation from C to Rust via Origin and Capability Analysis

> [arXiv预印本](https://arxiv.org/abs/2506.01427)

### To Tag, or Not to Tag: Translating C's Unions to Rust's Tagged Unions

> ASE 2024（IEEE/ACM International Conference on Automated Software Engineering）、CCF A

