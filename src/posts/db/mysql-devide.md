---
icon: pen-to-square
date: 2025-03-01
category:
  - MySQL
---

# MySQL 分表分库中的 Sharding 策略详解

在@pdai的这篇[文章](https://pdai.tech/md/db/sql-mysql/sql-mysql-devide.html)中提到，`MySQL`中`Sharding`策略主要分为三种：哈希取模、范围分片和映射表。
但作者没有细讲各自的优缺点以及应用场景，在此总结了一下：

## deepseek的思考过程
> 嗯，我需要详细介绍一下MySQL分表分库中的Sharding策略，特别是哈希取模、范围分片和映射表这三种方法。首先，我得确保自己理解这些策略的基本概念，然后考虑如何向别人解释清楚。让我先回忆一下相关知识，再逐步整理思路。
>
> 　
> 首先，分表分库的目的是为了应对数据量过大，单库单表性能瓶颈的问题。Sharding策略就是如何将数据分布到不同的数据库或表中的方法。常见的策略有哈希取模、范围分片和映射表三种。我需要分别解释这三种策略，包括它们的原理、应用场景、优缺点以及可能的示例。
>
>　
> 对于哈希取模，记得这是通过某个键（比如用户ID）的哈希值对数据库数量取模来决定数据存储的位置。比如，假设有4个数据库，计算hash(key) % 4，结果0到3分别对应不同的库。这样做的好处是数据分布均匀，避免热点问题。但缺点是可扩展性差，增加或减少库数量时需要重新分配数据，迁移成本高。应用场景可能适合需要均匀分布且不常变动的分库情况。
>
> 　
> 然后是范围分片，这可以基于ID范围或者时间范围。比如，用户ID在1-1000万的放在第一个库，1000万到2000万在第二个库，或者按月份分片。优点在于易于管理，查询范围数据时效率高，因为同一范围的数据在同一库或表中。缺点是可能存在数据分布不均，比如某些时间段数据量大，导致负载不均衡。适用于有明显范围查询需求的场景，比如按时间查询日志。
>
> 　
> 接下来是映射表，也就是使用一个单独的数据库来存储映射关系。例如，每个用户ID对应的存储位置记录在一个表中，查询时先查映射表找到位置，再访问对应的库。这种方法的优点是灵活，可以根据需要调整映射关系，扩展性好。但缺点是多了一次查询，可能影响性能，而且映射表本身可能成为单点故障或瓶颈。适合需要灵活分片，或者分片键不固定的情况。
>
> 　
> 在解释这三种策略时，应该分别给出它们的原理、步骤、优缺点、适用场景，以及可能的例子。同时需要注意比较它们之间的不同，帮助读者理解在什么情况下选择哪种策略。
>
> 　
> 可能需要注意的细节：哈希取模的哈希函数选择，如何处理节点增减时的数据迁移；范围分片如何定义范围边界，避免热点；映射表如何设计高效查询，避免成为性能瓶颈等。
>
> 　
> 现在需要把这些点组织成结构化的内容，确保逻辑清晰，语言通俗易懂。可能需要分段，每部分一个小标题，用列表或段落详细说明。同时，可能需要用示例来辅助说明，比如哈希取模的计算过程，范围分片的划分例子，映射表的结构等。
>
> 　
> 最后，总结部分要比较这三种策略的适用场景，帮助用户根据实际需求选择合适的方案。可能还需要提到其他策略，但根据问题要求，重点在哈希、范围和映射表这三种。

---

在分库分表架构中，**Sharding 策略**决定了数据如何分布到不同的数据库或表中。常见的策略包括**哈希取模**、**范围分片**和**映射表**，每种策略适用于不同场景，各有优缺点。

---

## 1. **哈希取模（Hash Sharding）**
**原理**：  
对分片键（如用户ID）计算哈希值，再对数据库/表的数量取模，确定数据存储位置。  
**公式**：`分片位置 = hash(key) % NUM_DB`  
**示例**：  
- 若分片键为 `user_id`，且 `NUM_DB=4`，则：  
  - `hash(1001) % 4 = 2` → 数据存入第 2 个库。  
  - `hash(1002) % 4 = 0` → 数据存入第 0 个库。  

**优点**：  
- 数据分布均匀，避免热点问题。  
- 查询单条数据时效率高（直接定位库/表）。  

**缺点**：  
- **扩展性差**：增减节点时（如从 4 库扩容到 5 库），需重新计算所有数据位置，迁移成本高。  
- **范围查询效率低**：跨多个库的查询需合并结果。  

**适用场景**：  
- 数据分布均匀且无频繁范围查询的场景（如用户表）。  

---

## 2. **范围分片（Range Sharding）**
**原理**：  
按分片键的范围（如ID区间或时间范围）划分数据。  
**示例**：  
- **ID范围**：  
  - 库1存储 `1 ≤ user_id < 1000万`  
  - 库2存储 `1000万 ≤ user_id < 2000万`  
- **时间范围**：  
  - 按月分片：`2023-01` 数据存入表1，`2023-02` 存入表2。  

**优点**：  
- **易于管理**：数据按自然边界划分，维护简单。  
- **高效范围查询**：同一范围的数据集中存储（如查询某月订单）。  

**缺点**：  
- **数据分布不均**：可能导致热点（如某时间段数据激增）。  
- **冷热数据分离**：旧数据访问频率低，但依然占用资源。  

**适用场景**：  
- 有明显范围特征且需高效范围查询的场景（如日志表、历史订单）。  

---

#### 3. **映射表（Lookup Table）**
**原理**：  
使用独立的数据库存储分片键与存储位置的映射关系，查询时先查映射表定位数据位置。  
**示例**：  
- 映射表结构：  
  | user_id | db_id  | table_id |  
  |---------|--------|----------|  
  | 1001    | db2    | table3   |  
  | 1002    | db0    | table1   |  

**优点**：  
- **灵活性强**：可动态调整分片规则，扩展无需迁移数据。  
- **支持复杂分片**：如按业务类型、地理位置等非数值键分片。  

**缺点**：  
- **性能瓶颈**：每次查询需先访问映射表，增加一次查询开销，映射表容易成为性能瓶颈。
- **单点故障风险**：映射表若宕机，整个系统不可用。  

**优化方案**：  
- 缓存映射关系（如Redis）减少数据库查询。  
- 对映射表做高可用设计（如主从复制）。  

**适用场景**：  
- 分片规则复杂或需要动态调整的场景（如多租户系统）。  

---

### **对比与选型建议**
| **策略**     | **均匀分布** | **扩展性** | **范围查询** | **适用场景**               |  
|--------------|--------------|------------|--------------|----------------------------|  
| 哈希取模     | ✅            | ❌          | ❌            | 高并发单点查询（用户表）   |  
| 范围分片     | ❌            | ✅          | ✅            | 按时间或ID区间查询（日志） |  
| 映射表       | ✅            | ✅          | ❌            | 动态分片（多租户系统）     |  

**实际应用**：  
- **混合策略**：如先按时间分库，再按哈希分表，兼顾范围查询与负载均衡。  
- **工具支持**：借助ShardingSphere、Vitess等中间件自动化分片逻辑。  

通过合理选择Sharding策略，可显著提升系统的扩展性和查询效率，但需权衡数据分布、查询模式及运维成本。




## Ref
- https://pdai.tech/md/db/sql-mysql/sql-mysql-devide.html
